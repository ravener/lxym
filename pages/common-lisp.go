
package pages

const Common_Lisp = "Common Lisp is a general-purpose, multi-paradigm programming language suited for a wide variety of\nindustry applications. It is frequently referred to as a programmable programming language.\n\nThe classic starting point is [Practical Common Lisp](http://www.gigamonkeys.com/book/). Another\npopular and recent book is [Land of Lisp](http://landoflisp.com/). A new book about best practices,\n[Common Lisp Recipes](http://weitz.de/cl-recipes/), was recently published.\n\n\n\n```lisp\n\n;;;-----------------------------------------------------------------------------\n;;; 0. Syntax\n;;;-----------------------------------------------------------------------------\n\n;;; General form\n\n;;; CL has two fundamental pieces of syntax: ATOM and S-EXPRESSION.\n;;; Typically, grouped S-expressions are called `forms`.\n\n10            ; an atom; it evaluates to itself\n:thing        ; another atom; evaluating to the symbol :thing\nt             ; another atom, denoting true\n(+ 1 2 3 4)   ; an s-expression\n'(4 :foo t)   ; another s-expression\n\n\n;;; Comments\n\n;;; Single-line comments start with a semicolon; use four for file-level\n;;; comments, three for section descriptions, two inside definitions, and one\n;;; for single lines. For example,\n\n;;;; life.lisp\n\n;;; Foo bar baz, because quu quux. Optimized for maximum krakaboom and umph.\n;;; Needed by the function LINULUKO.\n\n(defun meaning (life)\n  \"Return the computed meaning of LIFE\"\n  (let ((meh \"abc\"))\n    ;; Invoke krakaboom\n    (loop :for x :across meh\n       :collect x)))                    ; store values into x, then return it\n\n;;; Block comments, on the other hand, allow for free-form comments. They are\n;;; delimited with #| and |#\n\n#| This is a block comment which\n   can span multiple lines and\n    #|\n       they can be nested!\n    |#\n|#\n\n\n;;; Environment\n\n;;; A variety of implementations exist; most are standards-conformant. SBCL\n;;; is a good starting point. Third party libraries can be easily installed with\n;;; Quicklisp\n\n;;; CL is usually developed with a text editor and a Read Eval Print\n;;; Loop (REPL) running at the same time. The REPL allows for interactive\n;;; exploration of the program while it is running \"live\".\n\n\n;;;-----------------------------------------------------------------------------\n;;; 1. Primitive datatypes and operators\n;;;-----------------------------------------------------------------------------\n\n;;; Symbols\n\n'foo ; => FOO  Notice that the symbol is upper-cased automatically.\n\n;;; INTERN manually creates a symbol from a string.\n\n(intern \"AAAA\")        ; => AAAA\n(intern \"aaa\")         ; => |aaa|\n\n;;; Numbers\n\n9999999999999999999999 ; integers\n#b111                  ; binary => 7\n#o111                  ; octal => 73\n#x111                  ; hexadecimal => 273\n3.14159s0              ; single\n3.14159d0              ; double\n1/2                    ; ratios\n#C(1 2)                ; complex numbers\n\n;;; Function application are written as (f x y z ...) where f is a function and\n;;; x, y, z, ... are the arguments.\n\n(+ 1 2)                ; => 3\n\n;;; If you want to create literal data, use QUOTE to prevent it from being\n;;; evaluated\n\n(quote (+ 1 2))        ; => (+ 1 2)\n(quote a)              ; => A\n\n;;; The shorthand for QUOTE is '\n\n'(+ 1 2)               ; => (+ 1 2)\n'a                     ; => A\n\n;;; Basic arithmetic operations\n\n(+ 1 1)                ; => 2\n(- 8 1)                ; => 7\n(* 10 2)               ; => 20\n(expt 2 3)             ; => 8\n(mod 5 2)              ; => 1\n(/ 35 5)               ; => 7\n(/ 1 3)                ; => 1/3\n(+ #C(1 2) #C(6 -4))   ; => #C(7 -2)\n\n;;; Booleans\n\nt                      ; true; any non-NIL value is true\nnil                    ; false; also, the empty list: ()\n(not nil)              ; => T\n(and 0 t)              ; => T\n(or 0 nil)             ; => 0\n\n;;; Characters\n\n#\\A                    ; => #\\A\n#\\λ                    ; => #\\GREEK_SMALL_LETTER_LAMDA\n#\\u03BB                ; => #\\GREEK_SMALL_LETTER_LAMDA\n\n;;; Strings are fixed-length arrays of characters\n\n\"Hello, world!\"\n\"Benjamin \\\"Bugsy\\\" Siegel\"   ; backslash is an escaping character\n\n;;; Strings can be concatenated\n\n(concatenate 'string \"Hello, \" \"world!\") ; => \"Hello, world!\"\n\n;;; A string can be treated like a sequence of characters\n\n(elt \"Apple\" 0) ; => #\\A\n\n;;; FORMAT is used to create formatted output, which ranges from simple string\n;;; interpolation to loops and conditionals. The first argument to FORMAT\n;;; determines where will the formatted string go. If it is NIL, FORMAT\n;;; simply returns the formatted string as a value; if it is T, FORMAT outputs\n;;; to the standard output, usually the screen, then it returns NIL.\n\n(format nil \"~A, ~A!\" \"Hello\" \"world\")   ; => \"Hello, world!\"\n(format t \"~A, ~A!\" \"Hello\" \"world\")     ; => NIL\n\n\n;;;-----------------------------------------------------------------------------\n;;; 2. Variables\n;;;-----------------------------------------------------------------------------\n\n;;; You can create a global (dynamically scoped) variable using DEFVAR and\n;;; DEFPARAMETER. The variable name can use any character except: ()\",'`;#|\\\n\n;;; The difference between DEFVAR and DEFPARAMETER is that re-evaluating a\n;;; DEFVAR expression doesn't change the value of the variable. DEFPARAMETER,\n;;; on the other hand, does.\n\n;;; By convention, dynamically scoped variables have earmuffs in their name.\n\n(defparameter *some-var* 5)\n*some-var* ; => 5\n\n;;; You can also use unicode characters.\n(defparameter *AΛB* nil)\n\n;;; Accessing a previously unbound variable results in an UNBOUND-VARIABLE\n;;; error, however it is defined behavior. Don't do it.\n\n;;; You can create local bindings with LET. In the following snippet, `me` is\n;;; bound to \"dance with you\" only within the (let ...). LET always returns\n;;; the value of the last `form` in the LET form.\n\n(let ((me \"dance with you\")) me) ; => \"dance with you\"\n\n\n;;;-----------------------------------------------------------------------------;\n;;; 3. Structs and collections\n;;;-----------------------------------------------------------------------------;\n\n\n;;; Structs\n\n(defstruct dog name breed age)\n(defparameter *rover*\n    (make-dog :name \"rover\"\n              :breed \"collie\"\n              :age 5))\n*rover*            ; => #S(DOG :NAME \"rover\" :BREED \"collie\" :AGE 5)\n(dog-p *rover*)    ; => T\n(dog-name *rover*) ; => \"rover\"\n\n;;; DOG-P, MAKE-DOG, and DOG-NAME are all automatically created by DEFSTRUCT\n\n\n;;; Pairs\n\n;;; CONS constructs pairs. CAR and CDR return the head and tail of a CONS-pair.\n\n(cons 'SUBJECT 'VERB)         ; => '(SUBJECT . VERB)\n(car (cons 'SUBJECT 'VERB))   ; => SUBJECT\n(cdr (cons 'SUBJECT 'VERB))   ; => VERB\n\n\n;;; Lists\n\n;;; Lists are linked-list data structures, made of CONS pairs and end with a\n;;; NIL (or '()) to mark the end of the list\n\n(cons 1 (cons 2 (cons 3 nil)))     ; => '(1 2 3)\n\n;;; LIST is a convenience variadic constructor for lists\n\n(list 1 2 3)                       ; => '(1 2 3)\n\n;;; When the first argument to CONS is an atom and the second argument is a\n;;; list, CONS returns a new CONS-pair with the first argument as the first\n;;; item and the second argument as the rest of the CONS-pair\n\n(cons 4 '(1 2 3))                  ; => '(4 1 2 3)\n\n;;; Use APPEND to join lists\n\n(append '(1 2) '(3 4))             ; => '(1 2 3 4)\n\n;;; Or CONCATENATE\n\n(concatenate 'list '(1 2) '(3 4))  ; => '(1 2 3 4)\n\n;;; Lists are a very central type, so there is a wide variety of functionality for\n;;; them, a few examples:\n\n(mapcar #'1+ '(1 2 3))             ; => '(2 3 4)\n(mapcar #'+ '(1 2 3) '(10 20 30))  ; => '(11 22 33)\n(remove-if-not #'evenp '(1 2 3 4)) ; => '(2 4)\n(every #'evenp '(1 2 3 4))         ; => NIL\n(some #'oddp '(1 2 3 4))           ; => T\n(butlast '(subject verb object))   ; => (SUBJECT VERB)\n\n\n;;; Vectors\n\n;;; Vector's literals are fixed-length arrays\n\n#(1 2 3) ; => #(1 2 3)\n\n;;; Use CONCATENATE to add vectors together\n\n(concatenate 'vector #(1 2 3) #(4 5 6)) ; => #(1 2 3 4 5 6)\n\n\n;;; Arrays\n\n;;; Both vectors and strings are special-cases of arrays.\n\n;;; 2D arrays\n\n(make-array (list 2 2))         ; => #2A((0 0) (0 0))\n(make-array '(2 2))             ; => #2A((0 0) (0 0))\n(make-array (list 2 2 2))       ; => #3A(((0 0) (0 0)) ((0 0) (0 0)))\n\n;;; Caution: the default initial values of MAKE-ARRAY are implementation-defined.\n;;; To explicitly specify them:\n\n(make-array '(2) :initial-element 'unset)  ; => #(UNSET UNSET)\n\n;;; To access the element at 1, 1, 1:\n\n(aref (make-array (list 2 2 2)) 1 1 1)     ;  => 0\n;;; This value is implementation-defined:\n;;; NIL on ECL, 0 on SBCL and CCL.\n\n;;; Adjustable vectors\n\n;;; Adjustable vectors have the same printed representation as\n;;; fixed-length vector's literals.\n\n(defparameter *adjvec* (make-array '(3) :initial-contents '(1 2 3)\n                                   :adjustable t :fill-pointer t))\n*adjvec* ; => #(1 2 3)\n\n;;; Adding new elements\n\n(vector-push-extend 4 *adjvec*)   ; => 3\n*adjvec*                          ; => #(1 2 3 4)\n\n\n;;; Sets, naively, are just lists:\n\n(set-difference '(1 2 3 4) '(4 5 6 7))   ; => (3 2 1)\n(intersection '(1 2 3 4) '(4 5 6 7))     ; => 4\n(union '(1 2 3 4) '(4 5 6 7))            ; => (3 2 1 4 5 6 7)\n(adjoin 4 '(1 2 3 4))                    ; => (1 2 3 4)\n\n;;; However, you'll need a better data structure than linked lists when working\n;;; with larger data sets\n\n;;; Dictionaries are implemented as hash tables.\n\n;;; Create a hash table\n\n(defparameter *m* (make-hash-table))\n\n;;; Set value\n\n(setf (gethash 'a *m*) 1)\n\n;;; Retrieve value\n\n(gethash 'a *m*) ; => 1, T\n\n;;; CL expressions have the ability to return multiple values.\n\n(values 1 2) ; => 1, 2\n\n;;; which can be bound with MULTIPLE-VALUE-BIND\n\n(multiple-value-bind (x y)\n    (values 1 2)\n  (list y x))\n\n; => '(2 1)\n\n;;; GETHASH is an example of a function that returns multiple values. The first\n;;; value it return is the value of the key in the hash table; if the key is\n;;; not found it returns NIL.\n\n;;; The second value determines if that key is indeed present in the hash\n;;; table. If a key is not found in the table it returns NIL. This behavior\n;;; allows us to check if the value of a key is actually NIL.\n\n;;; Retrieving a non-present value returns nil\n\n(gethash 'd *m*) ;=> NIL, NIL\n\n;;; You can provide a default value for missing keys\n\n(gethash 'd *m* :not-found) ; => :NOT-FOUND\n\n;;; Let's handle the multiple return values here in code.\n\n(multiple-value-bind (a b)\n    (gethash 'd *m*)\n  (list a b))\n; => (NIL NIL)\n\n(multiple-value-bind (a b)\n    (gethash 'a *m*)\n  (list a b))\n; => (1 T)\n\n\n;;;-----------------------------------------------------------------------------\n;;; 3. Functions\n;;;-----------------------------------------------------------------------------\n\n;;; Use LAMBDA to create anonymous functions. Functions always returns the\n;;; value of the last expression. The exact printable representation of a\n;;; function varies between implementations.\n\n(lambda () \"Hello World\") ; => #<FUNCTION (LAMBDA ()) {1004E7818B}>\n\n;;; Use FUNCALL to call anonymous functions\n\n(funcall (lambda () \"Hello World\"))   ; => \"Hello World\"\n(funcall #'+ 1 2 3)                   ; => 6\n\n;;; A call to FUNCALL is also implied when the lambda expression is the CAR of\n;;; an unquoted list\n\n((lambda () \"Hello World\"))           ; => \"Hello World\"\n((lambda (val) val) \"Hello World\")    ; => \"Hello World\"\n\n;;; FUNCALL is used when the arguments are known beforehand. Otherwise, use APPLY\n\n(apply #'+ '(1 2 3))   ; => 6\n(apply (lambda () \"Hello World\") nil) ; => \"Hello World\"\n\n;;; To name a function, use DEFUN\n\n(defun hello-world () \"Hello World\")\n(hello-world) ; => \"Hello World\"\n\n;;; The () in the definition above is the list of arguments\n\n(defun hello (name) (format nil \"Hello, ~A\" name))\n(hello \"Steve\") ; => \"Hello, Steve\"\n\n;;; Functions can have optional arguments; they default to NIL\n\n(defun hello (name &optional from)\n  (if from\n      (format t \"Hello, ~A, from ~A\" name from)\n      (format t \"Hello, ~A\" name)))\n\n(hello \"Jim\" \"Alpacas\")       ; => Hello, Jim, from Alpacas\n\n;;; The default values can also be specified\n\n(defun hello (name &optional (from \"The world\"))\n   (format nil \"Hello, ~A, from ~A\" name from))\n\n(hello \"Steve\")               ; => Hello, Steve, from The world\n(hello \"Steve\" \"the alpacas\") ; => Hello, Steve, from the alpacas\n\n;;; Functions also have keyword arguments to allow non-positional arguments\n\n(defun generalized-greeter (name &key (from \"the world\") (honorific \"Mx\"))\n  (format t \"Hello, ~A ~A, from ~A\" honorific name from))\n\n(generalized-greeter \"Jim\")\n; => Hello, Mx Jim, from the world\n\n(generalized-greeter \"Jim\" :from \"the alpacas you met last summer\" :honorific \"Mr\")\n; => Hello, Mr Jim, from the alpacas you met last summer\n\n\n;;;-----------------------------------------------------------------------------\n;;; 4. Equality\n;;;-----------------------------------------------------------------------------\n\n;;; CL has a sophisticated equality system. Some are covered here.\n\n;;; For numbers, use `='\n(= 3 3.0)               ; => T\n(= 2 1)                 ; => NIL\n\n;;; For object identity (approximately) use EQL\n(eql 3 3)               ; => T\n(eql 3 3.0)             ; => NIL\n(eql (list 3) (list 3)) ; => NIL\n\n;;; for lists, strings, and bit-vectors use EQUAL\n(equal (list 'a 'b) (list 'a 'b)) ; => T\n(equal (list 'a 'b) (list 'b 'a)) ; => NIL\n\n\n;;;-----------------------------------------------------------------------------\n;;; 5. Control Flow\n;;;-----------------------------------------------------------------------------\n\n;;; Conditionals\n\n(if t                ; test expression\n    \"this is true\"   ; then expression\n    \"this is false\") ; else expression\n; => \"this is true\"\n\n;;; In conditionals, all non-NIL values are treated as true\n\n(member 'Groucho '(Harpo Groucho Zeppo)) ; => '(GROUCHO ZEPPO)\n(if (member 'Groucho '(Harpo Groucho Zeppo))\n    'yep\n    'nope)\n; => 'YEP\n\n;;; COND chains a series of tests to select a result\n(cond ((> 2 2) (error \"wrong!\"))\n      ((< 2 2) (error \"wrong again!\"))\n      (t 'ok)) ; => 'OK\n\n;;; TYPECASE switches on the type of the value\n(typecase 1\n  (string :string)\n  (integer :int))\n; => :int\n\n\n;;; Looping\n\n;;; Recursion\n\n(defun fact (n)\n  (if (< n 2)\n      1\n    (* n (fact(- n 1)))))\n\n(fact 5) ; => 120\n\n;;; Iteration\n\n(defun fact (n)\n  (loop :for result = 1 :then (* result i)\n     :for i :from 2 :to n\n     :finally (return result)))\n\n(fact 5) ; => 120\n\n(loop :for x :across \"abcd\" :collect x)\n; => (#\\a #\\b #\\c #\\d)\n\n(dolist (i '(1 2 3 4))\n  (format t \"~A\" i))\n; => 1234\n\n\n;;;-----------------------------------------------------------------------------\n;;; 6. Mutation\n;;;-----------------------------------------------------------------------------\n\n;;; Use SETF to assign a new value to an existing variable. This was\n;;; demonstrated earlier in the hash table example.\n\n(let ((variable 10))\n    (setf variable 2))\n; => 2\n\n;;; Good Lisp style is to minimize the use of destructive functions and to avoid\n;;; mutation when reasonable.\n\n\n;;;-----------------------------------------------------------------------------\n;;; 7. Classes and objects\n;;;-----------------------------------------------------------------------------\n\n;;; No more animal classes. Let's have Human-Powered Mechanical\n;;; Conveyances.\n\n(defclass human-powered-conveyance ()\n  ((velocity\n    :accessor velocity\n    :initarg :velocity)\n   (average-efficiency\n    :accessor average-efficiency\n   :initarg :average-efficiency))\n  (:documentation \"A human powered conveyance\"))\n\n;;; The arguments to DEFCLASS, in order are:\n;;; 1. class name\n;;; 2. superclass list\n;;; 3. slot list\n;;; 4. optional specifiers\n\n;;; When no superclass list is set, the empty list defaults to the\n;;; standard-object class. This *can* be changed, but not until you\n;;; know what you're doing. Look up the Art of the Metaobject Protocol\n;;; for more information.\n\n(defclass bicycle (human-powered-conveyance)\n  ((wheel-size\n    :accessor wheel-size\n    :initarg :wheel-size\n    :documentation \"Diameter of the wheel.\")\n   (height\n    :accessor height\n    :initarg :height)))\n\n(defclass recumbent (bicycle)\n  ((chain-type\n    :accessor chain-type\n    :initarg :chain-type)))\n\n(defclass unicycle (human-powered-conveyance) nil)\n\n(defclass canoe (human-powered-conveyance)\n  ((number-of-rowers\n    :accessor number-of-rowers\n    :initarg :number-of-rowers)))\n\n;;; Calling DESCRIBE on the HUMAN-POWERED-CONVEYANCE class in the REPL gives:\n\n(describe 'human-powered-conveyance)\n\n; COMMON-LISP-USER::HUMAN-POWERED-CONVEYANCE\n;  [symbol]\n;\n; HUMAN-POWERED-CONVEYANCE names the standard-class #<STANDARD-CLASS\n;                                                    HUMAN-POWERED-CONVEYANCE>:\n;  Documentation:\n;    A human powered conveyance\n;  Direct superclasses: STANDARD-OBJECT\n;  Direct subclasses: UNICYCLE, BICYCLE, CANOE\n;  Not yet finalized.\n;  Direct slots:\n;    VELOCITY\n;      Readers: VELOCITY\n;      Writers: (SETF VELOCITY)\n;    AVERAGE-EFFICIENCY\n;      Readers: AVERAGE-EFFICIENCY\n;      Writers: (SETF AVERAGE-EFFICIENCY)\n\n;;; Note the reflective behavior available. CL was designed to be an\n;;; interactive system\n\n;;; To define a method, let's find out what our circumference of the\n;;; bike wheel turns out to be using the equation: C = d * pi\n\n(defmethod circumference ((object bicycle))\n  (* pi (wheel-size object)))\n\n;;; PI is defined as a built-in in CL\n\n;;; Let's suppose we find out that the efficiency value of the number\n;;; of rowers in a canoe is roughly logarithmic. This should probably be set\n;;; in the constructor/initializer.\n\n;;; To initialize your instance after CL gets done constructing it:\n\n(defmethod initialize-instance :after ((object canoe) &rest args)\n  (setf (average-efficiency object)  (log (1+ (number-of-rowers object)))))\n\n;;; Then to construct an instance and check the average efficiency...\n\n(average-efficiency (make-instance 'canoe :number-of-rowers 15))\n; => 2.7725887\n\n\n;;;-----------------------------------------------------------------------------\n;;; 8. Macros\n;;;-----------------------------------------------------------------------------\n\n;;; Macros let you extend the syntax of the language. CL doesn't come\n;;; with a WHILE loop, however, it's trivial to write one. If we obey our\n;;; assembler instincts, we wind up with:\n\n(defmacro while (condition &body body)\n    \"While `condition` is true, `body` is executed.\n`condition` is tested prior to each execution of `body`\"\n    (let ((block-name (gensym)) (done (gensym)))\n        `(tagbody\n           ,block-name\n           (unless ,condition\n               (go ,done))\n           (progn\n           ,@body)\n           (go ,block-name)\n           ,done)))\n\n;;; Let's look at the high-level version of this:\n\n(defmacro while (condition &body body)\n    \"While `condition` is true, `body` is executed.\n`condition` is tested prior to each execution of `body`\"\n  `(loop while ,condition\n         do\n         (progn\n            ,@body)))\n\n;;; However, with a modern compiler, this is not required; the LOOP form\n;;; compiles equally well and is easier to read.\n\n;;; Note that ``` is used, as well as `,` and `@`. ``` is a quote-type operator\n;;; known as quasiquote; it allows the use of `,` . `,` allows \"unquoting\"\n;;; variables. @ interpolates lists.\n\n;;; GENSYM creates a unique symbol guaranteed to not exist elsewhere in\n;;; the system. This is because macros are expanded at compile time and\n;;; variables declared in the macro can collide with variables used in\n;;; regular code.\n\n;;; See Practical Common Lisp and On Lisp for more information on macros.\n```\n\n\n## Further reading\n\n- [Practical Common Lisp](http://www.gigamonkeys.com/book/)\n- [Common Lisp: A Gentle Introduction to Symbolic Computation](https://www.cs.cmu.edu/~dst/LispBook/book.pdf)\n\n\n## Extra information\n\n- [CLiki](http://www.cliki.net/)\n- [common-lisp.net](https://common-lisp.net/)\n- [Awesome Common Lisp](https://github.com/CodyReichert/awesome-cl)\n- [Lisp Lang](http://lisp-lang.org/)\n\n\n## Credits\n\nLots of thanks to the Scheme people for rolling up a great starting\npoint which could be easily moved to Common Lisp.\n\n- [Paul Khuong](https://github.com/pkhuong) for some great reviewing."
