
package pages

const Reason = "Reason is a syntax over OCaml that is easier to get started for programmers who are familiar with C-style syntax like JavaScript. BuckleScript is part of the toolchain which compiles Reason to JavaScript so you can write statically typed code for anywhere that JavaScript runs.\n\n```javascript\n/* Comments start with slash-star, and end with star-slash */\n\n/*----------------------------------------------\n * Variable and function declaration\n *----------------------------------------------\n * Variables and functions use the let keyword and end with a semi-colon\n * `let` bindings are immutable\n */\n\nlet x = 5;\n/* - Notice we didn't add a type, Reason will infer x is an int */\n\n/* A function like this, take two arguments and add them together */\nlet add = (a, b) => a + b;\n/* - This doesn't need a type annotation either! */\n\n/*----------------------------------------------\n * Type annotation\n *----------------------------------------------\n * Types don't need to be explicitly annotated in most cases but when you need\n * to, you can add the type after the name\n */\n\n/* A type can be explicitly written like so */\nlet x: int = 5;\n\n/* The add function from before could be explicitly annotated too */\nlet add2 = (a: int, b: int): int => a + b;\n\n/* A type can be aliased using the type keyword */\ntype companyId = int;\nlet myId: companyId = 101;\n\n/* Mutation is not encouraged in Reason but it's there if you need it\n   If you need to mutate a let binding, the value must be wrapped in a `ref()`*/\nlet myMutableNumber = ref(120);\n\n/* To access the value (and not the ref container), use `^` */\nlet copyOfMyMutableNumber = myMutableNumber^;\n\n/* To assign a new value, use the `:=` operator */\nmyMutableNumber := 240;\n\n/*----------------------------------------------\n * Basic types and operators\n *----------------------------------------------\n */\n\n/* > String */\n\n/* Use double quotes for strings */\nlet greeting = \"Hello world!\";\n\n/* A string can span multiple lines */\nlet aLongerGreeting = \"Look at me,\nI'm a multi-line string\n\";\n\n/* A quoted string can be used for string interpolation and special chars\n   Use the `js` annotation for unicode */\nlet world = {js|ðŸŒ|js};\n\n/* The `j` annotation is used for string interpolation */\nlet helloWorld = {j|hello, $world|j};\n\n/* Concatenate strings with ++ */\nlet name = \"John \" ++ \"Wayne\";\nlet emailSubject = \"Hi \" ++ name ++ \", you're a valued customer\";\n\n/* > Char */\n\n/* Use a single character for the char type */\nlet lastLetter = 'z';\n/* - Char doesn't support Unicode or UTF-8 */\n\n/* > Boolean */\n\n/* A boolean can be either true or false */\nlet isLearning = true;\n\ntrue && false;  /* - : bool = false;  Logical and */\ntrue || true;   /* - : bool = true;   Logical or  */\n!true;          /* - : bool = false;  Logical not */\n\n/* Greater than `>`, or greater than or equal to `>=` */\n'a' > 'b'; /* - bool : false */\n\n/* Less than `<`, or less than or equal to `<=` */\n1 < 5; /* - : bool = true */\n\n/* Structural equal */\n\"hello\" == \"hello\"; /* - : bool = true */\n\n/* Referential equal */\n\"hello\" === \"hello\"; /* - : bool = false */\n/* - This is false because they are two different \"hello\" string literals */\n\n/* Structural unequal */\nlastLetter != 'a'; /* -: bool = true */\n\n/* Referential unequal */\nlastLetter !== lastLetter; /* - : bool = false */\n\n/* > Integer */\n/* Perform math operations on integers */\n\n1 + 1;          /* - : int = 2  */\n25 - 11;        /* - : int = 11 */\n5 * 2 * 3;      /* - : int = 30 */\n8 / 2;          /* - : int = 4  */\n\n/* > Float */\n/* Operators on floats have a dot after them */\n\n1.1 +. 1.5;     /* - : float = 2.6  */\n18.0 -. 24.5;   /* - : float = -6.5 */\n2.5 *. 2.0;     /* - : float = 5.   */\n16.0 /. 4.0;    /* - : float = 4.   */\n\n/* > Tuple\n * Tuples have the following attributes\n  - immutable\n  - ordered\n  - fix-sized at creation time\n  - heterogeneous (can contain different types of values)\n A tuple is 2 or more values */\n\nlet teamMember = (\"John\", 25);\n\n/* Type annotation matches the values */\nlet position2d: (float, float) = (9.0, 12.0);\n\n/* Pattern matching is a great tool to retrieve just the values you care about\n   If we only want the y value, let's use `_` to ignore the value */\nlet (_, y) = position2d;\ny +. 1.0; /* - : float = 13. */\n\n/* > Record */\n\n/* A record has to have an explicit type */\ntype trainJourney = {\n  destination: string,\n  capacity: int,\n  averageSpeed: float,\n};\n\n/* Once the type is declared, Reason can infer it whenever it comes up */\nlet firstTrip = {destination: \"London\", capacity: 45, averageSpeed: 120.0};\n\n/* Access a property using dot notation */\nlet maxPassengers = firstTrip.capacity;\n\n/* If you define the record type in a different file, you have to reference the\n   filename, if trainJourney was in a file called Trips.re */\nlet secondTrip: Trips.trainJourney = {\n  destination: \"Paris\",\n  capacity: 50,\n  averageSpeed: 150.0,\n};\n\n/* Records are immutable by default */\n/* But the contents of a record can be copied using the spread operator */\nlet newTrip = {...secondTrip, averageSpeed: 120.0};\n\n/* A record property can be mutated explicitly with the `mutable` keyword */\ntype breakfastCereal = {\n  name: string,\n  mutable amount: int,\n};\n\nlet tastyMuesli = {name: \"Tasty Muesli TM\", amount: 500};\n\ntastyMuesli.amount = 200;\n/* - tastyMuesli now has an amount of 200 */\n\n/* Punning is used to avoid redundant typing */\nlet name = \"Just As Good Muesli\";\nlet justAsGoodMuesli = {name, amount: 500};\n/* - justAsGoodMuesli.name is now \"Just As Good Muesli\", it's equivalent\n   to { name: name, amount: 500 } */\n\n/* > Variant\n   Mutually exclusive states can be expressed with variants */\n\ntype authType =\n  | GitHub\n  | Facebook\n  | Google\n  | Password;\n/* - The constructors must be capitalized like so */\n/* - Like records, variants should be named if declared in a different file */\n\nlet userPreferredAuth = GitHub;\n\n/* Variants work great with a switch statement */\nlet loginMessage =\n  switch (userPreferredAuth) {\n  | GitHub => \"Login with GitHub credentials.\"\n  | Facebook => \"Login with your Facebook account.\"\n  | Google => \"Login with your Google account\"\n  | Password => \"Login with email and password.\"\n  };\n\n/* > Option\n   An option can be None or Some('a) where 'a is the type */\n\nlet userId = Some(23);\n\n/* A switch handles the two cases */\nlet alertMessage =\n  switch (userId) {\n  | Some(id) => \"Welcome, your ID is\" ++ string_of_int(id)\n  | None => \"You don't have an account!\"\n  };\n/* - Missing a case, `None` or `Some`, would cause an error */\n\n/* > List\n  * Lists have the following attributes\n   - immutable\n   - ordered\n   - fast at prepending items\n   - fast at splitting\n\n  * Lists in Reason are linked lists\n */\n\n/* A list is declared with square brackets */\nlet userIds = [1, 4, 8];\n\n/* The type can be explicitly set with list('a) where 'a is the type */\ntype idList = list(int);\ntype attendanceList = list(string);\n\n/* Lists are immutable */\n/* But the contents of a list can be copied using the spread operator */\nlet newUserIds = [101, 102, ...userIds];\n\n/* > Array\n * Arrays have the following attributes\n  - mutable\n  - fast at random access & updates */\n\n/* An array is declared with `[|` and ends with `|]` */\nlet languages = [|\"Reason\", \"JavaScript\", \"OCaml\"|];\n\n/*----------------------------------------------\n * Function\n *----------------------------------------------\n */\n\n/* Reason functions use the arrow syntax, the expression is returned */\nlet signUpToNewsletter = email => \"Thanks for signing up \" ++ email;\n\n/* Call a function like this */\nsignUpToNewsletter(\"hello@reason.org\");\n\n/* For longer functions, use a block */\nlet getEmailPrefs = email => {\n  let message = \"Update settings for \" ++ email;\n  let prefs = [\"Weekly News\", \"Daily Notifications\"];\n\n  (message, prefs);\n};\n/* - the final tuple is implicitly returned */\n\n/* > Labeled Arguments */\n\n/* Arguments can be labeled with the ~ symbol */\nlet moveTo = (~x, ~y) => {/* Move to x,y */};\n\nmoveTo(~x=7.0, ~y=3.5);\n\n/* Labeled arguments can also have a name used within the function */\nlet getMessage = (~message as msg) => \"==\" ++ msg ++ \"==\";\n\ngetMessage(~message=\"You have a message!\");\n/* - The caller specifies ~message but internally the function can make use */\n\n/* The following function also has explicit types declared */\nlet showDialog = (~message: string): unit => {\n  () /* Show the dialog */;\n};\n/* - The return type is `unit`, this is a special type that is equivalent to\n   specifying that this function doesn't return a value\n   the `unit` type can also be represented as `()` */\n\n/* > Currying\n   Functions can be curried and are partially called, allowing for easy reuse */\n\nlet div = (denom, numr) => numr / denom;\nlet divBySix = div(6);\nlet divByTwo = div(2);\n\ndiv(3, 24);     /* - : int = 8  */\ndivBySix(128);  /* - : int = 21 */\ndivByTwo(10);   /* - : int = 5  */\n\n/* > Optional Labeled Arguments */\n\n/* Use `=?` syntax for optional labeled arguments */\nlet greetPerson = (~name, ~greeting=?, ()) => {\n  switch (greeting) {\n  | Some(greet) => greet ++ \" \" ++ name\n  | None => \"Hi \" ++ name\n  };\n};\n/* - The third argument, `unit` or `()` is required because if we omitted it,\n   the function would be curried so greetPerson(~name=\"Kate\") would create\n   a partial function, to fix this we add `unit` when we declare and call it */\n\n/* Call greetPerson without the optional labeled argument */\ngreetPerson(~name=\"Kate\", ());\n\n/* Call greetPerson with all arguments */\ngreetPerson(~name=\"Marco\", ~greeting=\"How are you today,\");\n\n/* > Pipe */\n/* Functions can be called with the pipeline operator */\n\n/* Use `->` to pass in the first argument (pipe-first) */\n3->div(24);     /* - : int = 8 */\n/* - This is equivalent to div(3, 24); */\n\n36->divBySix;   /* - : int = 6 */\n/* - This is equivalent to divBySix(36); */\n\n/* Use `|>` to pass in the last argument (pipe-last) */\n24 |> div(3);   /* - : int = 8 */\n/* - This is equivalent to div(3, 24); */\n\n36 |> divBySix; /* - : int = 6 */\n/* - This is equivalent to divBySix(36); */\n\n/* Pipes make it easier to chain code together */\nlet addOne = a => a + 1;\nlet divByTwo = a => a / 2;\nlet multByThree = a => a * 3;\n\nlet pipedValue = 3->addOne->divByTwo->multByThree; /* - : int = 6 */\n\n/*----------------------------------------------\n * Control Flow & Pattern Matching\n *----------------------------------------------\n */\n\n/* > If-else */\n/* In Reason, `If` is an expression when evaluate will return the result */\n\n/* greeting will be \"Good morning!\" */\nlet greeting = if (true) {\"Good morning!\"} else {\"Hello!\"};\n\n/* Without an else branch the expression will return `unit` or `()` */\nif (false) {\n  showDialog(~message=\"Are you sure you want to leave?\");\n};\n/* - Because the result will be of type `unit`, both return types should be of\n   the same type if you want to assign the result. */\n\n/* > Destructuring */\n/* Extract properties from data structures easily */\n\nlet aTuple = (\"Teacher\", 101);\n\n/* We can extract the values of a tuple */\nlet (name, classNum) = aTuple;\n\n/* The properties of a record can be extracted too */\ntype person = {\n  firstName: string,\n  age: int,\n};\nlet bjorn = {firstName: \"Bjorn\", age: 28};\n\n/* The variable names have to match with the record property names */\nlet {firstName, age} = bjorn;\n\n/* But we can rename them like so */\nlet {firstName: bName, age: bAge} = bjorn;\n\nlet {firstName: cName, age: _} = bjorn;\n\n/* > Switch\n   Pattern matching with switches is an important tool in Reason\n   It can be used in combination with destructuring for an expressive and\n   concise tool */\n\n/* Lets take a simple list */\nlet firstNames = [\"James\", \"Jean\", \"Geoff\"];\n\n/* We can pattern match on the names for each case we want to handle */\nswitch (firstNames) {\n| [] => \"No names\"\n| [first] => \"Only \" ++ first\n| [first, second] => \"A couple of names \" ++ first ++ \",\" ++ second\n| [first, second, third] =>\n  \"Three names, \" ++ first ++ \", \" ++ second ++ \", \" ++ third\n| _ => \"Lots of names\"\n};\n/* - The `_` is a catch all at the end, it signifies that we don't care what\n   the value is so it will match every other case */\n\n/* > When clause */\n\nlet isJohn = a => a == \"John\";\nlet maybeName = Some(\"John\");\n\n/* When can add more complex logic to a simple switch */\nlet aGreeting =\n  switch (maybeName) {\n  | Some(name) when isJohn(name) => \"Hi John! How's it going?\"\n  | Some(name) => \"Hi \" ++ name ++ \", welcome.\"\n  | None => \"No one to greet.\"\n  };\n\n/* > Exception */\n\n/* Define a custom exception */\nexception Under_Age;\n\n/* Raise an exception within a function */\nlet driveToTown = (driver: person) =>\n  if (driver.age >= 15) {\n    \"We're in town\";\n  } else {\n    raise(Under_Age);\n  };\n\nlet evan = {firstName: \"Evan\", age: 14};\n\n/* Pattern match on the exception Under_Age */\nswitch (driveToTown(evan)) {\n| status => print_endline(status)\n| exception Under_Age =>\n  print_endline(evan.firstName ++ \" is too young to drive!\")\n};\n\n/* Alternatively, a try block can be used */\n/* - With Reason exceptions can be avoided with optionals and are seldom used */\nlet messageToEvan =\n  try (driveToTown(evan)) {\n  | Under_Age => evan.firstName ++ \" is too young to drive!\"\n  };\n\n/*----------------------------------------------\n * Object\n *----------------------------------------------\n * Objects are similar to Record types but aren't as rigid\n * An object resembles a class\n */\n\n/* An object may be typed like a record but contains a dot */\ntype surfaceComputer = {\n  .\n  color: string,\n  capacity: int,\n};\n/* - A single dot signifies a closed object, an object that uses this type\n   must have the exact shape */\n\nlet surfaceBook: surfaceComputer = {pub color = \"blue\"; pub capacity = 512};\n\n/* But an object doesn't require a type */\nlet house = {\n  /* A private property */\n  val temp = ref(18.0);\n  /* Public properties */\n  pub temperature = temp;\n  /* A private method only accessible from within house */\n  pri setThermostat = v => temp := v;\n  /* A public method that calls the private setThermostat method */\n  pub arriveHome = () => this#setThermostat(22.0)\n};\n\nhouse#temperature; /* - : float = 18. */\nhouse#arriveHome();\nhouse#temperature; /* - : float = 22. */\n\n/*----------------------------------------------\n * Module\n *----------------------------------------------\n * Modules are used to organize your code and provide namespacing.\n * Each file is a module by default\n */\n\n/* Create a module */\nmodule Staff = {\n  type role =\n    | Delivery\n    | Sales\n    | Other;\n  type member = {\n    name: string,\n    role,\n  };\n\n  let getRoleDirectionMessage = staff =>\n    switch (staff.role) {\n    | Delivery => \"Deliver it like you mean it!\"\n    | Sales => \"Sell it like only you can!\"\n    | Other => \"You're an important part of the team!\"\n    };\n};\n\n/* A module can be accessed with dot notation */\nlet newEmployee: Staff.member = {name: \"Laura\", role: Staff.Delivery};\n\n/* Using the module name can be tiresome so the module's contents can be opened\n   into the current scope with `open` */\nopen Staff;\n\nlet otherNewEmployee: member = {name: \"Fred\", role: Other};\n\n/* A module can be extended using the `include` keyword, include copies\n   the contents of the module into the scope of the new module */\nmodule SpecializedStaff = {\n  include Staff;\n\n  /* `member` is included so there's no need to reference it explicitly */\n  let ceo: member = {name: \"Reggie\", role: Other};\n\n  let getMeetingTime = staff =>\n    switch (staff) {\n    | Other => 11_15 /* - : int = 1115; Underscores are for formatting only  */\n    | _ => 9_30\n    };\n};\n```\n\n## Further Reading\n\n- [Official Reason Docs](https://reasonml.github.io/docs/en/what-and-why)\n- [Official BuckleScript Docs](https://bucklescript.github.io/docs/en/what-why)\n- [Try Reason](https://reasonml.github.io/en/try)\n- [Get Started with Reason by Nik Graf](https://egghead.io/courses/get-started-with-reason)"
