
package pages

const Clojure = "Clojure is a Lisp family language developed for the Java Virtual Machine. It has\na much stronger emphasis on pure [functional programming](https://en.wikipedia.org/wiki/Functional_programming) than\nCommon Lisp, but includes several [STM](https://en.wikipedia.org/wiki/Software_transactional_memory) utilities to handle\nstate as it comes up.\n\nThis combination allows it to handle concurrent processing very simply,\nand often automatically.\n\n(You need a version of Clojure 1.2 or newer)\n\n\n```clojure\n; Comments start with semicolons.\n\n; Clojure is written in \"forms\", which are just\n; lists of things inside parentheses, separated by whitespace.\n;\n; The clojure reader assumes that the first thing is a\n; function or macro to call, and the rest are arguments.\n\n; The first call in a file should be ns, to set the namespace\n(ns learnclojure)\n\n; More basic examples:\n\n; str will create a string out of all its arguments\n(str \"Hello\" \" \" \"World\") ; => \"Hello World\"\n\n; Math is straightforward\n(+ 1 1) ; => 2\n(- 2 1) ; => 1\n(* 1 2) ; => 2\n(/ 2 1) ; => 2\n\n; Equality is =\n(= 1 1) ; => true\n(= 2 1) ; => false\n\n; You need not for logic, too\n(not true) ; => false\n\n; Nesting forms works as you expect\n(+ 1 (- 3 2)) ; = 1 + (3 - 2) => 2\n\n; Types\n;;;;;;;;;;;;;\n\n; Clojure uses Java's object types for booleans, strings and numbers.\n; Use `class` to inspect them.\n(class 1) ; Integer literals are java.lang.Long by default\n(class 1.); Float literals are java.lang.Double\n(class \"\"); Strings always double-quoted, and are java.lang.String\n(class false) ; Booleans are java.lang.Boolean\n(class nil); The \"null\" value is called nil\n\n; If you want to create a literal list of data, use ' to stop it from\n; being evaluated\n'(+ 1 2) ; => (+ 1 2)\n; (shorthand for (quote (+ 1 2)))\n\n; You can eval a quoted list\n(eval '(+ 1 2)) ; => 3\n\n; Collections & Sequences\n;;;;;;;;;;;;;;;;;;;\n\n; Lists are linked-list data structures, while Vectors are array-backed.\n; Vectors and Lists are java classes too!\n(class [1 2 3]); => clojure.lang.PersistentVector\n(class '(1 2 3)); => clojure.lang.PersistentList\n\n; A list would be written as just (1 2 3), but we have to quote\n; it to stop the reader thinking it's a function.\n; Also, (list 1 2 3) is the same as '(1 2 3)\n\n; \"Collections\" are just groups of data\n; Both lists and vectors are collections:\n(coll? '(1 2 3)) ; => true\n(coll? [1 2 3]) ; => true\n\n; \"Sequences\" (seqs) are abstract descriptions of lists of data.\n; Only lists are seqs.\n(seq? '(1 2 3)) ; => true\n(seq? [1 2 3]) ; => false\n\n; A seq need only provide an entry when it is accessed.\n; So, seqs which can be lazy -- they can define infinite series:\n(range 4) ; => (0 1 2 3)\n(range) ; => (0 1 2 3 4 ...) (an infinite series)\n(take 4 (range)) ;  (0 1 2 3)\n\n; Use cons to add an item to the beginning of a list or vector\n(cons 4 [1 2 3]) ; => (4 1 2 3)\n(cons 4 '(1 2 3)) ; => (4 1 2 3)\n\n; Conj will add an item to a collection in the most efficient way.\n; For lists, they insert at the beginning. For vectors, they insert at the end.\n(conj [1 2 3] 4) ; => [1 2 3 4]\n(conj '(1 2 3) 4) ; => (4 1 2 3)\n\n; Use concat to add lists or vectors together\n(concat [1 2] '(3 4)) ; => (1 2 3 4)\n\n; Use filter, map to interact with collections\n(map inc [1 2 3]) ; => (2 3 4)\n(filter even? [1 2 3]) ; => (2)\n\n; Use reduce to reduce them\n(reduce + [1 2 3 4])\n; = (+ (+ (+ 1 2) 3) 4)\n; => 10\n\n; Reduce can take an initial-value argument too\n(reduce conj [] '(3 2 1))\n; = (conj (conj (conj [] 3) 2) 1)\n; => [3 2 1]\n\n; Functions\n;;;;;;;;;;;;;;;;;;;;;\n\n; Use fn to create new functions. A function always returns\n; its last statement.\n(fn [] \"Hello World\") ; => fn\n\n; (You need extra parens to call it)\n((fn [] \"Hello World\")) ; => \"Hello World\"\n\n; You can create a var using def\n(def x 1)\nx ; => 1\n\n; Assign a function to a var\n(def hello-world (fn [] \"Hello World\"))\n(hello-world) ; => \"Hello World\"\n\n; You can shorten this process by using defn\n(defn hello-world [] \"Hello World\")\n\n; The [] is the list of arguments for the function.\n(defn hello [name]\n  (str \"Hello \" name))\n(hello \"Steve\") ; => \"Hello Steve\"\n\n; You can also use this shorthand to create functions:\n(def hello2 #(str \"Hello \" %1))\n(hello2 \"Julie\") ; => \"Hello Julie\"\n\n; You can have multi-variadic functions, too\n(defn hello3\n  ([] \"Hello World\")\n  ([name] (str \"Hello \" name)))\n(hello3 \"Jake\") ; => \"Hello Jake\"\n(hello3) ; => \"Hello World\"\n\n; Functions can pack extra arguments up in a seq for you\n(defn count-args [& args]\n  (str \"You passed \" (count args) \" args: \" args))\n(count-args 1 2 3) ; => \"You passed 3 args: (1 2 3)\"\n\n; You can mix regular and packed arguments\n(defn hello-count [name & args]\n  (str \"Hello \" name \", you passed \" (count args) \" extra args\"))\n(hello-count \"Finn\" 1 2 3)\n; => \"Hello Finn, you passed 3 extra args\"\n\n\n; Maps\n;;;;;;;;;;\n\n; Hash maps and array maps share an interface. Hash maps have faster lookups\n; but don't retain key order.\n(class {:a 1 :b 2 :c 3}) ; => clojure.lang.PersistentArrayMap\n(class (hash-map :a 1 :b 2 :c 3)) ; => clojure.lang.PersistentHashMap\n\n; Arraymaps will automatically become hashmaps through most operations\n; if they get big enough, so you don't need to worry.\n\n; Maps can use any hashable type as a key, but usually keywords are best\n; Keywords are like strings with some efficiency bonuses\n(class :a) ; => clojure.lang.Keyword\n\n(def stringmap {\"a\" 1, \"b\" 2, \"c\" 3})\nstringmap  ; => {\"a\" 1, \"b\" 2, \"c\" 3}\n\n(def keymap {:a 1, :b 2, :c 3})\nkeymap ; => {:a 1, :c 3, :b 2}\n\n; By the way, commas are always treated as whitespace and do nothing.\n\n; Retrieve a value from a map by calling it as a function\n(stringmap \"a\") ; => 1\n(keymap :a) ; => 1\n\n; Keywords can be used to retrieve their value from a map, too!\n(:b keymap) ; => 2\n\n; Don't try this with strings.\n;(\"a\" stringmap)\n; => Exception: java.lang.String cannot be cast to clojure.lang.IFn\n\n; Retrieving a non-present key returns nil\n(stringmap \"d\") ; => nil\n\n; Use assoc to add new keys to hash-maps\n(def newkeymap (assoc keymap :d 4))\nnewkeymap ; => {:a 1, :b 2, :c 3, :d 4}\n\n; But remember, clojure types are immutable!\nkeymap ; => {:a 1, :b 2, :c 3}\n\n; Use dissoc to remove keys\n(dissoc keymap :a :b) ; => {:c 3}\n\n; Sets\n;;;;;;\n\n(class #{1 2 3}) ; => clojure.lang.PersistentHashSet\n(set [1 2 3 1 2 3 3 2 1 3 2 1]) ; => #{1 2 3}\n\n; Add a member with conj\n(conj #{1 2 3} 4) ; => #{1 2 3 4}\n\n; Remove one with disj\n(disj #{1 2 3} 1) ; => #{2 3}\n\n; Test for existence by using the set as a function:\n(#{1 2 3} 1) ; => 1\n(#{1 2 3} 4) ; => nil\n\n; There are more functions in the clojure.sets namespace.\n\n; Useful forms\n;;;;;;;;;;;;;;;;;\n\n; Logic constructs in clojure are just macros, and look like\n; everything else\n(if false \"a\" \"b\") ; => \"b\"\n(if false \"a\") ; => nil\n\n; Use let to create temporary bindings\n(let [a 1 b 2]\n  (> a b)) ; => false\n\n; Group statements together with do\n(do\n  (print \"Hello\")\n  \"World\") ; => \"World\" (prints \"Hello\")\n\n; Functions have an implicit do\n(defn print-and-say-hello [name]\n  (print \"Saying hello to \" name)\n  (str \"Hello \" name))\n(print-and-say-hello \"Jeff\") ;=> \"Hello Jeff\" (prints \"Saying hello to Jeff\")\n\n; So does let\n(let [name \"Urkel\"]\n  (print \"Saying hello to \" name)\n  (str \"Hello \" name)) ; => \"Hello Urkel\" (prints \"Saying hello to Urkel\")\n\n\n; Use the threading macros (-> and ->>) to express transformations of\n; data more clearly.\n\n; The \"Thread-first\" macro (->) inserts into each form the result of\n; the previous, as the first argument (second item)\n(->  \n   {:a 1 :b 2} \n   (assoc :c 3) ;=> (assoc {:a 1 :b 2} :c 3)\n   (dissoc :b)) ;=> (dissoc (assoc {:a 1 :b 2} :c 3) :b)\n\n; This expression could be written as:\n; (dissoc (assoc {:a 1 :b 2} :c 3) :b)\n; and evaluates to {:a 1 :c 3}\n\n; The double arrow does the same thing, but inserts the result of\n; each line at the *end* of the form. This is useful for collection\n; operations in particular:\n(->>\n   (range 10)\n   (map inc)     ;=> (map inc (range 10)\n   (filter odd?) ;=> (filter odd? (map inc (range 10))\n   (into []))    ;=> (into [] (filter odd? (map inc (range 10)))\n                 ; Result: [1 3 5 7 9]\n\n; When you are in a situation where you want more freedom as where to\n; put the result of previous data transformations in an \n; expression, you can use the as-> macro. With it, you can assign a\n; specific name to transformations' output and use it as a\n; placeholder in your chained expressions:\n\n(as-> [1 2 3] input\n  (map inc input);=> You can use last transform's output at the last position\n  (nth input 2) ;=>  and at the second position, in the same expression\n  (conj [4 5 6] input 8 9 10)) ;=> or in the middle !\n                               ; Result: [4 5 6 4 8 9 10]\n\n\n; Modules\n;;;;;;;;;;;;;;;\n\n; Use \"use\" to get all functions from the module\n(use 'clojure.set)\n\n; Now we can use set operations\n(intersection #{1 2 3} #{2 3 4}) ; => #{2 3}\n(difference #{1 2 3} #{2 3 4}) ; => #{1}\n\n; You can choose a subset of functions to import, too\n(use '[clojure.set :only [intersection]])\n\n; Use require to import a module\n(require 'clojure.string)\n\n; Use / to call functions from a module\n; Here, the module is clojure.string and the function is blank?\n(clojure.string/blank? \"\") ; => true\n\n; You can give a module a shorter name on import\n(require '[clojure.string :as str])\n(str/replace \"This is a test.\" #\"[a-o]\" str/upper-case) ; => \"THIs Is A tEst.\"\n; (#\"\" denotes a regular expression literal)\n\n; You can use require (and use, but don't) from a namespace using :require.\n; You don't need to quote your modules if you do it this way.\n(ns test\n  (:require\n    [clojure.string :as str]\n    [clojure.set :as set]))\n\n; Java\n;;;;;;;;;;;;;;;;;\n\n; Java has a huge and useful standard library, so\n; you'll want to learn how to get at it.\n\n; Use import to load a java module\n(import java.util.Date)\n\n; You can import from an ns too.\n(ns test\n  (:import java.util.Date\n           java.util.Calendar))\n\n; Use the class name with a \".\" at the end to make a new instance\n(Date.) ; <a date object>\n\n; Use . to call methods. Or, use the \".method\" shortcut\n(. (Date.) getTime) ; <a timestamp>\n(.getTime (Date.)) ; exactly the same thing.\n\n; Use / to call static methods\n(System/currentTimeMillis) ; <a timestamp> (system is always present)\n\n; Use doto to make dealing with (mutable) classes more tolerable\n(import java.util.Calendar)\n(doto (Calendar/getInstance)\n  (.set 2000 1 1 0 0 0)\n  .getTime) ; => A Date. set to 2000-01-01 00:00:00\n\n; STM\n;;;;;;;;;;;;;;;;;\n\n; Software Transactional Memory is the mechanism clojure uses to handle\n; persistent state. There are a few constructs in clojure that use this.\n\n; An atom is the simplest. Pass it an initial value\n(def my-atom (atom {}))\n\n; Update an atom with swap!.\n; swap! takes a function and calls it with the current value of the atom\n; as the first argument, and any trailing arguments as the second\n(swap! my-atom assoc :a 1) ; Sets my-atom to the result of (assoc {} :a 1)\n(swap! my-atom assoc :b 2) ; Sets my-atom to the result of (assoc {:a 1} :b 2)\n\n; Use '@' to dereference the atom and get the value\nmy-atom  ;=> Atom<#...> (Returns the Atom object)\n@my-atom ; => {:a 1 :b 2}\n\n; Here's a simple counter using an atom\n(def counter (atom 0))\n(defn inc-counter []\n  (swap! counter inc))\n\n(inc-counter)\n(inc-counter)\n(inc-counter)\n(inc-counter)\n(inc-counter)\n\n@counter ; => 5\n\n; Other STM constructs are refs and agents.\n; Refs: http://clojure.org/refs\n; Agents: http://clojure.org/agents\n```\n\n### Further Reading\n\nThis is far from exhaustive, but hopefully it's enough to get you on your feet.\n\nClojure.org has lots of articles:\n[http://clojure.org/](http://clojure.org/)\n\nClojuredocs.org has documentation with examples for most core functions:\n[http://clojuredocs.org/quickref/Clojure%20Core](http://clojuredocs.org/quickref/Clojure%20Core)\n\n4Clojure is a great way to build your clojure/FP skills:\n[http://www.4clojure.com/](http://www.4clojure.com/)\n\nClojure-doc.org (yes, really) has a number of getting started articles:\n[http://clojure-doc.org/](http://clojure-doc.org/)\n\nClojure for the Brave and True has a great introduction to Clojure and a free online version:\n[https://www.braveclojure.com/clojure-for-the-brave-and-true/](https://www.braveclojure.com/clojure-for-the-brave-and-true/)"
