
package pages

const Lbstanza = "LB Stanza (or Stanza for short) is a new optionally-typed general purpose programming language from the University of California, Berkeley. Stanza was designed to help programmers tackle the complexity of architecting large programs and significantly increase the productivity of application programmers across the entire software development life cycle.\n\n\n```stanza\n; this is a comment \n;<A>\nThis is a block comment \n    ;<B> \n        block comments can be nested with optional tags. \n    ;<B>\n;<A>\ndefpackage learn-stanza-in-y: \n  import core \n  import collections \n\n;==============================================================================\n; The basics, things you'd find in most programming languages\n;==============================================================================\n\n\n; Variables can be mutable (var) or immutable (val)\nval immutable = \"this string can't be changed\"\nvar mutable = \"this one can be\" \nmutable = \"like this\"\n\n; The basic data types (annotations are optional) \nval an-int: Int = 12345\nval a-long: Long = 12345L\nval a-float: Float = 1.2345f\nval a-double: Double = 3.14159\nval a-string: String = \"this is a string\"\nval a-multiline-string = \\<tag>\n    this is a \"raw\" string literal \n\\<tag>\n\n; Print a formatted string with println and \"...\" % [...]\nprintln(\"this is a formatted string %_ %_\" % [mutable, immutable])\n\n; Stanza is optionally typed, and has a ? (any) type. \nvar anything:? = 0\nanything = 3.14159\nanything = \"a string\"\n\n; Stanza has basic collections like Tuples, Arrays, Vectors and HashTables\nval tuple: Tuple<?> = [mutable, immutable]\n\nval array = Array<?>(3)\narray[0] = \"string\"\narray[1] = 1\narray[2] = 1.23455\n; array[3] = \"out-of-bounds\" ; arrays are bounds-checked \n\nval vector = Vector<?>()\nvector[0] = \"string\"\nvector[1] = 1\nvector[2] = 3.14159\n\nval hash-table = HashTable<String, ?>()\nhash-table[\"0\"] = 0\nhash-table[\"1\"] = 1 \nhash-table[\"2\"] = 1 \n\n\n;==============================================================================\n; Functions\n;==============================================================================\n; Functions are declared with the `defn` keyword \ndefn my-function (arg:?) : ; note the space between identifier and arg list\n  println(\"called my-function with %_\" % [arg])\n\nmy-function(\"arg\")  ; note the lack of a space to call the function\n\n; Functions can be declared inside another function and capture variables from\n; the surrounding environment.\ndefn outer (arg): \n  defn inner (): \n    println(\"outer had arg: %_\" % [arg])\n  inner()\n\nouter(\"something\")\n\n; functions are \"first-class\" in stanza, meaning you can assign variables \n; to functions and pass functions as arguments to other functions. \nval a-function = outer \ndefn do-n-times (arg, func, n:Int): \n  for i in 0 to n do : \n    func(arg)\ndo-n-times(\"argument\", a-function, 3)\n\n; sometimes you want to define a function inline, or use an anonymous function.\n; for this you can use the syntax: \n;   fn (args): \n;       ... \ndo-n-times(\"hello\", fn (arg): println(arg), 2)\n\n; there is a shorthand for writing anonymous functions\ndo-n-times(\"hello\", { println(_) }, 2)\n\n; the short hand works for multiple arguments as well. \nval multi-lambda = { println(_ + 2 * _) }\nmulti-lambda(1, 2)\n\n;==============================================================================\n; User defined types\n;==============================================================================\n; Structs are declared with the `defstruct` keyword\ndefstruct MyStruct: \n  field\n\n; constructors are derived automatically\nval my-struct = MyStruct(\"field:value\")\n\n; fields are accessed using function-call syntax\nprintln(field(my-struct))\n\n; Stanza supports subtyping with a \"multimethod\" system based on method \n; overloading.\ndeftype MyType\ndefmulti a-method (m:MyType)\n\ndefstruct Foo <: MyType\ndefstruct Bar <: MyType\ndefmethod a-method (a-foo: Foo):\n  println(\"called a-method on a Foo\")\n\ndefmethod a-method (a-foo: Bar):\n  println(\"called a-method on a Bar\")\n\n;==============================================================================\n; The Type System\n;==============================================================================\n; True and Falseare types with a single value. \nval a-true: True = true \nval a-false: False = false \n\n; You can declare a union type, or a value that is one of a set of types \nval a-boolean: True|False = true \nval another-boolean: True|False = false \n\n; You can pattern match on types \nmatch(a-boolean):\n  (t:True): println(\"is true\")\n  (f:False): println(\"is false\")\n\n; You can match against a single possible type\nmatch(a-boolean:True):\n  println(\"is still true\")\nelse: \n  println(\"is not true\")\n\n; You can compose program logic around the type of a variable\nif anything is Float :\n  println(\"anything is a float\")\nelse if anything is-not String : \n  println(\"anything is not an int\")\nelse : \n  println(\"I don't know what anything is\")\n\n;==============================================================================\n; Control Flow \n;==============================================================================\n; stanza has the standard basic control flow \nval condition = [false, false]\nif condition[0] : \n  ; do something \n  false \nelse if condition[1] : \n  ; do another thing\n  false \nelse :\n  ; whatever else\n  false\n\n; there is also a switch statement, which can be used to pattern match\n; on values (as opposed to types)\nswitch(anything):\n  \"this\": false \n  \"that\": false \n  \"the-other-thing\": false \n  else: false \n\n; for and while loops are supported\nwhile condition[0]: \n  println(\"do stuff\")\n\nfor i in 0 to 10 do:  \n  vector[i] = i\n\n; stanza also supports named labels which can functin as break or return \n; statements\ndefn another-fn (): \n  label<False> return:\n    label<False> break:\n      while true: \n        if condition[0] is False: \n            break(false) \n    return(false)\n\n; For a comprehensive guide on Stanza's advanced control flow, check out \n; this page: http://lbstanza.org/chapter9.html from Stanza-by-Example\n\n;==============================================================================\n; Sequences \n;==============================================================================\n; for \"loops\" are sugar for a more powerful syntax. \nval xs = [1, 2, 3] \nval ys = ['a', 'b', 'c']\nval zs = [\"foo\", \"bar\", \"baz\"]\n\nfor (x in xs, y in ys, z in zs) do : \n  println(\"x:%_, y:%_, z:%_\" % [x, y, z])\n\n\n;xs, ys, and zs are all \"Seqable\" meaing they are Seq types (sequences). \n; the `do` identifier is a special function that just applies the body of\n; the for loop to each element of the sequence.\n; \n; A common sequence task is concatenating sequences. This is accomplished \n; using the `seq-cat` function. This is analogous to \"flattening\" iterateors\nval concat = to-tuple $ \n  for sequence in [xs, ys, zs] seq-cat: \n    sequence\n\n; we can also use a variation to interleave the elements of multiple sequences\nval interleaved = to-tuple $ \n  for (x in xs, y in ys, z in zs) seq-cat : \n    [x, y, z]\n\nprintln(\"[%,] [%,]\" % [concat, interleaved])\n\n; Another common task is mapping a sequence to another, for example multiplying\n; all the elements of a list of numbers by a constant. To do this we use `seq`. \nvar numbers = [1.0, 2.0, 3.0, 4.0] \nnumbers = to-tuple $ \n  for n in numbers seq : \n    2.0 * n \nprintln(\"%,\" % [numbers])\n\nif find({_ == 2.0}, numbers) is-not False : \n  println(\"found it!\")\n\n; or maybe we just want to know if there's something in a sequence \nvar is-there = \n  for n in numbers any? :\n    n == 2.0 \n\n; since this is \"syntactic sugar\" we can write it explicitly using an \n; anonymous function\nis-there = any?({_ == 2.0}, numbers)\n\n; a detailed reference of the sequence library and various adaptors can \n; be found here: http://lbstanza.org/reference.html#anchor439\n\n\n=========================================================================\n; Documentation \n;=========================================================================\n;\n; Top level statements can be prefixed with the \"doc\" field which takes \n; a string value and is used to autogenerate documentation for the package. \ndoc: \\<doc>\n    # Document Strings \n\n    ```stanza\n    val you-can = \"include code snippets, too\" \n    ```\n\n    To render documentation as markdown (compatible with mdbook)\n\n    ```bash \n    stanza doc source.stanza -o docs \n    ```\n\\<doc>\ndefn docfn () : false \n```"
