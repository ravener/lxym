
package pages

const Prolog = "Prolog is a logic programming language first specified in 1972, and refined into multiple modern implementations.\n\n```\n% This is a comment.\n\n% Prolog treats code entered in interactive mode differently\n% to code entered in a file and loaded (\"consulted\").\n% This code must be loaded from a file to work as intended.\n% Lines that begin with ?- can be typed in interactive mode.\n% A bunch of errors and warnings will trigger when you load this file\n% due to the examples which are supposed to fail - they can be safely\n% ignored.\n\n% Output is based on SWI-prolog 7.2.3. Different Prologs may behave\n% differently.\n\n% Prolog is based on the ideal of logic programming.\n% A subprogram (called a predicate) represents a state of the world.\n% A command (called a goal) tells Prolog to make that state of the world\n%   come true, if possible.\n\n% As an example, here is a definition of the simplest kind of predicate:\n% a fact.\n\nmagicNumber(7).\nmagicNumber(9).\nmagicNumber(42).\n\n% This introduces magicNumber as a predicate and says that it is true\n% with parameter 7, 9, or 42, but no other parameter. Note that\n% predicate names must start with lower case letters. We can now use\n% interactive mode to ask if it is true for different values:\n\n?- magicNumber(7).                   % True\n?- magicNumber(8).                   % False\n?- magicNumber(9).                   % True\n\n% Some older Prologs may display \"Yes\" and \"No\" instead of True and\n% False.\n\n% What makes Prolog unusual is that we can also tell Prolog to _make_\n% magicNumber true, by passing it an undefined variable. Any name\n% starting with a capital letter is a variable in Prolog.\n\n?- magicNumber(Presto).              % Presto = 7 ;\n                                     % Presto = 9 ;\n                                     % Presto = 42.\n\n% Prolog makes magicNumber true by assigning one of the valid numbers to\n% the undefined variable Presto. By default it assigns the first one, 7.\n% By pressing ; in interactive mode you can reject that solution and\n% force it to assign the next one, 9. Pressing ; again forces it to try\n% the last one, 42, after which it no longer accepts input because this\n% is the last solution. You can accept an earlier solution by pressing .\n% instead of ;.\n\n% This is Prolog's central operation: unification. Unification is\n% essentially a combination of assignment and equality! It works as\n% follows:\n%  If both sides are bound (ie, defined), check equality.\n%  If one side is free (ie, undefined), assign to match the other side.\n%  If both sides are free, the assignment is remembered. With some luck,\n%    one of the two sides will eventually be bound, but this isn't\n%    necessary.\n%\n% The = sign in Prolog represents unification, so:\n\n?- 2 = 3.                            % False - equality test\n?- X = 3.                            % X = 3 - assignment\n?- X = 2, X = Y.                     % X = Y = 2 - two assignments\n                                     % Note Y is assigned too, even though it is\n                                     % on the right hand side, because it is free\n?- X = 3, X = 2.                     % False\n                                     % First acts as assignment and binds X=3\n                                     % Second acts as equality because X is bound\n                                     % Since 3 does not equal 2, gives False\n                                     % Thus in Prolog variables are immutable\n?- X = 3+2.                          % X = 3+2 - unification can't do arithmetic\n?- X is 3+2.                         % X = 5 - \"is\" does arithmetic.\n?- 5 = X+2.                          % This is why = can't do arithmetic -\n                                     % because Prolog can't solve equations\n?- 5 is X+2.                         % Error. Unlike =, the right hand side of IS\n                                     % must always be bound, thus guaranteeing\n                                     % no attempt to solve an equation.\n?- X = Y, X = 2, Z is Y + 3.         % X = Y, Y = 2, Z = 5.\n                                     % X = Y are both free, so Prolog remembers\n                                     % it. Therefore assigning X will also\n                                     % assign Y.\n\n% Any unification, and thus any predicate in Prolog, can either:\n% Succeed (return True) without changing anything,\n%   because an equality-style unification was true\n% Succeed (return True) and bind one or more variables in the process,\n%   because an assignment-style unification was made true\n% or Fail (return False)\n%   because an equality-style unification was false\n% (Failure can never bind variables)\n\n% The ideal of being able to give any predicate as a goal and have it\n% made true is not always possible, but can be worked toward. For\n% example, Prolog has a built in predicate plus which represents\n% arithmetic addition but can reverse simple additions.\n\n?- plus(1, 2, 3).                    % True\n?- plus(1, 2, X).                    % X = 3 because 1+2 = X.\n?- plus(1, X, 3).                    % X = 2 because 1+X = 3.\n?- plus(X, 2, 3).                    % X = 1 because X+2 = 3.\n?- plus(X, 5, Y).                    % Error - although this could be solved,\n                                     % the number of solutions is infinite,\n                                     % which most predicates try to avoid.\n\n% When a predicate such as magicNumber can give several solutions, the\n% overall compound goal including it may have several solutions too.\n\n?- magicNumber(X), plus(X,Y,100).    % X = 7, Y = 93 ;\n                                     % X = 9, Y = 91 ;\n                                     % X = 42, Y = 58 .\n% Note: on this occasion it works to pass two variables to plus because\n% only Y is free (X is bound by magicNumber).\n\n% However, if one of the goals is fully bound and thus acts as a test,\n% then solutions which fail the test are rejected.\n?- magicNumber(X), X > 40.           % X = 42\n?- magicNumber(X), X > 100.          % False\n\n% To see how Prolog actually handles this, let's introduce the print\n% predicate. Print always succeeds, never binds any variables, and\n% prints out its parameter as a side effect.\n\n?- print(\"Hello\").                   % \"Hello\" true.\n?- X = 2, print(X).                  % 2 true.\n?- X = 2, print(X), X = 3.           % 2 false - print happens immediately when\n                                     % it is encountered, even though the overall\n                                     % compound goal fails (because 2 != 3,\n                                     % see the example above).\n\n% By using Print we can see what actually happens when we give a\n% compound goal including a test that sometimes fails.\n?- magicNumber(X), print(X), X > 40. % 7 9 42 X = 42 .\n\n% MagicNumber(X) unifies X with its first possibility, 7.\n% Print(X) prints out 7.\n% X > 40 tests if 7 > 40. It is not, so it fails.\n% However, Prolog remembers that magicNumber(X) offered multiple\n% solutions. So it _backtracks_ to that point in the code to try\n% the next solution, X = 9.\n% Having backtracked it must work through the compound goal\n% again from that point including the Print(X). So Print(X) prints out\n% 9.\n% X > 40 tests if 9 > 40 and fails again.\n% Prolog remembers that magicNumber(X) still has solutions and\n% backtracks. Now X = 42.\n% It works through the Print(X) again and prints 42.\n% X > 40 tests if 42 > 40 and succeeds so the result bound to X\n% The same backtracking process is used when you reject a result at\n% the interactive prompt by pressing ;, for example:\n\n?- magicNumber(X), print(X), X > 8.  % 7 9 X = 9 ;\n                                     % 42 X = 42.\n\n% As you saw above we can define our own simple predicates as facts.\n% More complex predicates are defined as rules, like this:\n\nnearby(X,Y) :- X = Y.\nnearby(X,Y) :- Y is X+1.\nnearby(X,Y) :- Y is X-1.\n\n% nearby(X,Y) is true if Y is X plus or minus 1.\n% However this predicate could be improved. Here's why:\n\n?- nearby(2,3).                      % True ; False.\n% Because we have three possible definitions, Prolog sees this as 3\n% possibilities. X = Y fails, so Y is X+1 is then tried and succeeds,\n% giving the True answer. But Prolog still remembers there are more\n% possibilities for nearby() (in Prolog terminology, \"it has a\n% choice point\") even though \"Y is X-1\" is doomed to fail, and gives us\n% the option of rejecting the True answer, which doesn't make a whole\n% lot of sense.\n\n?- nearby(4, X).                     % X = 4 ;\n                                     % X = 5 ;\n                                     % X = 3. Great, this works\n?- nearby(X, 4).                     % X = 4 ;\n                                     % error\n% After rejecting X = 4 prolog backtracks and tries \"Y is X+1\" which is\n% \"4 is X+1\" after substitution of parameters. But as we know from above\n% \"is\" requires its argument to be fully instantiated and it is not, so\n% an error occurs.\n\n% One way to solve the first problem is to use a construct called the\n% cut, !, which does nothing but which cannot be backtracked past.\n\nnearbychk(X,Y) :- X = Y, !.\nnearbychk(X,Y) :- Y is X+1, !.\nnearbychk(X,Y) :- Y is X-1.\n\n% This solves the first problem:\n?- nearbychk(2,3).                   % True.\n\n% But unfortunately it has consequences:\n?- nearbychk(2,X).                   % X = 2.\n% Because Prolog cannot backtrack past the cut after X = Y, it cannot\n% try the possibilities \"Y is X+1\" and \"Y is X-1\", so it only generates\n% one solution when there should be 3.\n% However if our only interest is in checking if numbers are nearby,\n% this may be all we need, thus the name nearbychk.\n% This structure is used in Prolog itself from time to time (for example\n% in list membership).\n\n% To solve the second problem we can use built-in predicates in Prolog\n% to verify if a parameter is bound or free and adjust our calculations\n% appropriately.\nnearby2(X,Y) :- nonvar(X), X = Y.\nnearby2(X,Y) :- nonvar(X), Y is X+1.\nnearby2(X,Y) :- nonvar(X), Y is X-1.\nnearby2(X,Y) :- var(X), nonvar(Y), nearby2(Y,X).\n\n% We can combine this with a cut in the case where both variables are\n% bound, to solve both problems.\nnearby3(X,Y) :- nonvar(X), nonvar(Y), nearby2(X,Y), !.\nnearby3(X,Y) :- nearby2(X,Y).\n\n% However when writing a predicate it is not normally necessary to go to\n% these lengths to perfectly support every possible parameter\n% combination. It suffices to support parameter combinations we need to\n% use in the program. It is a good idea to document which combinations\n% are supported. In regular Prolog this is informally in structured\n% comments, but in some Prolog variants like Visual Prolog and Mercury\n% this is mandatory and checked by the compiler.\n\n% Here is the structured comment declaration for nearby3:\n\n%!    nearby3(+X:Int, +Y:Int) is semideterministic.\n%!    nearby3(+X:Int, -Y:Int) is multi.\n%!    nearby3(-X:Int, +Y:Int) is multi.\n\n% For each variable we list a type. The + or - before the variable name\n% indicates if the parameter is bound (+) or free (-). The word after\n% \"is\" describes the behaviour of the predicate:\n%   semideterministic - can succeed once or fail\n%     ( Two specific numbers are either nearby or not )\n%   multi - can succeed multiple times but cannot fail\n%     ( One number surely has at least 3 nearby numbers )\n%  Other possibilities are:\n%    det - always succeeds exactly once (eg, print)\n%    nondet - can succeed multiple times or fail.\n% In Prolog these are just structured comments and strictly informal but\n% extremely useful.\n\n% An unusual feature of Prolog is its support for atoms. Atoms are\n% essentially members of an enumerated type that are created on demand\n% whenever an unquoted non variable value is used. For example:\ncharacter(batman).            % Creates atom value batman\ncharacter(robin).             % Creates atom value robin\ncharacter(joker).             % Creates atom value joker\ncharacter(darthVader).        % Creates atom value darthVader\n?- batman = batman.           % True - Once created value is reused\n?- batman = batMan.           % False - atoms are case sensitive\n?- batman = darthVader.       % False - atoms are distinct\n\n% Atoms are popular in examples but were created on the assumption that\n% Prolog would be used interactively by end users - they are less\n% useful for modern applications and some Prolog variants abolish them\n% completely. However they can be very useful internally.\n\n% Loops in Prolog are classically written using recursion.\n% Note that below, writeln is used instead of print because print is\n% intended for debugging.\n\n%!    countTo(+X:Int) is deterministic.\n%!    countUpTo(+Value:Int, +Limit:Int) is deterministic.\ncountTo(X) :- countUpTo(1,X).\ncountUpTo(Value, Limit) :- Value = Limit, writeln(Value), !.\ncountUpTo(Value, Limit) :- Value \\= Limit, writeln(Value),\n    NextValue is Value+1,\n    countUpTo(NextValue, Limit).\n\n?- countTo(10).                      % Outputs 1 to 10\n\n% Note the use of multiple declarations in countUpTo to create an\n% IF test. If Value = Limit fails the second declaration is run.\n% There is also a more elegant syntax.\n\n%!    countUpTo2(+Value:Int, +Limit:Int) is deterministic.\ncountUpTo2(Value, Limit) :- writeln(Value),\n    Value = Limit -> true ; (\n        NextValue is Value+1,\n        countUpTo2(NextValue, Limit)).\n\n?- countUpTo2(1,10).                 % Outputs 1 to 10\n\n% If a predicate returns multiple times it is often useful to loop\n% through all the values it returns. Older Prologs used a hideous syntax\n% called a \"failure-driven loop\" to do this, but newer ones use a higher\n% order function.\n\n%!    countTo2(+X:Int) is deterministic.\ncountTo2(X) :- forall(between(1,X,Y),writeln(Y)).\n\n?- countTo2(10).                     % Outputs 1 to 10\n\n% Lists are given in square brackets. Use memberchk to check membership.\n% A group is safe if it doesn't include Joker or does include Batman.\n\n%!     safe(Group:list(atom)) is deterministic.\nsafe(Group) :- memberchk(joker, Group) -> memberchk(batman, Group) ; true.\n\n?- safe([robin]).                    % True\n?- safe([joker]).                    % False\n?- safe([joker, batman]).            % True\n\n% The member predicate works like memberchk if both arguments are bound,\n% but can accept free variables and thus can be used to loop through\n% lists.\n\n?- member(X, [1,2,3]).               % X = 1 ; X = 2 ; X = 3 .\n?- forall(member(X,[1,2,3]),\n       (Y is X+1, writeln(Y))).      % 2 3 4\n\n% The maplist function can be used to generate lists based on other\n% lists. Note that the output list is a free variable, causing an\n% undefined value to be passed to plus, which is then bound by\n% unification. Also notice the use of currying on the plus predicate -\n% it's a 3 argument predicate, but we specify only the first, because\n% the second and third are filled in by maplist.\n\n?- maplist(plus(1), [2,3,4], Output).   % Output = [3, 4, 5].\n```\n\n##Ready For More?\n\n* [SWI-Prolog](http://www.swi-prolog.org/)"
