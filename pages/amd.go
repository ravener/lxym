
package pages

const Amd = "## Getting Started with AMD\n\nThe **Asynchronous Module Definition** API specifies a mechanism for defining\nJavaScript modules such that the module and its dependencies can be asynchronously\nloaded. This is particularly well suited for the browser environment where\nsynchronous loading of modules incurs performance, usability, debugging, and\ncross-domain access problems.\n\n### Basic concept\n```javascript\n// The basic AMD API consists of nothing but two methods: `define` and `require`\n// and is all about module definition and consumption:\n// `define(id?, dependencies?, factory)` defines a module\n// `require(dependencies, callback)` imports a set of dependencies and\n// consumes them in the passed callback\n\n// Let's start by using define to define a new named module\n// that has no dependencies. We'll do so by passing a name\n// and a factory function to define:\ndefine('awesomeAMD', function(){\n  var isAMDAwesome = function(){\n    return true;\n  };\n  // The return value of a module's factory function is\n  // what other modules or require calls will receive when\n  // requiring our `awesomeAMD` module.\n  // The exported value can be anything, (constructor) functions,\n  // objects, primitives, even undefined (although that won't help too much).\n  return isAMDAwesome;\n});\n\n// Now, let's define another module that depends upon our `awesomeAMD` module.\n// Notice that there's an additional argument defining our\n// module's dependencies now:\ndefine('loudmouth', ['awesomeAMD'], function(awesomeAMD){\n  // dependencies will be passed to the factory's arguments\n  // in the order they are specified\n  var tellEveryone = function(){\n    if (awesomeAMD()){\n      alert('This is sOoOo rad!');\n    } else {\n      alert('Pretty dull, isn\\'t it?');\n    }\n  };\n  return tellEveryone;\n});\n\n// As we do know how to use define now, let's use `require` to\n// kick off our program. `require`'s signature is `(arrayOfDependencies, callback)`.\nrequire(['loudmouth'], function(loudmouth){\n  loudmouth();\n});\n\n// To make this tutorial run code, let's implement a very basic\n// (non-asynchronous) version of AMD right here on the spot:\nfunction define(name, deps, factory){\n  // notice how modules without dependencies are handled\n  define[name] = require(factory ? deps : [], factory || deps);\n}\n\nfunction require(deps, callback){\n  var args = [];\n  // first let's retrieve all the dependencies needed\n  // by the require call\n  for (var i = 0; i < deps.length; i++){\n    args[i] = define[deps[i]];\n  }\n  // satisfy all the callback's dependencies\n  return callback.apply(null, args);\n}\n// you can see this code in action here: http://jsfiddle.net/qap949pd/\n```\n\n### Real-world usage with require.js\n\nIn contrast to the introductory example, `require.js` (the most popular AMD library) actually implements the **A** in **AMD**, enabling you to load modules and their dependencies asynchronously via XHR:\n\n```javascript\n/* file: app/main.js */\nrequire(['modules/someClass'], function(SomeClass){\n  // the callback is deferred until the dependency is loaded\n  var thing = new SomeClass();\n});\nconsole.log('So here we are, waiting!'); // this will run first\n```\n\nBy convention, you usually store one module in one file. `require.js` can resolve module names based on file paths, so you don't have to name your modules, but can simply reference them using their location. In the example `someClass` is assumed to be in the `modules` folder, relative to your configuration's `baseUrl`:\n\n* app/\n  * main.js\n  * modules/\n    * someClass.js\n    * someHelpers.js\n    * ...\n  * daos/\n    * things.js\n    * ...\n\nThis means we can define `someClass` without specifying a module id:\n\n```javascript\n/* file: app/modules/someClass.js */\ndefine(['daos/things', 'modules/someHelpers'], function(thingsDao, helpers){\n  // module definition, of course, will also happen asynchronously\n  function SomeClass(){\n    this.method = function(){/**/};\n    // ...\n  }\n  return SomeClass;\n});\n```\nTo alter the default path mapping behavior use `requirejs.config(configObj)` in your `main.js`:\n\n```javascript\n/* file: main.js */\nrequirejs.config({\n  baseUrl : 'app',\n  paths : {\n    // you can also load modules from other locations\n    jquery : '//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min',\n    coolLibFromBower : '../bower_components/cool-lib/coollib'\n  }\n});\nrequire(['jquery', 'coolLibFromBower', 'modules/someHelpers'], function($, coolLib, helpers){\n  // a `main` file needs to call require at least once,\n  // otherwise no code will ever run\n  coolLib.doFancyStuffWith(helpers.transform($('#foo')));\n});\n```\n`require.js`-based apps will usually have a single entry point (`main.js`) that is passed to the `require.js` script tag as a data-attribute. It will be automatically loaded and executed on pageload:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>A hundred script tags? Never again!</title>\n</head>\n<body>\n  <script src=\"require.js\" data-main=\"app/main\"></script>\n</body>\n</html>\n```\n\n### Optimizing a whole project using r.js\n\nMany people prefer using AMD for sane code organization during development, but still want to ship a single script file in production instead of performing hundreds of XHRs on page load.\n\n`require.js` comes with a script called `r.js` (that you will probably run in node.js, although Rhino is supported too) that can analyse your project's dependency graph, and build a single file containing all your modules (properly named), minified and ready for consumption.\n\nInstall it using `npm`:\n```shell\n$ npm install requirejs -g\n```\n\nNow you can feed it with a configuration file:\n```shell\n$ r.js -o app.build.js\n```\n\nFor our above example the configuration might look like:\n```javascript\n/* file : app.build.js */\n({\n  name : 'main', // name of the entry point\n  out : 'main-built.js', // name of the file to write the output to\n  baseUrl : 'app',\n  paths : {\n    // `empty:` tells r.js that this should still be loaded from the CDN, using\n    // the location specified in `main.js`\n    jquery : 'empty:',\n    coolLibFromBower : '../bower_components/cool-lib/coollib'\n  }\n})\n```\n\nTo use the built file in production, simply swap `data-main`:\n```html\n<script src=\"require.js\" data-main=\"app/main-built\"></script>\n```\n\nAn incredibly detailed [overview of build options](https://github.com/jrburke/r.js/blob/master/build/example.build.js) is available in the GitHub repo.\n\n### Topics not covered in this tutorial\n* [Loader plugins / transforms](http://requirejs.org/docs/plugins.html)\n* [CommonJS style loading and exporting](http://requirejs.org/docs/commonjs.html)\n* [Advanced configuration](http://requirejs.org/docs/api.html#config)\n* [Shim configuration (loading non-AMD modules)](http://requirejs.org/docs/api.html#config-shim)\n* [CSS loading and optimizing with require.js](http://requirejs.org/docs/optimization.html#onecss)\n* [Using almond.js for builds](https://github.com/jrburke/almond)\n\n### Further reading:\n\n* [Official Spec](https://github.com/amdjs/amdjs-api/wiki/AMD)\n* [Why AMD?](http://requirejs.org/docs/whyamd.html)\n* [Universal Module Definition](https://github.com/umdjs/umd)\n\n### Implementations:\n\n* [require.js](http://requirejs.org)\n* [dojo toolkit](http://dojotoolkit.org/documentation/tutorials/1.9/modules/)\n* [cujo.js](http://cujojs.com/)\n* [curl.js](https://github.com/cujojs/curl)\n* [lsjs](https://github.com/zazl/lsjs)\n* [mmd](https://github.com/alexlawrence/mmd)"
