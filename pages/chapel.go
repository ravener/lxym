
package pages

const Chapel = "You can read all about Chapel at [Cray's official Chapel website](https://chapel-lang.org).\nIn short, Chapel is an open-source, high-productivity, parallel-programming\nlanguage in development at Cray Inc., and is designed to run on multi-core PCs\nas well as multi-kilocore supercomputers.\n\nMore information and support can be found at the bottom of this document.\n\n```chapel\n// Comments are C-family style\n\n// one line comment\n/*\n multi-line comment\n*/\n\n// Basic printing\n\nwrite(\"Hello, \");\nwriteln(\"World!\");\n\n// write and writeln can take a list of things to print.\n// Each thing is printed right next to the others, so include your spacing!\nwriteln(\"There are \", 3, \" commas (\\\",\\\") in this line of code\");\n\n// Different output channels:\nstdout.writeln(\"This goes to standard output, just like plain writeln() does\");\nstderr.writeln(\"This goes to standard error\");\n\n\n// Variables don't have to be explicitly typed as long as\n// the compiler can figure out the type that it will hold.\n// 10 is an int, so myVar is implicitly an int\nvar myVar = 10;\nmyVar = -10;\nvar mySecondVar = myVar;\n// var anError; would be a compile-time error.\n\n// We can (and should) explicitly type things.\nvar myThirdVar: real;\nvar myFourthVar: real = -1.234;\nmyThirdVar = myFourthVar;\n\n// Types\n\n// There are a number of basic types.\nvar myInt: int = -1000; // Signed ints\nvar myUint: uint = 1234; // Unsigned ints\nvar myReal: real = 9.876; // Floating point numbers\nvar myImag: imag = 5.0i; // Imaginary numbers\nvar myCplx: complex = 10 + 9i; // Complex numbers\nmyCplx = myInt + myImag; // Another way to form complex numbers\nvar myBool: bool = false; // Booleans\nvar myStr: string = \"Some string...\"; // Strings\nvar singleQuoteStr = 'Another string...'; // String literal with single quotes\n\n// Some types can have sizes.\nvar my8Int: int(8) = 10; // 8 bit (one byte) sized int;\nvar my64Real: real(64) = 1.516; // 64 bit (8 bytes) sized real\n\n// Typecasting.\nvar intFromReal = myReal : int;\nvar intFromReal2: int = myReal : int;\n\n// Type aliasing.\ntype chroma = int;        // Type of a single hue\ntype RGBColor = 3*chroma; // Type representing a full color\nvar black: RGBColor = (0,0,0);\nvar white: RGBColor = (255, 255, 255);\n\n// Constants and Parameters\n\n// A const is a constant, and cannot be changed after set in runtime.\nconst almostPi: real = 22.0/7.0;\n\n// A param is a constant whose value must be known statically at\n// compile-time.\nparam compileTimeConst: int = 16;\n\n// The config modifier allows values to be set at the command line.\n// Set with --varCmdLineArg=Value or --varCmdLineArg Value at runtime.\nconfig var varCmdLineArg: int = -123;\nconfig const constCmdLineArg: int = 777;\n\n// config param can be set at compile-time.\n// Set with --set paramCmdLineArg=value at compile-time.\nconfig param paramCmdLineArg: bool = false;\nwriteln(varCmdLineArg, \", \", constCmdLineArg, \", \", paramCmdLineArg);\n\n// References\n\n// ref operates much like a reference in C++. In Chapel, a ref cannot\n// be made to alias a variable other than the variable it is initialized with.\n// Here, refToActual refers to actual.\nvar actual = 10;\nref refToActual = actual;\nwriteln(actual, \" == \", refToActual); // prints the same value\nactual = -123; // modify actual (which refToActual refers to)\nwriteln(actual, \" == \", refToActual); // prints the same value\nrefToActual = 99999999; // modify what refToActual refers to (which is actual)\nwriteln(actual, \" == \", refToActual); // prints the same value\n\n// Operators\n\n// Math operators:\nvar a: int, thisInt = 1234, thatInt = 5678;\na = thisInt + thatInt;  // Addition\na = thisInt * thatInt;  // Multiplication\na = thisInt - thatInt;  // Subtraction\na = thisInt / thatInt;  // Division\na = thisInt ** thatInt; // Exponentiation\na = thisInt % thatInt;  // Remainder (modulo)\n\n// Logical operators:\nvar b: bool, thisBool = false, thatBool = true;\nb = thisBool && thatBool; // Logical and\nb = thisBool || thatBool; // Logical or\nb = !thisBool;            // Logical negation\n\n// Relational operators:\nb = thisInt > thatInt;           // Greater-than\nb = thisInt >= thatInt;          // Greater-than-or-equal-to\nb = thisInt < a && a <= thatInt; // Less-than, and, less-than-or-equal-to\nb = thisInt != thatInt;          // Not-equal-to\nb = thisInt == thatInt;          // Equal-to\n\n// Bitwise operators:\na = thisInt << 10;     // Left-bit-shift by 10 bits;\na = thatInt >> 5;      // Right-bit-shift by 5 bits;\na = ~thisInt;          // Bitwise-negation\na = thisInt ^ thatInt; // Bitwise exclusive-or\n\n// Compound assignment operators:\na += thisInt;          // Addition-equals (a = a + thisInt;)\na *= thatInt;          // Times-equals (a = a * thatInt;)\nb &&= thatBool;        // Logical-and-equals (b = b && thatBool;)\na <<= 3;               // Left-bit-shift-equals (a = a << 10;)\n\n// Unlike other C family languages, there are no\n// pre/post-increment/decrement operators, such as:\n//\n// ++j, --j, j++, j--\n\n// Swap operator:\nvar old_this = thisInt;\nvar old_that = thatInt;\nthisInt <=> thatInt; // Swap the values of thisInt and thatInt\nwriteln((old_this == thatInt) && (old_that == thisInt));\n\n// Operator overloads can also be defined, as we'll see with procedures.\n\n// Tuples\n\n// Tuples can be of the same type or different types.\nvar sameTup: 2*int = (10, -1);\nvar sameTup2 = (11, -6);\nvar diffTup: (int,real,complex) = (5, 1.928, myCplx);\nvar diffTupe2 = (7, 5.64, 6.0+1.5i);\n\n// Tuples can be accessed using square brackets or parentheses, and are\n// 1-indexed.\nwriteln(\"(\", sameTup[1], \",\", sameTup(2), \")\");\nwriteln(diffTup);\n\n// Tuples can also be written into.\ndiffTup(1) = -1;\n\n// Tuple values can be expanded into their own variables.\nvar (tupInt, tupReal, tupCplx) = diffTup;\nwriteln(diffTup == (tupInt, tupReal, tupCplx));\n\n// They are also useful for writing a list of variables, as is common in debugging.\nwriteln((a,b,thisInt,thatInt,thisBool,thatBool));\n\n// Control Flow\n\n// if - then - else works just like any other C-family language.\nif 10 < 100 then\n  writeln(\"All is well\");\n\nif -1 < 1 then\n  writeln(\"Continuing to believe reality\");\nelse\n  writeln(\"Send mathematician, something is wrong\");\n\n// You can use parentheses if you prefer.\nif (10 > 100) {\n  writeln(\"Universe broken. Please reboot universe.\");\n}\n\nif a % 2 == 0 {\n  writeln(a, \" is even.\");\n} else {\n  writeln(a, \" is odd.\");\n}\n\nif a % 3 == 0 {\n  writeln(a, \" is even divisible by 3.\");\n} else if a % 3 == 1 {\n  writeln(a, \" is divided by 3 with a remainder of 1.\");\n} else {\n  writeln(b, \" is divided by 3 with a remainder of 2.\");\n}\n\n// Ternary: if - then - else in a statement.\nvar maximum = if thisInt < thatInt then thatInt else thisInt;\n\n// select statements are much like switch statements in other languages.\n// However, select statements do not cascade like in C or Java.\nvar inputOption = \"anOption\";\nselect inputOption {\n  when \"anOption\" do writeln(\"Chose 'anOption'\");\n  when \"otherOption\" {\n    writeln(\"Chose 'otherOption'\");\n    writeln(\"Which has a body\");\n  }\n  otherwise {\n    writeln(\"Any other Input\");\n    writeln(\"the otherwise case does not need a do if the body is one line\");\n  }\n}\n\n// while and do-while loops also behave like their C counterparts.\nvar j: int = 1;\nvar jSum: int = 0;\nwhile (j <= 1000) {\n  jSum += j;\n  j += 1;\n}\nwriteln(jSum);\n\ndo {\n  jSum += j;\n  j += 1;\n} while (j <= 10000);\nwriteln(jSum);\n\n// for loops are much like those in Python in that they iterate over a\n// range. Ranges (like the 1..10 expression below) are a first-class object\n// in Chapel, and as such can be stored in variables.\nfor i in 1..10 do write(i, \", \");\nwriteln();\n\nvar iSum: int = 0;\nfor i in 1..1000 {\n  iSum += i;\n}\nwriteln(iSum);\n\nfor x in 1..10 {\n  for y in 1..10 {\n    write((x,y), \"\\t\");\n  }\n  writeln();\n}\n\n// Ranges and Domains\n\n// For-loops and arrays both use ranges and domains to define an index set that\n// can be iterated over. Ranges are single dimensional integer indices, while\n// domains can be multi-dimensional and represent indices of different types.\n\n// They are first-class citizen types, and can be assigned into variables.\nvar range1to10: range = 1..10;  // 1, 2, 3, ..., 10\nvar range2to11 = 2..11; // 2, 3, 4, ..., 11\nvar rangeThisToThat: range = thisInt..thatInt; // using variables\nvar rangeEmpty: range = 100..-100; // this is valid but contains no indices\n\n// Ranges can be unbounded.\nvar range1toInf: range(boundedType=BoundedRangeType.boundedLow) = 1.. ; // 1, 2, 3, 4, 5, ...\nvar rangeNegInfTo1 = ..1; // ..., -4, -3, -2, -1, 0, 1\n\n// Ranges can be strided (and reversed) using the by operator.\nvar range2to10by2: range(stridable=true) = 2..10 by 2; // 2, 4, 6, 8, 10\nvar reverse2to10by2 = 2..10 by -2; // 10, 8, 6, 4, 2\n\nvar trapRange = 10..1 by -1; // Do not be fooled, this is still an empty range\nwriteln(\"Size of range \", trapRange, \" = \", trapRange.length);\n\n// Note: range(boundedType= ...) and range(stridable= ...) are only\n// necessary if we explicitly type the variable.\n\n// The end point of a range can be determined using the count (#) operator.\nvar rangeCount: range = -5..#12; // range from -5 to 6\n\n// Operators can be mixed.\nvar rangeCountBy: range(stridable=true) = -5..#12 by 2; // -5, -3, -1, 1, 3, 5\nwriteln(rangeCountBy);\n\n// Properties of the range can be queried.\n// In this example, printing the first index, last index, number of indices,\n// stride, and if 2 is include in the range.\nwriteln((rangeCountBy.first, rangeCountBy.last, rangeCountBy.length,\n           rangeCountBy.stride, rangeCountBy.member(2)));\n\nfor i in rangeCountBy {\n  write(i, if i == rangeCountBy.last then \"\\n\" else \", \");\n}\n\n// Rectangular domains are defined using the same range syntax,\n// but they are required to be bounded (unlike ranges).\nvar domain1to10: domain(1) = {1..10};        // 1D domain from 1..10;\nvar twoDimensions: domain(2) = {-2..2,0..2}; // 2D domain over product of ranges\nvar thirdDim: range = 1..16;\nvar threeDims: domain(3) = {thirdDim, 1..10, 5..10}; // using a range variable\n\n// Domains can also be resized\nvar resizedDom = {1..10};\nwriteln(\"before, resizedDom = \", resizedDom);\nresizedDom = {-10..#10};\nwriteln(\"after, resizedDom = \", resizedDom);\n\n// Indices can be iterated over as tuples.\nfor idx in twoDimensions do\n  write(idx, \", \");\nwriteln();\n\n// These tuples can also be deconstructed.\nfor (x,y) in twoDimensions {\n  write(\"(\", x, \", \", y, \")\", \", \");\n}\nwriteln();\n\n// Associative domains act like sets.\nvar stringSet: domain(string); // empty set of strings\nstringSet += \"a\";\nstringSet += \"b\";\nstringSet += \"c\";\nstringSet += \"a\"; // Redundant add \"a\"\nstringSet -= \"c\"; // Remove \"c\"\nwriteln(stringSet.sorted());\n\n// Associative domains can also have a literal syntax\nvar intSet = {1, 2, 4, 5, 100};\n\n// Both ranges and domains can be sliced to produce a range or domain with the\n// intersection of indices.\nvar rangeA = 1.. ; // range from 1 to infinity\nvar rangeB =  ..5; // range from negative infinity to 5\nvar rangeC = rangeA[rangeB]; // resulting range is 1..5\nwriteln((rangeA, rangeB, rangeC));\n\nvar domainA = {1..10, 5..20};\nvar domainB = {-5..5, 1..10};\nvar domainC = domainA[domainB];\nwriteln((domainA, domainB, domainC));\n\n// Arrays\n\n// Arrays are similar to those of other languages.\n// Their sizes are defined using domains that represent their indices.\nvar intArray: [1..10] int;\nvar intArray2: [{1..10}] int; // equivalent\n\n// They can be accessed using either brackets or parentheses\nfor i in 1..10 do\n  intArray[i] = -i;\nwriteln(intArray);\n\n// We cannot access intArray[0] because it exists outside\n// of the index set, {1..10}, we defined it to have.\n// intArray[11] is illegal for the same reason.\nvar realDomain: domain(2) = {1..5,1..7};\nvar realArray: [realDomain] real;\nvar realArray2: [1..5,1..7] real;   // equivalent\nvar realArray3: [{1..5,1..7}] real; // equivalent\n\nfor i in 1..5 {\n  for j in realDomain.dim(2) {   // Only use the 2nd dimension of the domain\n    realArray[i,j] = -1.61803 * i + 0.5 * j;  // Access using index list\n    var idx: 2*int = (i,j);                   // Note: 'index' is a keyword\n    realArray[idx] = - realArray[(i,j)];      // Index using tuples\n  }\n}\n\n// Arrays have domains as members, and can be iterated over as normal.\nfor idx in realArray.domain {  // Again, idx is a 2*int tuple\n  realArray[idx] = 1 / realArray[idx[1], idx[2]]; // Access by tuple and list\n}\n\nwriteln(realArray);\n\n// The values of an array can also be iterated directly.\nvar rSum: real = 0;\nfor value in realArray {\n  rSum += value; // Read a value\n  value = rSum;  // Write a value\n}\nwriteln(rSum, \"\\n\", realArray);\n\n// Associative arrays (dictionaries) can be created using associative domains.\nvar dictDomain: domain(string) = { \"one\", \"two\" };\nvar dict: [dictDomain] int = [\"one\" => 1, \"two\" => 2];\ndict[\"three\"] = 3; // Adds 'three' to 'dictDomain' implicitly\nfor key in dictDomain.sorted() do\n  writeln(dict[key]);\n\n// Arrays can be assigned to each other in a few different ways.\n// These arrays will be used in the example.\nvar thisArray : [0..5] int = [0,1,2,3,4,5];\nvar thatArray : [0..5] int;\n\n// First, simply assign one to the other. This copies thisArray into\n// thatArray, instead of just creating a reference. Therefore, modifying\n// thisArray does not also modify thatArray.\n\nthatArray = thisArray;\nthatArray[1] = -1;\nwriteln((thisArray, thatArray));\n\n// Assign a slice from one array to a slice (of the same size) in the other.\nthatArray[4..5] = thisArray[1..2];\nwriteln((thisArray, thatArray));\n\n// Operations can also be promoted to work on arrays. 'thisPlusThat' is also\n// an array.\nvar thisPlusThat = thisArray + thatArray;\nwriteln(thisPlusThat);\n\n// Moving on, arrays and loops can also be expressions, where the loop\n// body expression is the result of each iteration.\nvar arrayFromLoop = for i in 1..10 do i;\nwriteln(arrayFromLoop);\n\n// An expression can result in nothing, such as when filtering with an if-expression.\nvar evensOrFives = for i in 1..10 do if (i % 2 == 0 || i % 5 == 0) then i;\n\nwriteln(arrayFromLoop);\n\n// Array expressions can also be written with a bracket notation.\n// Note: this syntax uses the forall parallel concept discussed later.\nvar evensOrFivesAgain = [i in 1..10] if (i % 2 == 0 || i % 5 == 0) then i;\n\n// They can also be written over the values of the array.\narrayFromLoop = [value in arrayFromLoop] value + 1;\n\n\n// Procedures\n\n// Chapel procedures have similar syntax functions in other languages.\nproc fibonacci(n : int) : int {\n  if n <= 1 then return n;\n  return fibonacci(n-1) + fibonacci(n-2);\n}\n\n// Input parameters can be untyped to create a generic procedure.\nproc doublePrint(thing): void {\n  write(thing, \" \", thing, \"\\n\");\n}\n\n// The return type can be inferred, as long as the compiler can figure it out.\nproc addThree(n) {\n  return n + 3;\n}\n\ndoublePrint(addThree(fibonacci(20)));\n\n// It is also possible to take a variable number of parameters.\nproc maxOf(x ...?k) {\n  // x refers to a tuple of one type, with k elements\n  var maximum = x[1];\n  for i in 2..k do maximum = if maximum < x[i] then x[i] else maximum;\n  return maximum;\n}\nwriteln(maxOf(1, -10, 189, -9071982, 5, 17, 20001, 42));\n\n// Procedures can have default parameter values, and\n// the parameters can be named in the call, even out of order.\nproc defaultsProc(x: int, y: real = 1.2634): (int,real) {\n  return (x,y);\n}\n\nwriteln(defaultsProc(10));\nwriteln(defaultsProc(x=11));\nwriteln(defaultsProc(x=12, y=5.432));\nwriteln(defaultsProc(y=9.876, x=13));\n\n// The ? operator is called the query operator, and is used to take\n// undetermined values like tuple or array sizes and generic types.\n// For example, taking arrays as parameters. The query operator is used to\n// determine the domain of A. This is uesful for defining the return type,\n// though it's not required.\nproc invertArray(A: [?D] int): [D] int{\n  for a in A do a = -a;\n  return A;\n}\n\nwriteln(invertArray(intArray));\n\n// We can query the type of arguments to generic procedures.\n// Here we define a procedure that takes two arguments of\n// the same type, yet we don't define what that type is.\nproc genericProc(arg1 : ?valueType, arg2 : valueType): void {\n  select(valueType) {\n    when int do writeln(arg1, \" and \", arg2, \" are ints\");\n    when real do writeln(arg1, \" and \", arg2, \" are reals\");\n    otherwise writeln(arg1, \" and \", arg2, \" are somethings!\");\n  }\n}\n\ngenericProc(1, 2);\ngenericProc(1.2, 2.3);\ngenericProc(1.0+2.0i, 3.0+4.0i);\n\n// We can also enforce a form of polymorphism with the where clause\n// This allows the compiler to decide which function to use.\n// Note: That means that all information needs to be known at compile-time.\n// The param modifier on the arg is used to enforce this constraint.\nproc whereProc(param N : int): void\n where (N > 0) {\n  writeln(\"N is greater than 0\");\n}\n\nproc whereProc(param N : int): void\n where (N < 0) {\n  writeln(\"N is less than 0\");\n}\n\nwhereProc(10);\nwhereProc(-1);\n\n// whereProc(0) would result in a compiler error because there\n// are no functions that satisfy the where clause's condition.\n// We could have defined a whereProc without a where clause\n// that would then have served as a catch all for all the other cases\n// (of which there is only one).\n\n// where clauses can also be used to constrain based on argument type.\nproc whereType(x: ?t) where t == int {\n  writeln(\"Inside 'int' version of 'whereType': \", x);\n}\n\nproc whereType(x: ?t) {\n  writeln(\"Inside general version of 'whereType': \", x);\n}\n\nwhereType(42);\nwhereType(\"hello\");\n\n// Intents\n\n/* Intent modifiers on the arguments convey how those arguments are passed to the procedure.\n\n     * in: copy arg in, but not out\n     * out: copy arg out, but not in\n     * inout: copy arg in, copy arg out\n     * ref: pass arg by reference\n*/\nproc intentsProc(in inarg, out outarg, inout inoutarg, ref refarg) {\n  writeln(\"Inside Before: \", (inarg, outarg, inoutarg, refarg));\n  inarg = inarg + 100;\n  outarg = outarg + 100;\n  inoutarg = inoutarg + 100;\n  refarg = refarg + 100;\n  writeln(\"Inside After: \", (inarg, outarg, inoutarg, refarg));\n}\n\nvar inVar: int = 1;\nvar outVar: int = 2;\nvar inoutVar: int = 3;\nvar refVar: int = 4;\nwriteln(\"Outside Before: \", (inVar, outVar, inoutVar, refVar));\nintentsProc(inVar, outVar, inoutVar, refVar);\nwriteln(\"Outside After: \", (inVar, outVar, inoutVar, refVar));\n\n// Similarly, we can define intents on the return type.\n// refElement returns a reference to an element of array.\n// This makes more practical sense for class methods where references to\n// elements in a data-structure are returned via a method or iterator.\nproc refElement(array : [?D] ?T, idx) ref : T {\n  return array[idx];\n}\n\nvar myChangingArray : [1..5] int = [1,2,3,4,5];\nwriteln(myChangingArray);\nref refToElem = refElement(myChangingArray, 5); // store reference to element in ref variable\nwriteln(refToElem);\nrefToElem = -2; // modify reference which modifies actual value in array\nwriteln(refToElem);\nwriteln(myChangingArray);\n\n// Operator Definitions\n\n// Chapel allows for operators to be overloaded.\n// We can define the unary operators:\n// + - ! ~\n// and the binary operators:\n// + - * / % ** == <= >= < > << >> & | ˆ by\n// += -= *= /= %= **= &= |= ˆ= <<= >>= <=>\n\n// Boolean exclusive or operator.\nproc ^(left : bool, right : bool): bool {\n  return (left || right) && !(left && right);\n}\n\nwriteln(true  ^ true);\nwriteln(false ^ true);\nwriteln(true  ^ false);\nwriteln(false ^ false);\n\n// Define a * operator on any two types that returns a tuple of those types.\nproc *(left : ?ltype, right : ?rtype): (ltype, rtype) {\n  writeln(\"\\tIn our '*' overload!\");\n  return (left, right);\n}\n\nwriteln(1 * \"a\"); // Uses our * operator.\nwriteln(1 * 2);   // Uses the default * operator.\n\n//  Note: You could break everything if you get careless with your overloads.\n//  This here will break everything. Don't do it.\n\n/*\n    proc +(left: int, right: int): int {\n      return left - right;\n    }\n*/\n\n// Iterators\n\n// Iterators are sisters to the procedure, and almost everything about\n// procedures also applies to iterators. However, instead of returning a single\n// value, iterators may yield multiple values to a loop.\n//\n// This is useful when a complicated set or order of iterations is needed, as\n// it allows the code defining the iterations to be separate from the loop\n// body.\niter oddsThenEvens(N: int): int {\n  for i in 1..N by 2 do\n    yield i; // yield values instead of returning.\n  for i in 2..N by 2 do\n    yield i;\n}\n\nfor i in oddsThenEvens(10) do write(i, \", \");\nwriteln();\n\n// Iterators can also yield conditionally, the result of which can be nothing\niter absolutelyNothing(N): int {\n  for i in 1..N {\n    if N < i { // Always false\n      yield i;     // Yield statement never happens\n    }\n  }\n}\n\nfor i in absolutelyNothing(10) {\n  writeln(\"Woa there! absolutelyNothing yielded \", i);\n}\n\n// We can zipper together two or more iterators (who have the same number\n// of iterations) using zip() to create a single zipped iterator, where each\n// iteration of the zipped iterator yields a tuple of one value yielded\n// from each iterator.\nfor (positive, negative) in zip(1..5, -5..-1) do\n  writeln((positive, negative));\n\n// Zipper iteration is quite important in the assignment of arrays,\n// slices of arrays, and array/loop expressions.\nvar fromThatArray : [1..#5] int = [1,2,3,4,5];\nvar toThisArray : [100..#5] int;\n\n// Some zipper operations implement other operations.\n// The first statement and the loop are equivalent.\ntoThisArray = fromThatArray;\nfor (i,j) in zip(toThisArray.domain, fromThatArray.domain) {\n  toThisArray[i] = fromThatArray[j];\n}\n\n// These two chunks are also equivalent.\ntoThisArray = [j in -100..#5] j;\nwriteln(toThisArray);\n\nfor (i, j) in zip(toThisArray.domain, -100..#5) {\n  toThisArray[i] = j;\n}\nwriteln(toThisArray);\n\n// This is very important in understanding why this statement exhibits a\n// runtime error.\n\n/*\n  var iterArray : [1..10] int = [i in 1..10] if (i % 2 == 1) then i;\n*/\n\n// Even though the domain of the array and the loop-expression are\n// the same size, the body of the expression can be thought of as an iterator.\n// Because iterators can yield nothing, that iterator yields a different number\n// of things than the domain of the array or loop, which is not allowed.\n\n// Classes\n\n// Classes are similar to those in C++ and Java, allocated on the heap.\nclass MyClass {\n\n// Member variables\n  var memberInt : int;\n  var memberBool : bool = true;\n\n// Explicitly defined initializer.\n// We also get the compiler-generated initializer, with one argument per field.\n// Note that soon there will be no compiler-generated initializer when we\n// define any initializer(s) explicitly.\n  proc init(val : real) {\n    this.memberInt = ceil(val): int;\n  }\n\n// Explicitly defined deinitializer.\n// If we did not write one, we would get the compiler-generated deinitializer,\n// which has an empty body.\n  proc deinit() {\n    writeln(\"MyClass deinitializer called \", (this.memberInt, this.memberBool));\n  }\n\n// Class methods.\n  proc setMemberInt(val: int) {\n    this.memberInt = val;\n  }\n\n  proc setMemberBool(val: bool) {\n    this.memberBool = val;\n  }\n\n  proc getMemberInt(): int{\n    return this.memberInt;\n  }\n\n  proc getMemberBool(): bool {\n    return this.memberBool;\n  }\n} // end MyClass\n\n// Call compiler-generated initializer, using default value for memberBool.\nvar myObject = new MyClass(10);\n    myObject = new MyClass(memberInt = 10); // Equivalent\nwriteln(myObject.getMemberInt());\n\n// Same, but provide a memberBool value explicitly.\nvar myDiffObject = new MyClass(-1, true);\n    myDiffObject = new MyClass(memberInt = -1,\n                                memberBool = true); // Equivalent\nwriteln(myDiffObject);\n\n// Call the initializer we wrote.\nvar myOtherObject = new MyClass(1.95);\n    myOtherObject = new MyClass(val = 1.95); // Equivalent\nwriteln(myOtherObject.getMemberInt());\n\n// We can define an operator on our class as well, but\n// the definition has to be outside the class definition.\nproc +(A : MyClass, B : MyClass) : MyClass {\n  return new MyClass(memberInt = A.getMemberInt() + B.getMemberInt(),\n                      memberBool = A.getMemberBool() || B.getMemberBool());\n}\n\nvar plusObject = myObject + myDiffObject;\nwriteln(plusObject);\n\n// Destruction.\ndelete myObject;\ndelete myDiffObject;\ndelete myOtherObject;\ndelete plusObject;\n\n// Classes can inherit from one or more parent classes\nclass MyChildClass : MyClass {\n  var memberComplex: complex;\n}\n\n// Here's an example of generic classes.\nclass GenericClass {\n  type classType;\n  var classDomain: domain(1);\n  var classArray: [classDomain] classType;\n\n// Explicit constructor.\n  proc GenericClass(type classType, elements : int) {\n    this.classDomain = {1..#elements};\n  }\n\n// Copy constructor.\n// Note: We still have to put the type as an argument, but we can\n// default to the type of the other object using the query (?) operator.\n// Further, we can take advantage of this to allow our copy constructor\n// to copy classes of different types and cast on the fly.\n  proc GenericClass(other : GenericClass(?otherType),\n                     type classType = otherType) {\n    this.classDomain = other.classDomain;\n    // Copy and cast\n    for idx in this.classDomain do this[idx] = other[idx] : classType;\n  }\n\n// Define bracket notation on a GenericClass\n// object so it can behave like a normal array\n// i.e. objVar[i] or objVar(i)\n  proc this(i : int) ref : classType {\n    return this.classArray[i];\n  }\n\n// Define an implicit iterator for the class\n// to yield values from the array to a loop\n// i.e. for i in objVar do ...\n  iter these() ref : classType {\n    for i in this.classDomain do\n      yield this[i];\n  }\n} // end GenericClass\n\n// We can assign to the member array of the object using the bracket\n// notation that we defined.\nvar realList = new GenericClass(real, 10);\nfor i in realList.classDomain do realList[i] = i + 1.0;\n\n// We can iterate over the values in our list with the iterator\n// we defined.\nfor value in realList do write(value, \", \");\nwriteln();\n\n// Make a copy of realList using the copy constructor.\nvar copyList = new GenericClass(realList);\nfor value in copyList do write(value, \", \");\nwriteln();\n\n// Make a copy of realList and change the type, also using the copy constructor.\nvar copyNewTypeList = new GenericClass(realList, int);\nfor value in copyNewTypeList do write(value, \", \");\nwriteln();\n\n\n// Modules\n\n// Modules are Chapel's way of managing name spaces.\n// The files containing these modules do not need to be named after the modules\n// (as in Java), but files implicitly name modules.\n// For example, this file implicitly names the learnChapelInYMinutes module\n\nmodule OurModule {\n\n// We can use modules inside of other modules.\n// Time is one of the standard modules.\n  use Time;\n\n// We'll use this procedure in the parallelism section.\n  proc countdown(seconds: int) {\n    for i in 1..seconds by -1 {\n      writeln(i);\n      sleep(1);\n    }\n  }\n\n// It is possible to create arbitrarily deep module nests.\n// i.e. submodules of OurModule\n  module ChildModule {\n    proc foo() {\n      writeln(\"ChildModule.foo()\");\n    }\n  }\n\n  module SiblingModule {\n    proc foo() {\n      writeln(\"SiblingModule.foo()\");\n    }\n  }\n} // end OurModule\n\n// Using OurModule also uses all the modules it uses.\n// Since OurModule uses Time, we also use Time.\nuse OurModule;\n\n// At this point we have not used ChildModule or SiblingModule so\n// their symbols (i.e. foo) are not available to us. However, the module\n// names are available, and we can explicitly call foo() through them.\nSiblingModule.foo();\nOurModule.ChildModule.foo();\n\n// Now we use ChildModule, enabling unqualified calls.\nuse ChildModule;\nfoo();\n\n// Parallelism\n\n// In other languages, parallelism is typically done with\n// complicated libraries and strange class structure hierarchies.\n// Chapel has it baked right into the language.\n\n// We can declare a main procedure, but all the code above main still gets\n// executed.\nproc main() {\n\n// A begin statement will spin the body of that statement off\n// into one new task.\n// A sync statement will ensure that the progress of the main\n// task will not progress until the children have synced back up.\n\n  sync {\n    begin { // Start of new task's body\n      var a = 0;\n      for i in 1..1000 do a += 1;\n      writeln(\"Done: \", a);\n    } // End of new tasks body\n    writeln(\"spun off a task!\");\n  }\n  writeln(\"Back together\");\n\n  proc printFibb(n: int) {\n    writeln(\"fibonacci(\",n,\") = \", fibonacci(n));\n  }\n\n// A cobegin statement will spin each statement of the body into one new\n// task. Notice here that the prints from each statement may happen in any\n// order.\n  cobegin {\n    printFibb(20); // new task\n    printFibb(10); // new task\n    printFibb(5);  // new task\n    {\n      // This is a nested statement body and thus is a single statement\n      // to the parent statement, executed by a single task.\n      writeln(\"this gets\");\n      writeln(\"executed as\");\n      writeln(\"a whole\");\n    }\n  }\n\n// A coforall loop will create a new task for EACH iteration.\n// Again we see that prints happen in any order.\n// NOTE: coforall should be used only for creating tasks!\n// Using it to iterating over a structure is very a bad idea!\n  var num_tasks = 10; // Number of tasks we want\n  coforall taskID in 1..#num_tasks {\n    writeln(\"Hello from task# \", taskID);\n  }\n\n// forall loops are another parallel loop, but only create a smaller number\n// of tasks, specifically --dataParTasksPerLocale= number of tasks.\n  forall i in 1..100 {\n    write(i, \", \");\n  }\n  writeln();\n\n// Here we see that there are sections that are in order, followed by\n// a section that would not follow (e.g. 1, 2, 3, 7, 8, 9, 4, 5, 6,).\n// This is because each task is taking on a chunk of the range 1..10\n// (1..3, 4..6, or 7..9) doing that chunk serially, but each task happens\n// in parallel. Your results may depend on your machine and configuration\n\n// For both the forall and coforall loops, the execution of the\n// parent task will not continue until all the children sync up.\n\n// forall loops are particularly useful for parallel iteration over arrays.\n// Lets run an experiment to see how much faster a parallel loop is\n  use Time; // Import the Time module to use Timer objects\n  var timer: Timer;\n  var myBigArray: [{1..4000,1..4000}] real; // Large array we will write into\n\n// Serial Experiment:\n  timer.start(); // Start timer\n  for (x,y) in myBigArray.domain { // Serial iteration\n    myBigArray[x,y] = (x:real) / (y:real);\n  }\n  timer.stop(); // Stop timer\n  writeln(\"Serial: \", timer.elapsed()); // Print elapsed time\n  timer.clear(); // Clear timer for parallel loop\n\n// Parallel Experiment:\n  timer.start(); // start timer\n  forall (x,y) in myBigArray.domain { // Parallel iteration\n    myBigArray[x,y] = (x:real) / (y:real);\n  }\n  timer.stop(); // Stop timer\n  writeln(\"Parallel: \", timer.elapsed()); // Print elapsed time\n  timer.clear();\n\n// You may have noticed that (depending on how many cores you have)\n// the parallel loop went faster than the serial loop.\n\n// The bracket style loop-expression described\n// much earlier implicitly uses a forall loop.\n  [val in myBigArray] val = 1 / val; // Parallel operation\n\n// Atomic variables, common to many languages, are ones whose operations\n// occur uninterrupted. Multiple threads can therefore modify atomic\n// variables and can know that their values are safe.\n// Chapel atomic variables can be of type bool, int,\n// uint, and real.\n  var uranium: atomic int;\n  uranium.write(238);      // atomically write a variable\n  writeln(uranium.read()); // atomically read a variable\n\n// Atomic operations are described as functions, so you can define your own.\n  uranium.sub(3); // atomically subtract a variable\n  writeln(uranium.read());\n\n  var replaceWith = 239;\n  var was = uranium.exchange(replaceWith);\n  writeln(\"uranium was \", was, \" but is now \", replaceWith);\n\n  var isEqualTo = 235;\n  if uranium.compareExchange(isEqualTo, replaceWith) {\n    writeln(\"uranium was equal to \", isEqualTo,\n             \" so replaced value with \", replaceWith);\n  } else {\n    writeln(\"uranium was not equal to \", isEqualTo,\n             \" so value stays the same...  whatever it was\");\n  }\n\n  sync {\n    begin { // Reader task\n      writeln(\"Reader: waiting for uranium to be \", isEqualTo);\n      uranium.waitFor(isEqualTo);\n      writeln(\"Reader: uranium was set (by someone) to \", isEqualTo);\n    }\n\n    begin { // Writer task\n      writeln(\"Writer: will set uranium to the value \", isEqualTo, \" in...\");\n      countdown(3);\n      uranium.write(isEqualTo);\n    }\n  }\n\n// sync variables have two states: empty and full.\n// If you read an empty variable or write a full variable, you are waited\n// until the variable is full or empty again.\n  var someSyncVar$: sync int; // varName$ is a convention not a law.\n  sync {\n    begin { // Reader task\n      writeln(\"Reader: waiting to read.\");\n      var read_sync = someSyncVar$;\n      writeln(\"Reader: value is \", read_sync);\n    }\n\n    begin { // Writer task\n      writeln(\"Writer: will write in...\");\n      countdown(3);\n      someSyncVar$ = 123;\n    }\n  }\n\n// single vars can only be written once. A read on an unwritten single\n// results in a wait, but when the variable has a value it can be read\n// indefinitely.\n  var someSingleVar$: single int; // varName$ is a convention not a law.\n  sync {\n    begin { // Reader task\n      writeln(\"Reader: waiting to read.\");\n      for i in 1..5 {\n        var read_single = someSingleVar$;\n        writeln(\"Reader: iteration \", i,\", and the value is \", read_single);\n      }\n    }\n\n    begin { // Writer task\n      writeln(\"Writer: will write in...\");\n      countdown(3);\n      someSingleVar$ = 5; // first and only write ever.\n    }\n  }\n\n// Here's an example using atomics and a sync variable to create a\n// count-down mutex (also known as a multiplexer).\n  var count: atomic int; // our counter\n  var lock$: sync bool;   // the mutex lock\n\n  count.write(2);       // Only let two tasks in at a time.\n  lock$.writeXF(true);  // Set lock$ to full (unlocked)\n  // Note: The value doesn't actually matter, just the state\n  // (full:unlocked / empty:locked)\n  // Also, writeXF() fills (F) the sync var regardless of its state (X)\n\n  coforall task in 1..#5 { // Generate tasks\n    // Create a barrier\n    do {\n      lock$;                 // Read lock$ (wait)\n    } while (count.read() < 1); // Keep waiting until a spot opens up\n\n    count.sub(1);          // decrement the counter\n    lock$.writeXF(true); // Set lock$ to full (signal)\n\n    // Actual 'work'\n    writeln(\"Task #\", task, \" doing work.\");\n    sleep(2);\n\n    count.add(1);        // Increment the counter\n    lock$.writeXF(true); // Set lock$ to full (signal)\n  }\n\n// We can define the operations + * & | ^ && || min max minloc maxloc\n// over an entire array using scans and reductions.\n// Reductions apply the operation over the entire array and\n// result in a scalar value.\n  var listOfValues: [1..10] int = [15,57,354,36,45,15,456,8,678,2];\n  var sumOfValues = + reduce listOfValues;\n  var maxValue = max reduce listOfValues; // 'max' give just max value\n\n// maxloc gives max value and index of the max value.\n// Note: We have to zip the array and domain together with the zip iterator.\n  var (theMaxValue, idxOfMax) = maxloc reduce zip(listOfValues,\n                                                  listOfValues.domain);\n\n  writeln((sumOfValues, maxValue, idxOfMax, listOfValues[idxOfMax]));\n\n// Scans apply the operation incrementally and return an array with the\n// values of the operation at that index as it progressed through the\n// array from array.domain.low to array.domain.high.\n  var runningSumOfValues = + scan listOfValues;\n  var maxScan = max scan listOfValues;\n  writeln(runningSumOfValues);\n  writeln(maxScan);\n} // end main()\n```\n\nWho is this tutorial for?\n-------------------------\n\nThis tutorial is for people who want to learn the ropes of chapel without\nhaving to hear about what fiber mixture the ropes are, or how they were\nbraided, or how the braid configurations differ between one another. It won't\nteach you how to develop amazingly performant code, and it's not exhaustive.\nRefer to the [language specification](https://chapel-lang.org/docs/latest/language/spec.html) and\nthe [module documentation](https://chapel-lang.org/docs/latest/) for more\ndetails.\n\nOccasionally check back here and on the [Chapel site](https://chapel-lang.org)\nto see if more topics have been added or more tutorials created.\n\n### What this tutorial is lacking:\n\n * Exposition of the [standard modules](https://chapel-lang.org/docs/latest/modules/standard.html)\n * Multiple Locales (distributed memory system)\n * Records\n * Parallel iterators\n\nYour input, questions, and discoveries are important to the developers!\n-----------------------------------------------------------------------\n\nThe Chapel language is still in active development, so there are\noccasional hiccups with performance and language features. The more information\nyou give the Chapel development team about issues you encounter or features you\nwould like to see, the better the language becomes.\nThere are several ways to interact with the developers:\n+ [Gitter chat](https://gitter.im/chapel-lang/chapel)\n+ [sourceforge email lists](https://sourceforge.net/p/chapel/mailman)\n\nIf you're really interested in the development of the compiler or contributing\nto the project, [check out the master GitHub repository](https://github.com/chapel-lang/chapel).\nIt is under the [Apache 2.0 License](http://www.apache.org/licenses/LICENSE-2.0).\n\nInstalling the Compiler\n-----------------------\n\n[The Official Chapel documentation details how to download and compile the Chapel compiler.](https://chapel-lang.org/docs/usingchapel/QUICKSTART.html)\n\nChapel can be built and installed on your average 'nix machine (and cygwin).\n[Download the latest release version](https://github.com/chapel-lang/chapel/releases/)\nand it's as easy as\n\n 1. `tar -xvf chapel-<VERSION>.tar.gz`\n 2. `cd chapel-<VERSION>`\n 3. `source util/setchplenv.bash # or .sh or .csh or .fish`\n 4. `make`\n 5. `make check # optional`\n\nYou will need to `source util/setchplenv.EXT` from within the Chapel directory\n(`$CHPL_HOME`) every time your terminal starts so it's suggested that you drop\nthat command in a script that will get executed on startup (like .bashrc).\n\nChapel is easily installed with Brew for OS X\n\n 1. `brew update`\n 2. `brew install chapel`\n\nCompiling Code\n--------------\n\nBuilds like other compilers:\n\n`chpl myFile.chpl -o myExe`\n\nNotable arguments:\n\n * `--fast`: enables a number of optimizations and disables array bounds\n   checks. Should only enable when application is stable.\n * `--set <Symbol Name>=<Value>`: set config param `<Symbol Name>` to `<Value>`\n   at compile-time.\n * `--main-module <Module Name>`: use the main() procedure found in the module\n   `<Module Name>` as the executable's main.\n * `--module-dir <Directory>`: includes `<Directory>` in the module search path."
