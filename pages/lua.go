
package pages

const Lua = "```lua\n-- Two dashes start a one-line comment.\n\n--[[\n     Adding two ['s and ]'s makes it a\n     multi-line comment.\n--]]\n\n----------------------------------------------------\n-- 1. Variables and flow control.\n----------------------------------------------------\n\nnum = 42  -- All numbers are doubles.\n-- Don't freak out, 64-bit doubles have 52 bits for\n-- storing exact int values; machine precision is\n-- not a problem for ints that need < 52 bits.\n\ns = 'walternate'  -- Immutable strings like Python.\nt = \"double-quotes are also fine\"\nu = [[ Double brackets\n       start and end\n       multi-line strings.]]\nt = nil  -- Undefines t; Lua has garbage collection.\n\n-- Blocks are denoted with keywords like do/end:\nwhile num < 50 do\n  num = num + 1  -- No ++ or += type operators.\nend\n\n-- If clauses:\nif num > 40 then\n  print('over 40')\nelseif s ~= 'walternate' then  -- ~= is not equals.\n  -- Equality check is == like Python; ok for strs.\n  io.write('not over 40\\n')  -- Defaults to stdout.\nelse\n  -- Variables are global by default.\n  thisIsGlobal = 5  -- Camel case is common.\n\n  -- How to make a variable local:\n  local line = io.read()  -- Reads next stdin line.\n\n  -- String concatenation uses the .. operator:\n  print('Winter is coming, ' .. line)\nend\n\n-- Undefined variables return nil.\n-- This is not an error:\nfoo = anUnknownVariable  -- Now foo = nil.\n\naBoolValue = false\n\n-- Only nil and false are falsy; 0 and '' are true!\nif not aBoolValue then print('twas false') end\n\n-- 'or' and 'and' are short-circuited.\n-- This is similar to the a?b:c operator in C/js:\nans = aBoolValue and 'yes' or 'no'  --> 'no'\n\nkarlSum = 0\nfor i = 1, 100 do  -- The range includes both ends.\n  karlSum = karlSum + i\nend\n\n-- Use \"100, 1, -1\" as the range to count down:\nfredSum = 0\nfor j = 100, 1, -1 do fredSum = fredSum + j end\n\n-- In general, the range is begin, end[, step].\n\n-- Another loop construct:\nrepeat\n  print('the way of the future')\n  num = num - 1\nuntil num == 0\n\n\n----------------------------------------------------\n-- 2. Functions.\n----------------------------------------------------\n\nfunction fib(n)\n  if n < 2 then return 1 end\n  return fib(n - 2) + fib(n - 1)\nend\n\n-- Closures and anonymous functions are ok:\nfunction adder(x)\n  -- The returned function is created when adder is\n  -- called, and remembers the value of x:\n  return function (y) return x + y end\nend\na1 = adder(9)\na2 = adder(36)\nprint(a1(16))  --> 25\nprint(a2(64))  --> 100\n\n-- Returns, func calls, and assignments all work\n-- with lists that may be mismatched in length.\n-- Unmatched receivers are nil;\n-- unmatched senders are discarded.\n\nx, y, z = 1, 2, 3, 4\n-- Now x = 1, y = 2, z = 3, and 4 is thrown away.\n\nfunction bar(a, b, c)\n  print(a, b, c)\n  return 4, 8, 15, 16, 23, 42\nend\n\nx, y = bar('zaphod')  --> prints \"zaphod  nil nil\"\n-- Now x = 4, y = 8, values 15...42 are discarded.\n\n-- Functions are first-class, may be local/global.\n-- These are the same:\nfunction f(x) return x * x end\nf = function (x) return x * x end\n\n-- And so are these:\nlocal function g(x) return math.sin(x) end\nlocal g; g  = function (x) return math.sin(x) end\n-- the 'local g' decl makes g-self-references ok.\n\n-- Trig funcs work in radians, by the way.\n\n-- Calls with one string param don't need parens:\nprint 'hello'  -- Works fine.\n\n\n----------------------------------------------------\n-- 3. Tables.\n----------------------------------------------------\n\n-- Tables = Lua's only compound data structure;\n--          they are associative arrays.\n-- Similar to php arrays or js objects, they are\n-- hash-lookup dicts that can also be used as lists.\n\n-- Using tables as dictionaries / maps:\n\n-- Dict literals have string keys by default:\nt = {key1 = 'value1', key2 = false}\n\n-- String keys can use js-like dot notation:\nprint(t.key1)  -- Prints 'value1'.\nt.newKey = {}  -- Adds a new key/value pair.\nt.key2 = nil   -- Removes key2 from the table.\n\n-- Literal notation for any (non-nil) value as key:\nu = {['@!#'] = 'qbert', [{}] = 1729, [6.28] = 'tau'}\nprint(u[6.28])  -- prints \"tau\"\n\n-- Key matching is basically by value for numbers\n-- and strings, but by identity for tables.\na = u['@!#']  -- Now a = 'qbert'.\nb = u[{}]     -- We might expect 1729, but it's nil:\n-- b = nil since the lookup fails. It fails\n-- because the key we used is not the same object\n-- as the one used to store the original value. So\n-- strings & numbers are more portable keys.\n\n-- A one-table-param function call needs no parens:\nfunction h(x) print(x.key1) end\nh{key1 = 'Sonmi~451'}  -- Prints 'Sonmi~451'.\n\nfor key, val in pairs(u) do  -- Table iteration.\n  print(key, val)\nend\n\n-- _G is a special table of all globals.\nprint(_G['_G'] == _G)  -- Prints 'true'.\n\n-- Using tables as lists / arrays:\n\n-- List literals implicitly set up int keys:\nv = {'value1', 'value2', 1.21, 'gigawatts'}\nfor i = 1, #v do  -- #v is the size of v for lists.\n  print(v[i])  -- Indices start at 1 !! SO CRAZY!\nend\n-- A 'list' is not a real type. v is just a table\n-- with consecutive integer keys, treated as a list.\n\n----------------------------------------------------\n-- 3.1 Metatables and metamethods.\n----------------------------------------------------\n\n-- A table can have a metatable that gives the table\n-- operator-overloadish behavior. Later we'll see\n-- how metatables support js-prototypey behavior.\n\nf1 = {a = 1, b = 2}  -- Represents the fraction a/b.\nf2 = {a = 2, b = 3}\n\n-- This would fail:\n-- s = f1 + f2\n\nmetafraction = {}\nfunction metafraction.__add(f1, f2)\n  sum = {}\n  sum.b = f1.b * f2.b\n  sum.a = f1.a * f2.b + f2.a * f1.b\n  return sum\nend\n\nsetmetatable(f1, metafraction)\nsetmetatable(f2, metafraction)\n\ns = f1 + f2  -- call __add(f1, f2) on f1's metatable\n\n-- f1, f2 have no key for their metatable, unlike\n-- prototypes in js, so you must retrieve it as in\n-- getmetatable(f1). The metatable is a normal table\n-- with keys that Lua knows about, like __add.\n\n-- But the next line fails since s has no metatable:\n-- t = s + s\n-- Class-like patterns given below would fix this.\n\n-- An __index on a metatable overloads dot lookups:\ndefaultFavs = {animal = 'gru', food = 'donuts'}\nmyFavs = {food = 'pizza'}\nsetmetatable(myFavs, {__index = defaultFavs})\neatenBy = myFavs.animal  -- works! thanks, metatable\n\n-- Direct table lookups that fail will retry using\n-- the metatable's __index value, and this recurses.\n\n-- An __index value can also be a function(tbl, key)\n-- for more customized lookups.\n\n-- Values of __index,add, .. are called metamethods.\n-- Full list. Here a is a table with the metamethod.\n\n-- __add(a, b)                     for a + b\n-- __sub(a, b)                     for a - b\n-- __mul(a, b)                     for a * b\n-- __div(a, b)                     for a / b\n-- __mod(a, b)                     for a % b\n-- __pow(a, b)                     for a ^ b\n-- __unm(a)                        for -a\n-- __concat(a, b)                  for a .. b\n-- __len(a)                        for #a\n-- __eq(a, b)                      for a == b\n-- __lt(a, b)                      for a < b\n-- __le(a, b)                      for a <= b\n-- __index(a, b)  <fn or a table>  for a.b\n-- __newindex(a, b, c)             for a.b = c\n-- __call(a, ...)                  for a(...)\n\n----------------------------------------------------\n-- 3.2 Class-like tables and inheritance.\n----------------------------------------------------\n\n-- Classes aren't built in; there are different ways\n-- to make them using tables and metatables.\n\n-- Explanation for this example is below it.\n\nDog = {}                                   -- 1.\n\nfunction Dog:new()                         -- 2.\n  newObj = {sound = 'woof'}                -- 3.\n  self.__index = self                      -- 4.\n  return setmetatable(newObj, self)        -- 5.\nend\n\nfunction Dog:makeSound()                   -- 6.\n  print('I say ' .. self.sound)\nend\n\nmrDog = Dog:new()                          -- 7.\nmrDog:makeSound()  -- 'I say woof'         -- 8.\n\n-- 1. Dog acts like a class; it's really a table.\n-- 2. function tablename:fn(...) is the same as\n--    function tablename.fn(self, ...)\n--    The : just adds a first arg called self.\n--    Read 7 & 8 below for how self gets its value.\n-- 3. newObj will be an instance of class Dog.\n-- 4. self = the class being instantiated. Often\n--    self = Dog, but inheritance can change it.\n--    newObj gets self's functions when we set both\n--    newObj's metatable and self's __index to self.\n-- 5. Reminder: setmetatable returns its first arg.\n-- 6. The : works as in 2, but this time we expect\n--    self to be an instance instead of a class.\n-- 7. Same as Dog.new(Dog), so self = Dog in new().\n-- 8. Same as mrDog.makeSound(mrDog); self = mrDog.\n\n----------------------------------------------------\n\n-- Inheritance example:\n\nLoudDog = Dog:new()                           -- 1.\n\nfunction LoudDog:makeSound()\n  s = self.sound .. ' '                       -- 2.\n  print(s .. s .. s)\nend\n\nseymour = LoudDog:new()                       -- 3.\nseymour:makeSound()  -- 'woof woof woof'      -- 4.\n\n-- 1. LoudDog gets Dog's methods and variables.\n-- 2. self has a 'sound' key from new(), see 3.\n-- 3. Same as LoudDog.new(LoudDog), and converted to\n--    Dog.new(LoudDog) as LoudDog has no 'new' key,\n--    but does have __index = Dog on its metatable.\n--    Result: seymour's metatable is LoudDog, and\n--    LoudDog.__index = LoudDog. So seymour.key will\n--    = seymour.key, LoudDog.key, Dog.key, whichever\n--    table is the first with the given key.\n-- 4. The 'makeSound' key is found in LoudDog; this\n--    is the same as LoudDog.makeSound(seymour).\n\n-- If needed, a subclass's new() is like the base's:\nfunction LoudDog:new()\n  newObj = {}\n  -- set up newObj\n  self.__index = self\n  return setmetatable(newObj, self)\nend\n\n----------------------------------------------------\n-- 4. Modules.\n----------------------------------------------------\n\n\n--[[ I'm commenting out this section so the rest of\n--   this script remains runnable.\n```\n\n```lua\n-- Suppose the file mod.lua looks like this:\nlocal M = {}\n\nlocal function sayMyName()\n  print('Hrunkner')\nend\n\nfunction M.sayHello()\n  print('Why hello there')\n  sayMyName()\nend\n\nreturn M\n\n-- Another file can use mod.lua's functionality:\nlocal mod = require('mod')  -- Run the file mod.lua.\n\n-- require is the standard way to include modules.\n-- require acts like:     (if not cached; see below)\nlocal mod = (function ()\n  <contents of mod.lua>\nend)()\n-- It's like mod.lua is a function body, so that\n-- locals inside mod.lua are invisible outside it.\n\n-- This works because mod here = M in mod.lua:\nmod.sayHello()  -- Says hello to Hrunkner.\n\n-- This is wrong; sayMyName only exists in mod.lua:\nmod.sayMyName()  -- error\n\n-- require's return values are cached so a file is\n-- run at most once, even when require'd many times.\n\n-- Suppose mod2.lua contains \"print('Hi!')\".\nlocal a = require('mod2')  -- Prints Hi!\nlocal b = require('mod2')  -- Doesn't print; a=b.\n\n-- dofile is like require without caching:\ndofile('mod2.lua')  --> Hi!\ndofile('mod2.lua')  --> Hi! (runs it again)\n\n-- loadfile loads a lua file but doesn't run it yet.\nf = loadfile('mod2.lua')  -- Call f() to run it.\n\n-- loadstring is loadfile for strings.\ng = loadstring('print(343)')  -- Returns a function.\ng()  -- Prints out 343; nothing printed before now.\n\n--]]\n\n```\n## References\n\nI was excited to learn Lua so I could make games\nwith the <a href=\"http://love2d.org/\">Love 2D game engine</a>. That's the why.\n\nI started with <a href=\"https://ebens.me/post/lua-for-programmers-part-1/\">BlackBulletIV's Lua for programmers</a>.\nNext I read the official <a href=\"http://www.lua.org/pil/contents.html\">Programming in Lua</a> book.\nThat's the how.\n\nIt might be helpful to check out the <a href=\"http://lua-users.org/files/wiki_insecure/users/thomasl/luarefv51.pdf\">Lua short\nreference</a> on lua-users.org.\n\nThe main topics not covered are standard libraries:\n\n* <a href=\"http://lua-users.org/wiki/StringLibraryTutorial\">string library</a>\n* <a href=\"http://lua-users.org/wiki/TableLibraryTutorial\">table library</a>\n* <a href=\"http://lua-users.org/wiki/MathLibraryTutorial\">math library</a>\n* <a href=\"http://lua-users.org/wiki/IoLibraryTutorial\">io library</a>\n* <a href=\"http://lua-users.org/wiki/OsLibraryTutorial\">os library</a>\n\nBy the way, the entire file is valid Lua; save it\nas learn.lua and run it with \"lua learn.lua\" !\n\nThis was first written for tylerneylon.com, and is\nalso available as a <a href=\"https://gist.github.com/tylerneylon/5853042\">github gist</a>. Have fun with Lua!"
