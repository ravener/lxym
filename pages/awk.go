
package pages

const Awk = "AWK is a standard tool on every POSIX-compliant UNIX system. It's like\nflex/lex, from the command-line, perfect for text-processing tasks and\nother scripting needs. It has a C-like syntax, but without mandatory\nsemicolons (although, you should use them anyway, because they are required\nwhen you're writing one-liners, something AWK excels at), manual memory\nmanagement, or static typing. It excels at text processing. You can call to\nit from a shell script, or you can use it as a stand-alone scripting language.\n\nWhy use AWK instead of Perl? Readability. AWK is easier to read\nthan Perl. For simple text-processing scripts, particularly ones that read\nfiles line by line and split on delimiters, AWK is probably the right tool for\nthe job.\n\n```awk\n#!/usr/bin/awk -f\n\n# Comments are like this\n\n\n# AWK programs consist of a collection of patterns and actions.\npattern1 { action; } # just like lex\npattern2 { action; }\n\n# There is an implied loop and AWK automatically reads and parses each\n# record of each file supplied. Each record is split by the FS delimiter,\n# which defaults to white-space (multiple spaces,tabs count as one)\n# You can assign FS either on the command line (-F C) or in your BEGIN\n# pattern\n\n# One of the special patterns is BEGIN. The BEGIN pattern is true\n# BEFORE any of the files are read. The END pattern is true after\n# an End-of-file from the last file (or standard-in if no files specified)\n# There is also an output field separator (OFS) that you can assign, which\n# defaults to a single space\n\nBEGIN {\n\n    # BEGIN will run at the beginning of the program. It's where you put all\n    # the preliminary set-up code, before you process any text files. If you\n    # have no text files, then think of BEGIN as the main entry point.\n\n    # Variables are global. Just set them or use them, no need to declare..\n    count = 0;\n\n    # Operators just like in C and friends\n    a = count + 1;\n    b = count - 1;\n    c = count * 1;\n    d = count / 1; # integer division\n    e = count % 1; # modulus\n    f = count ^ 1; # exponentiation\n\n    a += 1;\n    b -= 1;\n    c *= 1;\n    d /= 1;\n    e %= 1;\n    f ^= 1;\n\n    # Incrementing and decrementing by one\n    a++;\n    b--;\n\n    # As a prefix operator, it returns the incremented value\n    ++a;\n    --b;\n\n    # Notice, also, no punctuation such as semicolons to terminate statements\n\n    # Control statements\n    if (count == 0)\n        print \"Starting with count of 0\";\n    else\n        print \"Huh?\";\n\n    # Or you could use the ternary operator\n    print (count == 0) ? \"Starting with count of 0\" : \"Huh?\";\n\n    # Blocks consisting of multiple lines use braces\n    while (a < 10) {\n        print \"String concatenation is done\" \" with a series\" \" of\"\n            \" space-separated strings\";\n        print a;\n\n        a++;\n    }\n\n    for (i = 0; i < 10; i++)\n        print \"Good ol' for loop\";\n\n    # As for comparisons, they're the standards:\n    # a < b   # Less than\n    # a <= b  # Less than or equal\n    # a != b  # Not equal\n    # a == b  # Equal\n    # a > b   # Greater than\n    # a >= b  # Greater than or equal\n\n    # Logical operators as well\n    # a && b  # AND\n    # a || b  # OR\n\n    # In addition, there's the super useful regular expression match\n    if (\"foo\" ~ \"^fo+$\")\n        print \"Fooey!\";\n    if (\"boo\" !~ \"^fo+$\")\n        print \"Boo!\";\n\n    # Arrays\n    arr[0] = \"foo\";\n    arr[1] = \"bar\";\n    \n    # You can also initialize an array with the built-in function split()\n    \n    n = split(\"foo:bar:baz\", arr, \":\");\n   \n    # You also have associative arrays (actually, they're all associative arrays)\n    assoc[\"foo\"] = \"bar\";\n    assoc[\"bar\"] = \"baz\";\n\n    # And multi-dimensional arrays, with some limitations I won't mention here\n    multidim[0,0] = \"foo\";\n    multidim[0,1] = \"bar\";\n    multidim[1,0] = \"baz\";\n    multidim[1,1] = \"boo\";\n\n    # You can test for array membership\n    if (\"foo\" in assoc)\n        print \"Fooey!\";\n\n    # You can also use the 'in' operator to traverse the keys of an array\n    for (key in assoc)\n        print assoc[key];\n\n    # The command line is in a special array called ARGV\n    for (argnum in ARGV)\n        print ARGV[argnum];\n\n    # You can remove elements of an array\n    # This is particularly useful to prevent AWK from assuming the arguments\n    # are files for it to process\n    delete ARGV[1];\n\n    # The number of command line arguments is in a variable called ARGC\n    print ARGC;\n\n    # AWK has several built-in functions. They fall into three categories. I'll\n    # demonstrate each of them in their own functions, defined later.\n\n    return_value = arithmetic_functions(a, b, c);\n    string_functions();\n    io_functions();\n}\n\n# Here's how you define a function\nfunction arithmetic_functions(a, b, c,     d) {\n\n    # Probably the most annoying part of AWK is that there are no local\n    # variables. Everything is global. For short scripts, this is fine, even\n    # useful, but for longer scripts, this can be a problem.\n\n    # There is a work-around (ahem, hack). Function arguments are local to the\n    # function, and AWK allows you to define more function arguments than it\n    # needs. So just stick local variable in the function declaration, like I\n    # did above. As a convention, stick in some extra whitespace to distinguish\n    # between actual function parameters and local variables. In this example,\n    # a, b, and c are actual parameters, while d is merely a local variable.\n\n    # Now, to demonstrate the arithmetic functions\n\n    # Most AWK implementations have some standard trig functions\n    localvar = sin(a);\n    localvar = cos(a);\n    localvar = atan2(b, a); # arc tangent of b / a\n\n    # And logarithmic stuff\n    localvar = exp(a);\n    localvar = log(a);\n\n    # Square root\n    localvar = sqrt(a);\n\n    # Truncate floating point to integer\n    localvar = int(5.34); # localvar => 5\n\n    # Random numbers\n    srand(); # Supply a seed as an argument. By default, it uses the time of day\n    localvar = rand(); # Random number between 0 and 1.\n\n    # Here's how to return a value\n    return localvar;\n}\n\nfunction string_functions(    localvar, arr) {\n\n    # AWK, being a string-processing language, has several string-related\n    # functions, many of which rely heavily on regular expressions.\n\n    # Search and replace, first instance (sub) or all instances (gsub)\n    # Both return number of matches replaced\n    localvar = \"fooooobar\";\n    sub(\"fo+\", \"Meet me at the \", localvar); # localvar => \"Meet me at the bar\"\n    gsub(\"e+\", \".\", localvar); # localvar => \"m..t m. at th. bar\"\n\n    # Search for a string that matches a regular expression\n    # index() does the same thing, but doesn't allow a regular expression\n    match(localvar, \"t\"); # => 4, since the 't' is the fourth character\n\n    # Split on a delimiter\n    n = split(\"foo-bar-baz\", arr, \"-\"); # a[1] = \"foo\"; a[2] = \"bar\"; a[3] = \"baz\"; n = 3\n\n    # Other useful stuff\n    sprintf(\"%s %d %d %d\", \"Testing\", 1, 2, 3); # => \"Testing 1 2 3\"\n    substr(\"foobar\", 2, 3); # => \"oob\"\n    substr(\"foobar\", 4); # => \"bar\"\n    length(\"foo\"); # => 3\n    tolower(\"FOO\"); # => \"foo\"\n    toupper(\"foo\"); # => \"FOO\"\n}\n\nfunction io_functions(    localvar) {\n\n    # You've already seen print\n    print \"Hello world\";\n\n    # There's also printf\n    printf(\"%s %d %d %d\\n\", \"Testing\", 1, 2, 3);\n\n    # AWK doesn't have file handles, per se. It will automatically open a file\n    # handle for you when you use something that needs one. The string you used\n    # for this can be treated as a file handle, for purposes of I/O. This makes\n    # it feel sort of like shell scripting, but to get the same output, the string\n    # must match exactly, so use a variable:\n    \n    outfile = \"/tmp/foobar.txt\";\n\n    print \"foobar\" > outfile;\n\n    # Now the string outfile is a file handle. You can close it:\n    close(outfile);\n\n    # Here's how you run something in the shell\n    system(\"echo foobar\"); # => prints foobar\n\n    # Reads a line from standard input and stores in localvar\n    getline localvar;\n\n    # Reads a line from a pipe (again, use a string so you close it properly)\n    cmd = \"echo foobar\";\n    cmd | getline localvar; # localvar => \"foobar\"\n    close(cmd);\n\n    # Reads a line from a file and stores in localvar\n    infile = \"/tmp/foobar.txt\";\n    getline localvar < infile; \n    close(infile);\n}\n\n# As I said at the beginning, AWK programs consist of a collection of patterns\n# and actions. You've already seen the BEGIN pattern. Other\n# patterns are used only if you're processing lines from files or standard\n# input.\n#\n# When you pass arguments to AWK, they are treated as file names to process.\n# It will process them all, in order. Think of it like an implicit for loop,\n# iterating over the lines in these files. these patterns and actions are like\n# switch statements inside the loop. \n\n/^fo+bar$/ {\n    \n    # This action will execute for every line that matches the regular\n    # expression, /^fo+bar$/, and will be skipped for any line that fails to\n    # match it. Let's just print the line:\n\n    print;\n\n    # Whoa, no argument! That's because print has a default argument: $0.\n    # $0 is the name of the current line being processed. It is created\n    # automatically for you.\n\n    # You can probably guess there are other $ variables. Every line is\n    # implicitly split before every action is called, much like the shell\n    # does. And, like the shell, each field can be access with a dollar sign\n\n    # This will print the second and fourth fields in the line\n    print $2, $4;\n\n    # AWK automatically defines many other variables to help you inspect and\n    # process each line. The most important one is NF\n\n    # Prints the number of fields on this line\n    print NF;\n\n    # Print the last field on this line\n    print $NF;\n}\n\n# Every pattern is actually a true/false test. The regular expression in the\n# last pattern is also a true/false test, but part of it was hidden. If you\n# don't give it a string to test, it will assume $0, the line that it's\n# currently processing. Thus, the complete version of it is this:\n\n$0 ~ /^fo+bar$/ {\n    print \"Equivalent to the last pattern\";\n}\n\na > 0 {\n    # This will execute once for each line, as long as a is positive\n}\n\n# You get the idea. Processing text files, reading in a line at a time, and\n# doing something with it, particularly splitting on a delimiter, is so common\n# in UNIX that AWK is a scripting language that does all of it for you, without\n# you needing to ask. All you have to do is write the patterns and actions\n# based on what you expect of the input, and what you want to do with it.\n\n# Here's a quick example of a simple script, the sort of thing AWK is perfect\n# for. It will read a name from standard input and then will print the average\n# age of everyone with that first name. Let's say you supply as an argument the\n# name of a this data file:\n#\n# Bob Jones 32\n# Jane Doe 22\n# Steve Stevens 83\n# Bob Smith 29\n# Bob Barker 72\n#\n# Here's the script:\n\nBEGIN {\n\n    # First, ask the user for the name\n    print \"What name would you like the average age for?\";\n\n    # Get a line from standard input, not from files on the command line\n    getline name < \"/dev/stdin\";\n}\n\n# Now, match every line whose first field is the given name\n$1 == name {\n\n    # Inside here, we have access to a number of useful variables, already\n    # pre-loaded for us:\n    # $0 is the entire line\n    # $3 is the third field, the age, which is what we're interested in here\n    # NF is the number of fields, which should be 3\n    # NR is the number of records (lines) seen so far\n    # FILENAME is the name of the file being processed\n    # FS is the field separator being used, which is \" \" here\n    # ...etc. There are plenty more, documented in the man page.\n\n    # Keep track of a running total and how many lines matched\n    sum += $3;\n    nlines++;\n}\n\n# Another special pattern is called END. It will run after processing all the\n# text files. Unlike BEGIN, it will only run if you've given it input to\n# process. It will run after all the files have been read and processed\n# according to the rules and actions you've provided. The purpose of it is\n# usually to output some kind of final report, or do something with the\n# aggregate of the data you've accumulated over the course of the script.\n\nEND {\n    if (nlines)\n        print \"The average age for \" name \" is \" sum / nlines;\n}\n\n```\nFurther Reading:\n\n* [Awk tutorial](http://www.grymoire.com/Unix/Awk.html)\n* [Awk man page](https://linux.die.net/man/1/awk)\n* [The GNU Awk User's Guide](https://www.gnu.org/software/gawk/manual/gawk.html) GNU Awk is found on most Linux systems.\n* [AWK one-liner collection](http://tuxgraphics.org/~guido/scripts/awk-one-liner.html)\n* [Awk alpinelinux wiki](https://wiki.alpinelinux.org/wiki/Awk) a technical summary and list of \"gotchas\" (places where different implementations may behave in different or unexpected ways). \n* [basic libraries for awk](https://github.com/dubiousjim/awkenough)"
