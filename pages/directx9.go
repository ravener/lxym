
package pages

const Directx9 = "**Microsoft DirectX** is a collection of application programming interfaces (APIs) for handling tasks related to\nmultimedia, especially game programming and video, on Microsoft platforms. Originally, the names of these APIs\nall began with Direct, such as Direct3D, DirectDraw, DirectMusic, DirectPlay, DirectSound, and so forth. [...]\nDirect3D (the 3D graphics API within DirectX) is widely used in the development of video games for Microsoft\nWindows and the Xbox line of consoles.<sup>[1]</sup>\n\nIn this tutorial we will be focusing on DirectX 9, which is not as low-level as it's sucessors, which are aimed at programmers very familiar with how graphics hardware works. It makes a great starting point for learning Direct3D. In this tutorial I will be using the Win32-API for window handling and the DirectX 2010 SDK.\n\n## Window creation\n\n```cpp\n#include <Windows.h>\n\nbool _running{ false };\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {\n    // Handle incoming message.\n    switch (msg) {\n        // Set running to false if the user tries to close the window.\n        case WM_DESTROY:\n            _running = false;\n            PostQuitMessage(0);\n            break;\n    }\n    // Return the handled event.\n    return DefWindowProc(hWnd, msg, wParam, lParam);\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\n                   LPSTR lpCmdLine, int nCmdShow) {\n    // Set window properties we want to use.\n    WNDCLASSEX wndEx{ };\n    wndEx.cbSize        = sizeof(WNDCLASSEX);        // structure size\n    wndEx.style         = CS_VREDRAW | CS_HREDRAW;   // class styles\n    wndEx.lpfnWndProc   = WndProc;                   // window procedure\n    wndEx.cbClsExtra    = 0;                         // extra memory (struct)\n    wndEx.cbWndExtra    = 0;                         // extra memory (window)\n    wndEx.hInstance     = hInstance;                 // module instance\n    wndEx.hIcon         = LoadIcon(nullptr, IDI_APPLICATION); // icon\n    wndEx.hCursor       = LoadCursor(nullptr, IDC_ARROW);     // cursor\n    wndEx.hbrBackground = (HBRUSH) COLOR_WINDOW;     // background color\n    wndEx.lpszMenuName  = nullptr;                   // menu name\n    wndEx.lpszClassName = \"DirectXClass\";            // register class name\n    wndEx.hIconSm       = nullptr;                   // small icon (taskbar)\n    // Register created class for window creation.\n    RegisterClassEx(&wndEx);\n    // Create a new window handle.\n    HWND hWnd{ nullptr };\n    // Create a new window handle using the registered class.\n    hWnd = CreateWindow(\"DirectXClass\",      // registered class\n                        \"directx window\",    // window title\n                        WS_OVERLAPPEDWINDOW, // window style\n                        50, 50,              // x, y (position)\n                        1024, 768,           // width, height (size)\n                        nullptr,             // parent window\n                        nullptr,             // menu\n                        hInstance,           // module instance\n                        nullptr);            // struct for infos\n    // Check if a window handle has been created.\n    if (!hWnd)\n        return -1;   \n    // Show and update the new window.\n    ShowWindow(hWnd, nCmdShow);\n    UpdateWindow(hWnd);\n    // Start the game loop and send incoming messages to the window procedure.\n    _running = true;\n    MSG msg{ };\n    while (_running) {\n        while (PeekMessage(&msg, hWnd, 0, 0, PM_REMOVE)) {\n            TranslateMessage(&msg);\n            DispatchMessage(&msg);\n        }\n    }  \n    return 0;\n}\n```\n\nThis should create a window, that can the moved, resized and closed.\n\n## Direct3D initialization\n\n```cpp\n// Includes DirectX 9 structures and functions.\n// Remember to link \"d3d9.lib\" and \"d3dx9.lib\".\n// For \"d3dx9.lib\" the DirectX SDK (June 2010) is needed.\n// Don't forget to set your subsystem to Windows.\n#include <d3d9.h>\n#include <d3dx9.h>\n// Includes the ComPtr, a smart pointer automatically releasing COM objects.\n#include <wrl.h>\nusing namespace Microsoft::WRL;\n// Next we define some Direct3D9 interface structs we need.\nComPtr<IDirect3D9> _d3d{ };\nComPtr<IDirect3DDevice9> _device{ };\n```\n\nWith all interfaces declared we can now initialize Direct3D.\n\n```cpp\nbool InitD3D(HWND hWnd) {\n    // Store the size of the window rectangle.\n    RECT clientRect{ };\n    GetClientRect(hWnd, &clientRect);\n    // Initialize Direct3D\n    _d3d = Direct3DCreate9(D3D_SDK_VERSION);\n    // Get the display mode which format will be the window format.\n    D3DDISPLAYMODE displayMode{ };\n    _d3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, // use default graphics card\n                                &displayMode);      // display mode pointer\n    // Next we have to set some presentation parameters.\n    D3DPRESENT_PARAMETERS pp{ };\n    pp.BackBufferWidth = clientRect.right;    // width is window width\n    pp.BackBufferHeight = clientRect.bottom;  // height is window height\n    pp.BackBufferFormat = displayMode.Format; // use adapter format\n    pp.BackBufferCount = 1;                   // 1 back buffer (default)\n    pp.SwapEffect = D3DSWAPEFFECT_DISCARD;    // discard after presentation\n    pp.hDeviceWindow = hWnd;                  // associated window handle\n    pp.Windowed = true;                       // display in window mode\n    pp.Flags = 0;                             // no special flags\n    // Variable to store results of methods to check if everything succeded.\n    HRESULT result{ };\n    result = _d3d->CreateDevice(D3DADAPTER_DEFAULT, // use default graphics card\n                                D3DDEVTYPE_HAL,     // use hardware acceleration\n                                hWnd,               // the window handle\n                                D3DCREATE_HARDWARE_VERTEXPROCESSING,\n                                    // vertices are processed by the hardware\n                                &pp,       // the present parameters\n                                &_device); // struct to store the device\n    // Return false if the device creation failed.\n    // It is helpful to set breakpoints at the return line.\n    if (FAILED(result))\n        return false;\n    // Create a viewport which hold information about which region to draw to.\n    D3DVIEWPORT9 viewport{ };\n    viewport.X = 0;         // start at top left corner\n    viewport.Y = 0;         // ..\n    viewport.Width = clientRect.right;   // use the entire window\n    viewport.Height = clientRect.bottom; // ..\n    viewport.MinZ = 0.0f;   // minimun view distance\n    viewport.MaxZ = 100.0f; // maximum view distance\n    // Apply the created viewport.\n    result = _device->SetViewport(&viewport);\n    // Always check if something failed.\n    if (FAILED(result))\n        return false;\n    // Everything was successful, return true.\n    return true;\n}\n// ...\n// Back in our WinMain function we call our initialization function.\n// ...\n// Check if Direct3D initialization succeded, else exit the application.\nif (!InitD3D(hWnd))\n    return -1;\n        \nMSG msg{ };\nwhile (_running) {\n    while (PeekMessage(&msg, hWnd, 0, 0, PM_REMOVE)) {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n    // Clear to render target to a specified color.\n    _device->Clear(0,               // number of rects to clear\n                   nullptr,         // indicates to clear the entire window\n                   D3DCLEAR_TARGET, // clear all render targets\n                   D3DXCOLOR{ 1.0f, 0.0f, 0.0f, 1.0f }, // color (red)\n                   0.0f,            // depth buffer clear value\n                   0);              // stencil buffer clear value\n    // ...\n    // Drawing operations go here.\n    // ...\n    // Flip the front- and backbuffer.\n    _device->Present(nullptr,  // no source rectangle\n                     nullptr,  // no destination rectangle\n                     nullptr,  // don't change the current window handle\n                     nullptr); // pretty much always nullptr\n}\n// ...\n```\n\nNow the window should be displayed in a bright red color.\n\n## Vertex Buffer\n\nLet's create a vertex buffer to store the vertices for our triangle\n\n```cpp\n// At the top of the file we need to add a include.\n#include <vector>\n// First we declare a new ComPtr holding a vertex buffer.\nComPtr<IDirect3DVertexBuffer9> _vertexBuffer{ };\n// Lets define a funtion to calculate the byte size of a std::vector\ntemplate <typename T>\nunsigned int GetByteSize(const std::vector<T>& vec) {\n    return sizeof(vec[0]) * vec.size();\n}\n// Define \"flexible vertex format\" describing the content of our vertex struct.\n// Use the defined color as diffuse color.\nconst unsigned long VertexStructFVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;\n// Define a struct representing the vertex data the buffer will hold.\nstruct VStruct {\n    float x, y, z;   // store the 3D position\n    D3DCOLOR color;  // store a color\n};\n// Declare a new function to create a vertex buffer.\nIDirect3DVertexBuffer9* CreateBuffer(const std::vector<VStruct>& vertices) {\n    // Declare the buffer to be returned.\n    IDirect3DVertexBuffer9* buffer{ };\n    HRESULT result{ };\n    result = _device->CreateVertexBuffer(\n                 GetByteSize(vertices), // vector size in bytes\n                 0,                     // data usage\n                 VertexStructFVF,       // FVF of the struct\n                 D3DPOOL_DEFAULT,       // use default pool for the buffer\n                 &buffer,               // receiving buffer\n                 nullptr);              // special shared handle\n    // Check if buffer was created successfully.\n    if (FAILED(result))\n        return nullptr;\n    // Create a data pointer for copying the vertex data\n    void* data{ };\n    // Lock the buffer to get a buffer for data storage.\n    result = buffer->Lock(0,                     // byte offset\n                          GetByteSize(vertices), // size to lock\n                          &data,                 // receiving data pointer\n                          0);                    // special lock flags\n    // Check if buffer was locked successfully.\n    if (FAILED(result))\n        return nullptr;\n    // Copy the vertex data using C standard libraries memcpy.\n    memcpy(data, vertices.data(), GetByteSize(vertices));\n    buffer->Unlock();\n    // Set the FVF Direct3D uses for rendering.\n    _device->SetFVF(VertexStructFVF);\n    // If everything was successful return the filled vertex buffer.\n    return buffer;\n}\n```\n\nIn our **WinMain** we can now call the new function after the Direct3D initialization.\n\n```cpp\n// ...\nif (!InitD3D(hWnd))\n    return -1;\n// Define the vertices we need to draw a triangle.\n// Values are declared in a clockwise direction else Direct3D would cull them.\n// If you want to diable culling just call:\n// _device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);\nstd::vector<VStruct> vertices {\n    // Bottom left\n    VStruct{ -1.0f, -1.0f, 1.0f, D3DXCOLOR{ 1.0f, 0.0f, 0.0f, 1.0f } },\n    // Top left\n    VStruct{ -1.0f,  1.0f, 1.0f, D3DXCOLOR{ 0.0f, 1.0f, 0.0f, 1.0f } },\n    // Top right\n    VStruct{  1.0f,  1.0f, 1.0f, D3DXCOLOR{ 0.0f, 0.0f, 1.0f, 1.0f } }\n};\n// Try to create the vertex buffer else exit the application.\nif (!(_vertexBuffer = CreateBuffer(vertices)))\n    return -1;\n// ...\n```\n\n## Transformations\n\nBefore we can use the vertex buffer to draw our primitives, we first need to set up the matrices.\n\n```cpp\n// Lets create a new funtions for the matrix transformations.\nbool SetupTransform() {\n    // Create a view matrix that transforms world space to\n    // view space.\n    D3DXMATRIX view{ };\n    // Use a left-handed coordinate system.\n    D3DXMatrixLookAtLH(\n        &view,                              // receiving matrix\n        &D3DXVECTOR3{ 0.0f, 0.0f, -20.0f }, // \"camera\" position\n        &D3DXVECTOR3{ 0.0f, 0.0f, 0.0f },   // position where to look at\n        &D3DXVECTOR3{ 0.0f, 1.0f, 0.0f });  // positive y-axis is up\n    HRESULT result{ };\n    result = _device->SetTransform(D3DTS_VIEW, &view); // apply the view matrix\n    if (FAILED(result))\n        return false;\n    // Create a projection matrix that defines the view frustrum.\n    // It transforms the view space to projection space.\n    D3DXMATRIX projection{ };\n    // Create a perspective projection using a left-handed coordinate system.\n    D3DXMatrixPerspectiveFovLH(\n        &projection,         // receiving matrix\n        D3DXToRadian(60.0f), // field of view in radians\n        1024.0f / 768.0f,    // aspect ratio (width / height)\n        0.0f,                // minimum view distance\n        100.0f);             // maximum view distance\n    result = _device->SetTransform(D3DTS_PROJECTION, &projection);\n    if (FAILED(result))\n        return false;\n    // Disable lighting for now so we can see what we want to render.\n    result = _device->SetRenderState(D3DRS_LIGHTING, false);\n    // View and projection matrix are successfully applied, return true.\n    return true;\n}\n// ...\n// Back in the WinMain function we can now call the transformation function.\n// ...\nif (!(_vertexBuffer = CreateVertexBuffer(vertices)))\n    return -1;\n// Call the transformation setup function.\nif (!SetupTransform())\n    return -1;\n// ...\n```\n\n## Rendering\n\nNow that everything is setup we can start drawing our first 2D triangle in 3D space.\n\n```cpp\n// ...\nif (!SetupTransform())\n    return -1;\n// First we have to bind our vertex buffer to the data stream.\nHRESULT result{ };\nresult = _device->SetStreamSource(0,                   // use the default stream\n                                  _vertexBuffer.Get(), // pass the vertex buffer\n                                  0,                   // no offset\n                                  sizeof(VStruct));    // size of vertex struct\nif (FAILED(result))\n    return -1;\n\n// Create a world transformation matrix and set it to an identity matrix.\nD3DXMATRIX world{ };\nD3DXMatrixIdentity(&world);\n// Create a scalation matrix scaling our primitve by 10 in the x,\n// 10 in the y and keeping the z direction.\nD3DXMATRIX scaling{ };\nD3DXMatrixScaling(&scaling, // matrix to scale\n                  10,       // x scaling\n                  10,       // y scaling\n                  1);       // z scaling\n// Create a rotation matrix storing the current rotation of our primitive.\n// We set the current rotation matrix to an identity matrix for now.\nD3DXMATRIX rotation{ };\nD3DXMatrixIdentity(&rotation);\n// Now we multiply the scalation and rotation matrix and store the result\n// in the world matrix.\nD3DXMatrixMultiply(&world,     // destination matrix\n                   &scaling,   // matrix 1\n                   &rotation); // matrix 2\n// Apply the current world matrix.\n_device->SetTransform(D3DTS_WORLD, &world);\n// Disable culling so we can see the back of our primitive when it rotates.\n_device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);\n// The default cullmode is D3DCULL_CW.\n// After we used our the rotation matrix for multiplication we can set it\n// to rotate a small amount.\n// D3DXToRadian() function converts degree to radians.\nD3DXMatrixRotationY(&rotation,           // matrix to rotate\n                    D3DXToRadian(0.5f)); // rotation angle in radians\n\nMSG msg{ };\n    while (_running) {\n    // ...\n        _device->Clear(0, nullptr, D3DCLEAR_TARGET,\n                       D3DXCOLOR{ 0.0f, 0.0f, 0.0f, 1.0f }, 0.0f, 0);\n        // With everything setup we can call the draw function.\n        _device->BeginScene();\n        _device->DrawPrimitive(D3DPT_TRIANGLELIST, // primitive type\n                               0,                  // start vertex\n                               1);                 // primitive count\n        _device->EndScene();\n    \n        _device->Present(nullptr, nullptr, nullptr, nullptr);\n        // We can keep multiplying the world matrix with our rotation matrix\n        // to add it's rotation to the world matrix.\n        D3DXMatrixMultiply(&world, &world, &rotation);\n        // Update the modified world matrix.\n        _device->SetTransform(D3DTS_WORLD, &world);\n    // ...\n```\n\nYou should now be viewing a 10x10 units colored triangle from 20 units away, rotating around its origin.<br>\nYou can find the complete working code here: [DirectX - 1](https://pastebin.com/YkSF2rkk)\n\n## Indexing\n\nTo make it easier to draw primitives sharing a lot of vertices we can use indexing, so we only have to declare the unique vertices and put the order they are called in another array.\n\n```cpp\n// First we declare a new ComPtr for our index buffer.\nComPtr<IDirect3DIndexBuffer9> _indexBuffer{ };\n// ...\n// Declare a function creating a index buffer from a std::vector\nIDirect3DIndexBuffer9* CreateIBuffer(std::vector<unsigned int>& indices) {\n    IDirect3DIndexBuffer9* buffer{ };\n    HRESULT result{ };\n    result = _device->CreateIndexBuffer(\n                 GetByteSize(indices), // vector size in bytes\n                 0,                    // data usage \n                 D3DFMT_INDEX32,       // format is 32 bit int\n                 D3DPOOL_DEFAULT,      // default pool\n                 &buffer,              // receiving buffer\n                 nullptr);             // special shared handle\n    if (FAILED(result))\n        return nullptr;\n    // Create a data pointer pointing to the buffer data.\n    void* data{ };\n    result = buffer->Lock(0,                    // byte offset\n                          GetByteSize(indices), // byte size\n                          &data,                // receiving data pointer\n                          0);                   // special lock flag\n    if (FAILED(result))\n        return nullptr;\n    // Copy the index data and unlock after copying.\n    memcpy(data, indices.data(), GetByteSize(indices));\n    buffer->Unlock();\n    // Return the filled index buffer.\n    return buffer;\n}\n// ...\n// In our WinMain we can now change the vertex data and create new index data.\n// ...\nstd::vector<VStruct> vertices {\n    VStruct{ -1.0f, -1.0f, 1.0f, D3DXCOLOR{ 1.0f, 0.0f, 0.0f, 1.0f } },\n    VStruct{ -1.0f,  1.0f, 1.0f, D3DXCOLOR{ 0.0f, 1.0f, 0.0f, 1.0f } },\n    VStruct{  1.0f,  1.0f, 1.0f, D3DXCOLOR{ 0.0f, 0.0f, 1.0f, 1.0f } },\n    // Add a vertex for the bottom right.\n    VStruct{  1.0f, -1.0f, 1.0f, D3DXCOLOR{ 1.0f, 1.0f, 0.0f, 1.0f } }\n};\n// Declare the index data, here we build a rectangle from two triangles.\nstd::vector<unsigned int> indices {\n    0, 1, 2, // the first triangle (b,left -> t,left -> t,right)\n    0, 2, 3  // the second triangle (b,left -> t,right -> b,right)\n};\n// ...\n// Now we call the \"CreateIBuffer\" function to create a index buffer.\n// ...\nif (!(_indexBuffer = CreateIBuffer(indices)))\n    return -1;\n// ...\n// After binding the vertex buffer we have to bind the index buffer to\n// use indexed rendering.\nresult = _device->SetStreamSource(0, _vertexBuffer.Get(), 0, sizeof(VStruct));\nif (FAILED(result))\n    return -1;\n// Bind the index data to the default data stream.\nresult = _device->SetIndices(_indexBuffer.Get())\nif (FAILED(result))\n    return -1;\n// ...\n// Now we replace the \"DrawPrimitive\" function with an indexed version.\n_device->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, // primitive type\n                              0,                  // base vertex index\n                              0,                  // minimum index\n                              indices.size(),     // amount of vertices\n                              0,                  // start in index buffer\n                              2);                 // primitive count\n// ...\n```\n\nNow you should see a colored rectangle made up of 2 triangles. If you set the primitive count in the \"DrawIndexedPrimitive\" method to 1 only the first triangle should be rendered and if you set the start of the index buffer to 3 and the primitive count to 1 only the second triangle should be rendered.<br>\nYou can find the complete working code here: [DirectX - 2](https://pastebin.com/yWBPWPRG)\n\n## Vertex declaration\n\nInstead of using the old \"flexible vertex format\" we should use vertex declarations instead, as the FVF declarations get converted to vertex declarations internally anyway.\n\n```cpp\n// First we have to REMOVE the following lines:\nconst unsigned long VertexStructFVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;\n// and\n_device->SetFVF(VertexStructFVF);\n// ...\n// We also have to change the vertex buffer creation FVF-flag.\nresult = _device->CreateVertexBuffer(\n                      GetByteSize(vertices),\n                      0,\n                      0,        // <- 0 indicates we use vertex declarations\n                      D3DPOOL_DEFAULT,\n                      &buffer,\n                      nullptr); \n// Next we have to declare a new ComPtr.\nComPtr<IDirect3DVertexDeclaration9> _vertexDecl{ };\n// ...\nresult = _device->SetIndices(_indexBuffer.Get());\nif (FAILED(result))\n    return -1;\n// Now we have to declare and apply the vertex declaration.\n// Create a vector of vertex elements making up the vertex declaration.\nstd::vector<D3DVERTEXELEMENT9> vertexDeclDesc {\n    { 0,                     // stream index\n      0,                     // byte offset from the struct beginning\n      D3DDECLTYPE_FLOAT3,    // data type (3d float vector)\n      D3DDECLMETHOD_DEFAULT, // tessellator operation\n      D3DDECLUSAGE_POSTION,  // usage of the data\n      0 },                   // index (multiples usage of the same type)\n    { 0,\n      12,                    // byte offset (3 * sizeof(float) bytes)\n      D3DDECLTYPE_D3DCOLOR,\n      D3DDECLMETHOD_DEFAULT,\n      D3DDECLUSAGE_COLOR,\n      0 },\n    D3DDECL_END()            // marks the end of the vertex declaration\n};\n// After having defined the vector we can create a vertex declaration from it.\nresult = _device->CreateVertexDeclaration(\n                      vertexDeclDesc.data(), // the vertex element array\n                      &_vertexDecl);         // receiving pointer\nif (FAILED(result)) \n    return -1;\n// Apply the created vertex declaration.\n_device->SetVertexDeclaration(_vertexDecl.Get());\n// ...\n```\n\n## Shader\n\nThe maximum shader model for Direct3D 9 is shader model 3.0. Even though every modern graphics card should support it, it is best to check for capabilities.\n\n```cpp\n// ...\n_device->SetVertexDeclaration(_vertexDecl.Get());\n// First we have to request the device capabilities.\nD3DCAPS9 deviceCaps{ };\n_device->GetDeviceCaps(&deviceCaps);\n// Now we check if shader model 3.0 is supported for the vertex shader.\nif (deviceCaps.VertexShaderVersion < D3DVS_VERSION(3, 0))\n    return -1;\n// And the same for the pixel shader.\nif (deviceCaps.PixelShaderVersion < D3DPS_VERSION(3, 0))\n    return -1;\n```\n\nNow that we are sure shader model 3.0 is supported let's create the vertex and pixel shader files.\nDirectX 9 introduced the HLSL (**High Level Shading Language**), a C-like shader language, which\nsimplified the shader programming a lot, as you could only write shaders in shader assembly in DirectX 8.\nLet's create a simple vertex- and pixel shader. \n\n**Vertex Shader**\n\n```cpp\n// 3 4x4 float matrices representing the matrices we set in the fixed-function\n// pipeline by using the SetTransform() method.\nfloat4x4 projectionMatrix;\nfloat4x4 viewMatrix;\nfloat4x4 worldMatrix;\n// The input struct to the vertex shader.\n// It holds a 3d float vector for the position and a 4d float vector\n// for the color.\nstruct VS_INPUT {\n    float3 position : POSITION;\n    float4 color : COLOR;\n};\n// The output struct of the vertex shader, that is passed to the pixel shader.\nstruct VS_OUTPUT {\n    float4 position : POSITION;\n    float4 color : COLOR;\n};\n// The main function of the vertex shader returns the output it sends to the\n// pixel shader and receives it's input as a parameter.\nVS_OUTPUT main(VS_INPUT input) {\n    // Declare a empty struct, that the vertex shader returns.\n    VS_OUTPUT output;\n    // Set the output position to the input position and set\n    // the w-component to 1, as the input position is a 3d vector and\n    // the output position a 4d vector.\n    output.position = float4(input.position, 1.0f);\n    // Multiply the output position step by step with the world, view and\n    // projection matrices.\n    output.position = mul(output.position, worldMatrix);\t\n    output.position = mul(output.position, viewMatrix);\n    output.position = mul(output.position, projectionMatrix);\n\t// Pass the input color unchanged to the pixel shader.\n    output.color = input.color;\n    // Return the output struct to the pixel shader.\n    // The position value is automatically used as the vertex position.\n    return output;\n}\n```\n\n**Pixel Shader**\n\n```cpp\n// The pixel shader input struct must be the same as the vertex shader output!\nstruct PS_INPUT {\n    float4 position : POSITION;\n    float4 color : COLOR;\n};\n// The pixel shader simply returns a 4d vector representing the vertex color.\n// It receives it's input as a parameter just like the vertex shader.\n// We have to declare the output semantic as color to it gets interpreted\n// correctly.\nfloat4 main(PS_INPUT input) : COLOR {\n    return input.color;\n}\n```\n\nFor more on semantics: [DirectX - Semantics](https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics#vertex-shader-semantics)\n\nNow we have to do quite some changes to the code.\n\n```cpp\nComPtr<IDirect3DDevice9> _device{ };\nComPtr<IDirect3DVertexBuffer9> _vertexBuffer{ };\nComPtr<IDirect3DIndexBuffer9> _indexBuffer{ };\nComPtr<IDirect3DVertexDeclaration9> _vertexDecl{ };\n// We have to add a ComPtr for the vertex- and pixel shader, aswell as one\n// for the constants (matrices) in our vertex shader.\nComPtr<IDirect3DVertexShader9> _vertexShader{ };\nComPtr<IDirect3DPixelShader9> _pixelShader{ };\nComPtr<ID3DXConstantTable> _vertexTable{ };\n// Declare the world and rotation matrix as global, because we use them in\n// WinMain and SetupTransform now.\nD3DXMATRIX _worldMatrix{ };\nD3DXMATRIX _rotationMatrix{ };\n// ...\nbool SetupTransform() {\n    // Set the world and rotation matrix to an identity matrix.\n    D3DXMatrixIdentity(&_worldMatrix);\n    D3DXMatrixIdentity(&_rotationMatrix);\n\t\n    D3DXMATRIX scaling{ };\n    D3DXMatrixScaling(&scaling, 10, 10, 1);\n    D3DXMatrixMultiply(&_worldMatrix, &scaling, &_rotationMatrix);\n    // After multiplying the scalation and rotation matrix the have to pass\n    // them to the shader, by using a method from the constant table\n    // of the vertex shader.\n    HRESULT result{ };\n    result = _vertexTable->SetMatrix(\n                         _device.Get(),   // direct3d device\n                         \"worldMatrix\",   // matrix name in the shader\n                          &_worldMatrix); // pointer to the matrix\n    if (FAILED(result))\n        return false;\n\n    D3DXMATRIX view{ };\n    D3DXMatrixLookAtLH(&view, &D3DXVECTOR3{ 0.0f, 0.0f, -20.0f },\n           &D3DXVECTOR3{ 0.0f, 0.0f, 0.0f }, &D3DXVECTOR3{ 0.0f, 1.0f, 0.0f });\n    // Do the same for the view matrix.\n    result = _vertexTable->SetMatrix(\n\t                       _device.Get(), // direct 3d device\n\t                       \"viewMatrix\",  // matrix name\n\t                       &view);        // matrix\n    if (FAILED(result))\n        return false;\n\n    D3DXMATRIX projection{ };\n    D3DXMatrixPerspectiveFovLH(&projection, D3DXToRadian(60.0f),\n        1024.0f / 768.0f, 0.0f, 100.0f);\n    // And also for the projection matrix.\n    result = _vertexTable->SetMatrix(\n\t                       _device.Get(),\n\t                       \"projectionMatrix\",\n\t                       &projection);\n    if (FAILED(result))\n        return false;\n\n    D3DXMatrixRotationY(&_rotationMatrix, D3DXToRadian(0.5f));\n    return true;\n}\n// ...\n// Vertex and index buffer creation aswell as initialization stay unchanged.\n// ...\n// After checking that shader model 3.0 is available we have to compile and\n// create the shaders.\n// Declare two temporary buffers storing the compiled shader code.\nID3DXBuffer* vertexShaderBuffer{ };\nID3DXBuffer* pixelShaderBuffer{ };\nresult = D3DXCompileShaderFromFile(\"vertex.hlsl\",  // shader name\n                                   nullptr,        // macro definitions\n                                   nullptr,        // special includes\n                                   \"main\",         // entry point name\n                                   \"vs_3_0\",       // shader model version\n                                   0,              // special flags\n                                   &vertexShaderBuffer, // code buffer\n                                   nullptr,        // error message\n                                   &_vertexTable); // constant table\nif (FAILED(result))\n    return -1;\n// After the vertex shader compile the pixel shader.\nresult = D3DXCompileShaderFromFile(\"pixel.hlsl\",\n                                   nullptr,\n                                   nullptr,\n                                   \"main\",\n                                   \"ps_3_0\", // pixel shader model 3.0\n                                   0,\n                                   &pixelShaderBuffer,\n                                   nullptr,\n                                   nullptr); // no need for a constant table\nif (FAILED(result))\n    return -1;\n// Create the vertex shader from the code buffer.\nresult = _device->CreateVertexShader(\n             (DWORD*)vertexShaderBuffer->GetBufferPointer(), // code buffer\n             &_vertexShader); // vertex shader pointer\nif (FAILED(result))\n    return -1;\n\t\nresult = _device->CreatePixelShader(\n             (DWORD*)pixelShaderBuffer->GetBufferPointer(),\n             &_pixelShader);\nif (FAILED(result))\n    return -1;\n// Release the temporary code buffers after the shaders are created.\nvertexShaderBuffer->Release();\npixelShaderBuffer->Release();\n// Apply the vertex- and pixel shader.\n_device->SetVertexShader(_vertexShader.Get());\n_device->SetPixelShader(_pixelShader.Get());\n// Apply the transform after the shaders have been set.\nif (!SetupTransform())\n    return -1;\n// You can also REMOVE the call so set the lighting render state.\n_device->SetRenderState(D3DRS_LIGHTING, false);\n```\n\nYou can find the complete code here: [DirectX - 3](https://pastebin.com/y4NrvawY)\n\n## Texturing\n\n```cpp\n// First we need to declare a ComPtr for the texture.\nComPtr<IDirect3DTexture9> _texture{ };\n// Then we have to change the vertex struct.\nstruct VStruct {\n    float x, y, z;\n    float u, v;      // Add texture u and v coordinates\n    D3DCOLOR color;\n};\n// In the vertex declaration we have to add the texture coordinates.\n// the top left of the texture is u: 0, v: 0.\nstd::vector<VStruct> vertices {\n    VStruct{ -1.0f, -1.0f, 1.0f, 0.0f, 1.0f, ... }, // bottom left\n    VStruct{ -1.0f,  1.0f, 1.0f, 0.0f, 0.0f, ... }, // top left\n    VStruct{  1.0f,  1.0f, 1.0f, 1.0f, 0.0f, ... }, // top right\n    VStruct{  1.0f, -1.0f, 1.0f, 1.0f, 1.0f, ... }  // bottom right\n};\n// Next is the vertex declaration.\nstd::vector<D3DVERTEXELEMENT9> vertexDecl{\n    {0, 0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0},\n    // Add a 2d float vector used for texture coordinates.\n    {0, 12, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0},\n    // The color offset is not (3 + 2) * sizeof(float) = 20 bytes\n    {0, 20, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR, 0},\n    D3DDECL_END()\n};\n// Now we have to load the texture and pass its to the shader.\n// ...\n_device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);\n// Create a Direct3D texture from a png file.\nresult = D3DXCreateTextureFromFile(_device.Get(), // direct3d device\n                                   \"texture.png\", // texture path\n                                   &_texture);    // receiving texture pointer\nif (FAILED(result))\n    return -1;\n// Attach the texture to shader stage 0, which is equal to texture register 0\n// in the pixel shader.\n_device->SetTexture(0, _texture.Get());\n```\n\nWith the main code ready we now have to adjust the shaders to these changes.\n\n**Vertex Shader**\n\n```cpp\nfloat4x4 projectionMatrix;\nfloat4x4 viewMatrix;\nfloat4x4 worldMatrix;\n// Add the texture coordinates to the vertex shader in- and output.\nstruct VS_INPUT {\n    float3 position : POSITION;\n    float2 texcoord : TEXCOORD;\n    float4 color : COLOR;\n};\n\nstruct VS_OUTPUT {\n    float4 position : POSITION;\n    float2 texcoord : TEXCOORD;\n    float4 color : COLOR;\n};\n\nVS_OUTPUT main(VS_INPUT input) {\n    VS_OUTPUT output;\n    \n    output.position = float4(input.position, 1.0f);\n    output.position = mul(output.position, worldMatrix);\t\n    output.position = mul(output.position, viewMatrix);\n    output.position = mul(output.position, projectionMatrix);\n\n    output.color = input.color;\n    // Set the texcoord output to the input.\n    output.texcoord = input.texcoord;\n    \n    return output;\n}\n```\n\n**Pixel Shader**\n\n```cpp\n// Create  a sampler called \"sam0\" using sampler register 0, which is equal\n// to the texture stage 0, to which we passed the texture.\nsampler sam0 : register(s0);\n\nstruct PS_INPUT {\n    float4 position : POSITION;\n    float2 texcoord : TEXCOORD;\n    float4 color : COLOR;\n};\n\nfloat4 main(PS_INPUT input) : COLOR{\n    // Do a linear interpolation between the texture color and the input color\n    // using 75% of the input color.\n    // tex2D returns the texture data at the specified texture coordinate.\n    return lerp(tex2D(sam0, input.texcoord), input.color, 0.75f);\n}\n```\n\n## Quotes\n<sup>[1]</sup>[DirectX - Wikipedia](https://en.wikipedia.org/wiki/DirectX)"
