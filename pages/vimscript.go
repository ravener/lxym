
package pages

const Vimscript = "```vim\n\" ##############\n\"  Introduction\n\" ##############\n\"\n\" Vim script (also called VimL) is the subset of Vim's ex-commands which\n\" supplies a number of features one one would expect from a scripting language,\n\" such as values, variables, functions or loops. Always keep in the back of\n\" your mind that a Vim script file is just a sequence of ex-commands. It is\n\" very common for a script to mix programming-language features and raw\n\" ex-commands.\n\"\n\" You can run Vim script directly by entering the commands in command-line mode\n\" (press `:` to enter command-line mode), or you can write them to a file\n\" (without the leading `:`) and source it in a running Vim instance (`:source\n\" path/to/file`). Some files are sourced automatically as part of your\n\" configuration (see |startup|). This guide assumes that you are familiar\n\" with ex-commands and will only cover the scripting. Help topics to the\n\" relevant manual sections are included.\n\"\n\" See |usr_41.txt| for the official introduction to Vim script. A comment is\n\" anything following an unmatched `\"` until the end of the line, and `|`\n\" separates instructions (what `;` does in most other languages). References to\n\" the manual as surrounded with `|`, such as |help.txt|.\n\n\" This is a comment\n\n\" The vertical line '|' (pipe) separates commands\necho 'Hello' | echo 'world!'\n\n\" Putting a comment after a command usually works\npwd                   \" Displays the current working directory\n\n\" Except for some commands it does not; use the command delemiter before the\n\" comment (echo assumes that the quotation mark begins a string)\necho 'Hello world!'  | \" Displays a message\n\n\" Line breaks can be escaped by pacing a backslash as the first non-whitespace\n\" character on the *following* line. Only works in script files, not on the\n\" command line\necho \" Hello\n    \\ world \"\n\necho [1, \n    \\ 2]\n\necho {\n    \\ 'a': 1,\n    \\ 'b': 2\n\\}\n\n\n\" #######\n\"  Types\n\" #######\n\"\n\" For an overview of types see |E712|. For an overview of operators see\n\" |expression-syntax|\n\n\" Numbers (|expr-number|)\n\" #######\n\necho  123         | \" Decimal\necho  0b1111011   | \" Binary\necho  0173        | \" Octal\necho  0x7B        | \" Hexadecimal\necho  123.0       | \" Floating-point\necho  1.23e2      | \" Floating-point (scientific notation)\n\n\" Note that an *integer* number with a leading `0` is in octal notation. The\n\" usual arithmetic operations are supported.\n\necho  1 + 2       | \" Addition\necho  1 - 2       | \" Subtraction\necho  - 1         | \" Negation (unary minus)\necho  + 1         | \" Unary plus (does nothing really, but still legal)\necho  1 * 2       | \" Multiplication\necho  1 / 2       | \" Division\necho  1 % 2       | \" Modulo (remainder)\n\n\" Booleans (|Boolean|)\n\" ########\n\"\n\" The number 0 is false, every other number is true. Strings are implicitly\n\" converted to numbers (see below). There are two pre-defined semantic\n\" constants.\n\necho  v:true      | \" Evaluates to 1 or the string 'v:true'\necho  v:false     | \" Evaluates to 0 or the string 'v:false'\n\n\" Boolean values can result from comparison of two objects.\n\necho  x == y             | \" Equality by value\necho  x != y             | \" Unequality\necho  x >  y             | \" Greater than\necho  x >= y             | \" Greater than or equal\necho  x <  y             | \" Smaller than\necho  x <= y             | \" Smaller than or equal\necho  x is y             | \" Instance identity (lists and dictionaries)\necho  x isnot y          | \" Instance non-identity (lists and dictionaries)\n\n\" Strings are compared based on their alphanumerical ordering\n\" echo 'a' < 'b'. Case sensitivity depends on the setting of 'ignorecase'\n\"\n\" Explicit case-sensitivity is specified by appending '#' (match case) or '?'\n\" (ignore case) to the operator. Prefer explicity case sensitivity when writing\n\" portable scripts.\n\necho  'a' <  'B'         | \" True or false depending on 'ignorecase'\necho  'a' <? 'B'         | \" True\necho  'a' <# 'B'         | \" False\n\n\" Regular expression matching\necho  \"hi\" =~  \"hello\"    | \" Regular expression match, uses 'ignorecase'\necho  \"hi\" =~# \"hello\"    | \" Regular expression match, case sensitive\necho  \"hi\" =~? \"hello\"    | \" Regular expression match, case insensitive\necho  \"hi\" !~  \"hello\"    | \" Regular expression unmatch, use 'ignorecase'\necho  \"hi\" !~# \"hello\"    | \" Regular expression unmatch, case sensitive\necho  \"hi\" !~? \"hello\"    | \" Regular expression unmatch, case insensitive\n\n\" Boolean operations are possible.\n\necho  v:true && v:false       | \" Logical AND\necho  v:true || v:false       | \" Logical OR\necho  ! v:true                | \" Logical NOT\necho  v:true ? 'yes' : 'no'   | \" Ternary operator\n\n\n\" Strings (|String|)\n\" #######\n\"\n\" An ordered zero-indexed sequence of bytes. The encoding of text into bytes\n\" depends on the option |'encoding'|.\n\n\" Literal constructors\necho  \"Hello world\\n\"   | \" The last two characters stand for newline\necho  'Hello world\\n'   | \" The last two characters are literal\necho  'Let''s go!'      | \" Two single quotes become one quote character\n\n\" Single-quote strings take all characters are literal, except two single\n\" quotes, which are taken to be a single quote in the string itself. See \n\" |expr-quote| for all possible escape sequences.\n\n\" String concatenation\n\" The .. operator is preferred, but only supported in since Vim 8.1.1114\necho  'Hello ' .  'world'  | \" String concatenation\necho  'Hello ' .. 'world'  | \" String concatenation (new variant)\n\n\" String indexing\necho  'Hello'[0]           | \" First byte\necho  'Hello'[1]           | \" Second byte\necho  'Hellö'[4]           | \" Returns a byte, not the character 'ö'\n\n\" Substrings (second index is inclusive)\necho  'Hello'[:]           | \" Copy of entire string\necho  'Hello'[1:3]         | \" Substring, second to fourth byte\necho  'Hello'[1:-2]        | \" Substring until second to last byte\necho  'Hello'[1:]          | \" Substring with starting index\necho  'Hello'[:2]          | \" Substring with ending index\necho  'Hello'[-2:]         | \" Substring relative to end of string\n\n\" A negative index is relative to the end of the string. See\n\" |string-functions| for all string-related functions.\n\n\" Lists (|List|)\n\" #####\n\"\n\" An ordered zero-indexed heterogeneous sequence of arbitrary Vim script\n\" objects.\n\n\" Literal constructor\necho  []                   | \" Empty list\necho  [1, 2, 'Hello']      | \" List with elements\necho  [1, 2, 'Hello', ]    | \" Trailing comma permitted\necho  [[1, 2], 'Hello']    | \" Lists can be nested arbitrarily\n\n\" List concatenation\necho  [1, 2] + [3, 4]      | \" Creates a new list\n\n\" List indexing, negative is relative to end of list (|list-index|)\necho  [1, 2, 3, 4][2]      | \" Third element\necho  [1, 2, 3, 4][-1]     | \" Last element\n\n\" List slicing (|sublist|)\necho  [1, 2, 3, 4][:]      | \" Shallow copy of entire list\necho  [1, 2, 3, 4][:2]     | \" Sublist until third item (inclusive)\necho  [1, 2, 3, 4][2:]     | \" Sublist from third item (inclusive)\necho  [1, 2, 3, 4][:-2]    | \" Sublist until second-to-last item (inclusive)\n\n\" All slicing operations create new lists. To modify a list in-place use list\n\" functions (|list-functions|) or assign directly to an item (see below about\n\" variables).\n\n\n\" Dictionaries (|Dictionary|)\n\" ############\n\"\n\" An unordered sequence of key-value pairs, keys are always strings (numbers\n\" are implicitly converted to strings).\n\n\" Dictionary literal\necho  {}                       | \" Empty dictionary\necho  {'a': 1, 'b': 2}         | \" Dictionary literal\necho  {'a': 1, 'b': 2, }       | \" Trailing comma permitted\necho  {'x': {'a': 1, 'b': 2}}  | \" Nested dictionary\n\n\" Indexing a dictionary\necho  {'a': 1, 'b': 2}['a']    | \" Literal index\necho  {'a': 1, 'b': 2}.a       | \" Syntactic sugar for simple keys\n\n\" See |dict-functions| for dictionary manipulation functions.\n\n\n\" Funcref (|Funcref|)\n\" #######\n\"\n\" Reference to a function, uses the function name as a string for construction.\n\" When stored in a variable the name of the variable has the same restrictions\n\" as a function name (see below).\n\necho  function('type')                   | \" Reference to function type()\n\" Note that `funcref('type')` will throw an error because the argument must be\n\" a user-defined function; see further below for defining your own functions.\necho  funcref('type')                    | \" Reference by identity, not name\n\" A lambda (|lambda|) is an anonymous function; it can only contain one\n\" expression in its body, which is also its implicit return value.\necho  {x -> x * x}                       | \" Anonymous function\necho  function('substitute', ['hello'])  | \" Partial function\n\n\n\" Regular expression (|regular-expression|)\n\" ##################\n\"\n\" A regular expression pattern is generally a string, but in some cases you can\n\" also use a regular expression between a pair of delimiters (usually `/`, but\n\" you can choose anything).\n\n\" Substitute 'hello' for 'Hello'\nsubstitute/hello/Hello/\n\n\n\" ###########################\n\"  Implicit type conversions\n\" ###########################\n\"\n\" Strings are converted to numbers, and numbers to strings when necessary. A\n\" number becomes its decimal notation as a string. A string becomes its\n\" numerical value if it can be parsed to a number, otherwise it becomes zero.\n\necho  \"1\" + 1         | \" Number\necho  \"1\" .. 1        | \" String\necho  \"0xA\" + 1       | \" Number\n\n\" Strings are treated like numbers when used as booleans\necho \"true\" ? 1 : 0   | \" This string is parsed to 0, which is false\n\n\" ###########\n\"  Variables\n\" ###########\n\" \n\" Variables are bound within a scope; if no scope is provided a default is\n\" chosen by Vim. Use `:let` and `:const` to bind a value and `:unlet` to unbind\n\" it.\n\nlet b:my_var = 1        | \" Local to current buffer\nlet w:my_var = 1        | \" Local to current window\nlet t:my_var = 1        | \" Local to current tab page\nlet g:my_var = 1        | \" Global variable\nlet l:my_var = 1        | \" Local to current function (see functions below)\nlet s:my_var = 1        | \" Local to current script file\nlet a:my_arg = 1        | \" Function argument (see functions below)\n\n\" The Vim scope is read-only\necho  v:true            | \" Special built-in Vim variables (|v:var|)\n\n\" Access special Vim memory like variables\nlet @a = 'Hello'        | \" Register\nlet $PATH=''            | \" Environment variable\nlet &textwidth = 79     | \" Option\nlet &l:textwidth = 79   | \" Local option\nlet &g:textwidth = 79   | \" Global option\n\n\" Access scopes as dictionaries (can be modified like all dictionaries)\n\" See the |dict-functions|, especially |get()|, for access and manipulation\necho  b:                | \" All buffer variables\necho  w:                | \" All window variables\necho  t:                | \" All tab page variables\necho  g:                | \" All global variables\necho  l:                | \" All local variables\necho  s:                | \" All script variables\necho  a:                | \" All function arguments\necho  v:                | \" All Vim variables\n\n\" Constant variables\nconst x = 10            | \" See |:const|, |:lockvar|\n\n\" Function reference variables have the same restrictions as function names\nlet IsString = {x -> type(x) == type('')}    | \" Global: capital letter\nlet s:isNumber = {x -> type(x) == type(0)}   | \" Local: any name allowed\n\n\" When omitted the scope `g:` is implied, except in functions, there `l:` is\n\" implied.\n\n\n\" Multiple value binding (list unpacking)\n\" #######################################\n\"\n\" Assign values of list to multiple variables (number of items must match)\nlet [x, y] = [1, 2]\n\n\" Assign the remainer to a rest variable (note the semicolon)\nlet [mother, father; children] = ['Alice', 'Bob', 'Carol', 'Dennis', 'Emily']\n\n\n\" ##############\n\"  Flow control\n\" ##############\n\n\" Conditional (|:if|, |:elseif|, |:else|, |:endif|)\n\" ###########\n\" \n\" Conditions are set between `if` and `endif`. They can be nested.\n\nlet condition = v:true\n\nif condition\n    echo 'First condition'\nelseif another_condition\n    echo 'Second condition'\nelse\n    echo 'Fail'\nendif\n\n\" Loops (|:for|, |:endfor|, |:while|, |:endwhile|, |:break|, |:continue|)\n\" #####\n\"\n\" Two types of loops: `:for` and `:while`. Use `:continue` to skip to the next\n\" iteration, `:break` to break out of the loop.\n\n\" For-loop (|:for|, |:endfor|)\n\" ========\n\"\n\" For-loops iterate over lists and nothing else. If you want to iterate over\n\" another sequence you need to use a function which will create a list.\n\n\" Iterate over a list\nfor person in ['Alice', 'Bob', 'Carol', 'Dennis', 'Emily']\n    echo 'Hello ' .. person\nendfor\n\n\" Iterate over a nested list by unpacking it\nfor [x, y] in [[1, 0], [0, 1], [-1, 0], [0, -1]]\n    echo 'Position: x ='  .. x .. ', y = ' .. y\nendfor\n\n\" Iterate over a range of numbers\nfor i in range(10, 0, -1)  \" Count down from 10\n    echo 'T minus'  .. i\nendfor\n\n\" Iterate over the keys of a dictionary\nfor symbol in keys({'π': 3.14, 'e': 2.71})\n    echo 'The constant ' .. symbol .. ' is a transcendent number'\nendfor\n\n\" Iterate over the values of a dictionary\nfor value in values({'π': 3.14, 'e': 2.71})\n    echo 'The value ' .. value .. ' approximates a transcendent number'\nendfor\n\n\" Iterate over the keys and values of a dictionary\nfor [symbol, value] in items({'π': 3.14, 'e': 2.71})\n    echo 'The number ' .. symbol .. ' is approximately ' .. value\nendfor\n\n\" While-loops (|:while|, |:endwhile|)\n\nlet there_yet = v:true\nwhile !there_yet\n    echo 'Are we there yet?'\nendwhile\n\n\n\" Exception handling (|exception-handling|)\n\" ##################\n\"\n\" Throw new exceptions as strings, catch them by pattern-matching a regular\n\" expression against the string\n\n\" Throw new exception\nthrow \"Wrong arguments\"\n\n\" Guard against an exception (the second catch matches any exception)\ntry\n    source path/to/file\ncatch /Cannot open/\n    echo 'Looks like that file does not exist'\ncatch /.*/\n    echo 'Something went wrong, but I do not know what'\nfinally\n    echo 'I am done trying'\nendtry\n\n\n\" ##########\n\"  Functions\n\" ##########\n\n\" Defining functions (|:function|, |:endfunction|)\n\" ##################\n\n\" Unscoped function names have to start with a capital letter\nfunction! AddNumbersLoudly(x, y)\n    \" Use a: scope to access arguments\n    echo 'Adding'  .. a:x ..  'and'  .. a:y   | \" A side effect\n    return a:x + a:y                          | \" A return value\nendfunction\n\n\" Scoped function names may start with a lower-case letter\nfunction! s:addNumbersLoudly(x, y)\n    echo 'Adding'  .. a:x ..  'and'  .. a:y\n    return a:x + a:y\nendfunction\n\n\" Without the exclamation mark it would be an error to re-define a function,\n\" with the exclamation mark the new definition can replace the old one. Since\n\" Vim script files can be reloaded several times over the course of a session\n\" it is best to use the exclamation mark unless you really know what you are\n\" doing.\n\n\" Function definitions can have special qualifiers following the argument list.\n\n\" Range functions define two implicit arguments, which will be set to the range\n\" of the ex-command\nfunction! FirstAndLastLine() range\n    echo [a:firstline, a:lastline]\nendfunction\n\n\" Prints the first and last line that match a pattern (|cmdline-ranges|)\n/^#!/,/!#$/call FirstAndLastLine()\n\n\" Aborting functions, abort once error occurs (|:func-abort|)\nfunction! SourceMyFile() abort\n    source my-file.vim        | \" Try sourcing non-existing file\n    echo 'This will never be printed'\nendfunction\n\n\" Closures, functions carrying values from outer scope (|:func-closure|)\nfunction! MakeAdder(x)\n    function! Adder(n) closure\n        return a:n + a:x\n    endfunction\n    return funcref('Adder')\nendfunction\nlet AddFive = MakeAdder(5)\necho AddFive(3)               | \" Prints 8\n\n\" Dictionary functions, poor man's OOP methods (|Dictionary-function|)\nfunction! Mylen() dict\n    return len(self.data)     | \" Implicit variable self\nendfunction\nlet mydict = {'data': [0, 1, 2, 3], 'len': function(\"Mylen\")}\necho mydict.len()\n\n\" Alternatively, more concise\nlet mydict = {'data': [0, 1, 2, 3]}\nfunction! mydict.len()\n    return len(self.data)\nendfunction\n\n\" Calling functions (|:call|)\n\" #################\n\n\" Call a function for its return value, and possibly for its side effects\nlet animals = keys({'cow': 'moo', 'dog': 'woof', 'cat': 'meow'})\n\n\" Call a function for its side effects only, ignore potential return value\ncall sign_undefine()\n\n\" The call() function calls a function reference and passes parameters as a\n\" list, and returns the function's result.\necho  call(function('get'), [{'a': 1, 'b': 2}, 'c', 3])   | \" Prints 3\n\n\" Recall that Vim script is embedded within the ex-commands, that is why we\n\" cannot just call a function directly, we have to use the `:call` ex-command.\n\n\" Function namespaces (|write-library-script|, |autoload|)\n\" ###################\n\n\" Must be defined in autoload/foo/bar.vim\n\" Namspaced function names do not have to start with a capital letter\nfunction! foo#bar#log(value)\n    echomsg value\nendfunction\n\ncall foo#bar#log('Hello')\n\n\n\" #############################\n\"  Frequently used ex-commands\n\" #############################\n\n\n\" Sourcing runtime files (|'runtimepath'|)\n\" ######################\n\n\" Source first match among runtime paths\nruntime plugin/my-plugin.vim\n\n\n\" Defining new ex-commands (|40.2|, |:command|)\n\" ########################\n\n\" First argument here is the name of the command, rest is the command body\ncommand! SwapAdjacentLines normal! ddp\n\n\" The exclamation mark works the same as with `:function`. User-defined\n\" commands must start with a capital letter. The `:command` command can take a\n\" number of attributes (some of which have their own parameters with `=`), such\n\" as `-nargs`, all of them start with a dash to set them apart from the command\n\" name.\n\ncommand! -nargs=1 Error echoerr <args>\n\n\n\" Defining auto-commands (|40.3|, |autocmd|, |autocommand-events|)\n\" ######################\n\n\" The arguments are \"events\", \"patterns\", rest is \"commands\"\nautocmd BufWritePost $MYVIMRC source $MYVIMRC\n\n\" Events and patterns are separated by commas with no space between. See\n\" |autocmd-events| for standard events, |User| for custom events. Everything\n\" else are the ex-commands which will be executed.\n\n\" Auto groups\n\" ===========\n\"\n\" When a file is sourced multiple times the auto-commands are defined anew,\n\" without deleting the old ones, causing auto-commands to pile up over time.\n\" Use auto-groups and the following ritual to guard against this.\n\naugroup auto-source   | \" The name of the group is arbitrary\n    autocmd!          | \" Deletes all auto-commands in the current group\n    autocmd BufWritePost $MYVIMRC source $MYVIMRC\naugroup END           | \" Switch back to default auto-group\n\n\" It is also possible to assign a group directly. This is useful if the\n\" definition of the group is in one script and the definition of the\n\" auto-command is in another script.\n\n\" In one file\naugroup auto-source\n    autocmd!\naugroup END\n\n\" In another file\nautocmd auto-source BufWritePost $MYVIMRC source $MYVIMRC\n\n\" Executing (run-time macros of sorts)\n\" ####################################\n\n\" Sometimes we need to construct an ex-command where part of the command is not\n\" known until runtime.\n\nlet line = 3                | \" Line number determined at runtime\nexecute line .. 'delete'    | \" Delete a line\n\n\" Executing normal-mode commands\n\" ##############################\n\"\n\" Use `:normal` to play back a sequence of normal mode commands from the\n\" command-line. Add an exclamation mark to ignore user mappings.\n\nnormal! ggddGp             | \" Transplant first line to end of buffer\n\n\" Window commands can be used with :normal, or with :wincmd if :normal would\n\" not work\nwincmd L                   | \" Move current window all the way to the right\n\n\n\" ###########################\n\"  Frequently used functions\n\" ###########################\n\n\" Feature check\necho  has('nvim')                  | \" Running Neovim\necho  has('python3')               | \" Support for Python 3 plugins\necho  has('unix')                  | \" Running on a Unix system\necho  has('win32')                 | \" Running on a Windows system\n\n\n\" Test if something exists\necho  exists('&mouse')             | \" Option (exists only)\necho  exists('+mouse')             | \" Option (exists and works)\necho  exists('$HOSTNAME')          | \" Environment variable\necho  exists('*strftime')          | \" Built-in function\necho  exists('**s:MyFunc')         | \" User-defined function\necho  exists('bufcount')           | \" Variable (scope optional)\necho  exists('my_dict[\"foo\"]')     | \" Variable (dictionary entry)\necho  exists('my_dict[\"foo\"]')     | \" Variable (dictionary entry)\necho  exists(':Make')              | \" Command\necho  exists(\"#CursorHold\")        | \" Auto-command defined for event\necho  exists(\"#BufReadPre#*.gz\")   | \" Event and pattern\necho  exists(\"#filetypeindent\")    | \" Auto-command group\necho  exists(\"##ColorScheme\")      | \" Auto-commnand supported for event\n\n\" Various dynamic values (see |expand()|)\necho  expand('%')                  | \" Current file name\necho  expand('<cword>')            | \" Current word under cursor\necho  expand('%:p')                | \" Modifier are possible\n\n\" Type tests\n\" There are unique constants defined for the following types. Older versions\n\" of Vim lack the type variables, see the reference \" documentation for a\n\" workaround\necho  type(my_var) == v:t_number      | \" Number\necho  type(my_var) == v:t_string      | \" String\necho  type(my_var) == v:t_func        | \" Funcref\necho  type(my_var) == v:t_list        | \" List\necho  type(my_var) == v:t_dict        | \" Dictionary\necho  type(my_var) == v:t_float       | \" Float\necho  type(my_var) == v:t_bool        | \" Explicit Boolean\n\" For the null object should compare it against itself\necho  my_var is v:null\n\n\" Format strings\necho  printf('%d in hexadecimal is %X', 123, 123)\n\n\n\" #####################\n\"  Tricks of the trade\n\" #####################\n\n\" Source guard\n\" ############\n\n\" Prevent a file from being sourced multiple times; users can set the variable\n\" in their configuration to prevent the plugin from loading at all.\nif exists('g:loaded_my_plugin')\n    finish\nendif\nlet g:loaded_my_plugin = v:true\n\n\" Default values\n\" ##############\n\n\" Get a default value: if the user defines a variable use it, otherwise use a\n\" hard-coded default. Uses the fact that a scope is also a dictionary.\nlet s:greeting = get(g:, 'my_plugin_greeting', 'Hello')\n```"
