
package pages

const Livescript = "LiveScript is a functional compile-to-JavaScript language which shares\nmost of the underlying semantics with its host language. Nice additions\ncomes with currying, function composition, pattern matching and lots of\nother goodies heavily borrowed from languages like Haskell, F# and\nScala.\n\nLiveScript is a fork of [Coco][], which is itself a fork of\n[CoffeeScript][]. The language is stable, and a new version is in active\ndevelopment to bring a plethora of new niceties!\n\n[Coco]: http://satyr.github.io/coco/\n[CoffeeScript]: http://coffeescript.org/\n\nFeedback is always welcome, so feel free to reach me over at\n[@kurisuwhyte](https://twitter.com/kurisuwhyte) :)\n\n\n```coffeescript\n# Just like its CoffeeScript cousin, LiveScript uses number symbols for\n# single-line comments.\n\n/*\n Multi-line comments are written C-style. Use them if you want comments\n to be preserved in the JavaScript output.\n */\n```\n```coffeescript\n# As far as syntax goes, LiveScript uses indentation to delimit blocks,\n# rather than curly braces, and whitespace to apply functions, rather\n# than parenthesis.\n\n\n########################################################################\n## 1. Basic values\n########################################################################\n\n# Lack of value is defined by the keyword `void` instead of `undefined`\nvoid            # same as `undefined` but safer (can't be overridden)\n\n# No valid value is represented by Null.\nnull\n\n\n# The most basic actual value is the logical type:\ntrue\nfalse\n\n# And it has a plethora of aliases that mean the same thing:\non; off\nyes; no\n\n\n# Then you get numbers. These are double-precision floats like in JS.\n10\n0.4     # Note that the leading `0` is required\n\n# For readability, you may use underscores and letter suffixes in a\n# number, and these will be ignored by the compiler.\n12_344km\n\n\n# Strings are immutable sequences of characters, like in JS:\n\"Christina\"             # apostrophes are okay too!\n\"\"\"Multi-line\n   strings\n   are\n   okay\n   too.\"\"\"\n\n# Sometimes you want to encode a keyword, the backslash notation makes\n# this easy:\n\\keyword                # => 'keyword'\n\n\n# Arrays are ordered collections of values.\nfruits =\n  * \\apple\n  * \\orange\n  * \\pear\n\n# They can be expressed more concisely with square brackets:\nfruits = [ \\apple, \\orange, \\pear ]\n\n# You also get a convenient way to create a list of strings, using\n# white space to delimit the items.\nfruits = <[ apple orange pear ]>\n\n# You can retrieve an item by their 0-based index:\nfruits[0]       # => \"apple\"\n\n# Objects are a collection of unordered key/value pairs, and a few other\n# things (more on that later).\nperson =\n  name: \"Christina\"\n  likes:\n    * \"kittens\"\n    * \"and other cute stuff\"\n\n# Again, you can express them concisely with curly brackets:\nperson = {name: \"Christina\", likes: [\"kittens\", \"and other cute stuff\"]}\n\n# You can retrieve an item by their key:\nperson.name     # => \"Christina\"\nperson[\"name\"]  # => \"Christina\"\n\n\n# Regular expressions use the same syntax as JavaScript:\ntrailing-space = /\\s$/          # dashed-words become dashedWords\n\n# Except you can do multi-line expressions too!\n# (comments and whitespace just gets ignored)\nfunRE = //\n        function\\s+(.+)         # name\n        \\s* \\((.*)\\) \\s*        # arguments\n        { (.*) }                # body\n        //\n\n\n########################################################################\n## 2. Basic operations\n########################################################################\n\n# Arithmetic operators are the same as JavaScript's:\n1 + 2   # => 3\n2 - 1   # => 1\n2 * 3   # => 6\n4 / 2   # => 2\n3 % 2   # => 1\n\n\n# Comparisons are mostly the same too, except that `==` is the same as\n# JS's `===`, where JS's `==` in LiveScript is `~=`, and `===` enables\n# object and array comparisons, and also stricter comparisons:\n2 == 2          # => true\n2 == \"2\"        # => false\n2 ~= \"2\"        # => true\n2 === \"2\"       # => false\n\n[1,2,3] == [1,2,3]        # => false\n[1,2,3] === [1,2,3]       # => true\n\n+0 == -0     # => true\n+0 === -0    # => false\n\n# Other relational operators include <, <=, > and >=\n\n# Logical values can be combined through the logical operators `or`,\n# `and` and `not`\ntrue and false  # => false\nfalse or true   # => true\nnot false       # => true\n\n\n# Collections also get some nice additional operators\n[1, 2] ++ [3, 4]                # => [1, 2, 3, 4]\n'a' in <[ a b c ]>              # => true\n'name' of { name: 'Chris' }     # => true\n\n\n########################################################################\n## 3. Functions\n########################################################################\n\n# Since LiveScript is functional, you'd expect functions to get a nice\n# treatment. In LiveScript it's even more apparent that functions are\n# first class:\nadd = (left, right) -> left + right\nadd 1, 2        # => 3\n\n# Functions which take no arguments are called with a bang!\ntwo = -> 2\ntwo!\n\n# LiveScript uses function scope, just like JavaScript, and has proper\n# closures too. Unlike JavaScript, the `=` works as a declaration\n# operator, and will always declare the variable on the left hand side.\n\n# The `:=` operator is available to *reuse* a name from the parent\n# scope.\n\n\n# You can destructure arguments of a function to quickly get to\n# interesting values inside a complex data structure:\ntail = ([head, ...rest]) -> rest\ntail [1, 2, 3]  # => [2, 3]\n\n# You can also transform the arguments using binary or unary\n# operators. Default arguments are also possible.\nfoo = (a = 1, b = 2) -> a + b\nfoo!    # => 3\n\n# You could use it to clone a particular argument to avoid side-effects,\n# for example:\ncopy = (^^target, source) ->\n  for k,v of source => target[k] = v\n  target\na = { a: 1 }\ncopy a, { b: 2 }        # => { a: 1, b: 2 }\na                       # => { a: 1 }\n\n\n# A function may be curried by using a long arrow rather than a short\n# one:\nadd = (left, right) --> left + right\nadd1 = add 1\nadd1 2          # => 3\n\n# Functions get an implicit `it` argument, even if you don't declare\n# any.\nidentity = -> it\nidentity 1      # => 1\n\n# Operators are not functions in LiveScript, but you can easily turn\n# them into one! Enter the operator sectioning:\ndivide-by-two = (/ 2)\n[2, 4, 8, 16].map(divide-by-two) .reduce (+)\n\n\n# Not only of function application lives LiveScript, as in any good\n# functional language you get facilities for composing them:\ndouble-minus-one = (- 1) . (* 2)\n\n# Other than the usual `f . g` mathematical formulae, you get the `>>`\n# and `<<` operators, that describe how the flow of values through the\n# functions.\ndouble-minus-one = (* 2) >> (- 1)\ndouble-minus-one = (- 1) << (* 2)\n\n\n# And talking about flow of value, LiveScript gets the `|>` and `<|`\n# operators that apply a value to a function:\nmap = (f, xs) --> xs.map f\n[1 2 3] |> map (* 2)            # => [2 4 6]\n\n# You can also choose where you want the value to be placed, just mark\n# the place with an underscore (_):\nreduce = (f, xs, initial) --> xs.reduce f, initial\n[1 2 3] |> reduce (+), _, 0     # => 6\n\n\n# The underscore is also used in regular partial application, which you\n# can use for any function:\ndiv = (left, right) -> left / right\ndiv-by-two = div _, 2\ndiv-by-two 4      # => 2\n\n\n# Last, but not least, LiveScript has back-calls, which might help\n# with some callback-based code (though you should try more functional\n# approaches, like Promises):\nreadFile = (name, f) -> f name\na <- readFile 'foo'\nb <- readFile 'bar'\nconsole.log a + b\n\n# Same as:\nreadFile 'foo', (a) -> readFile 'bar', (b) -> console.log a + b\n\n\n########################################################################\n## 4. Patterns, guards and control-flow\n########################################################################\n\n# You can branch computations with the `if...else` expression:\nx = if n > 0 then \\positive else \\negative\n\n# Instead of `then`, you can use `=>`\nx = if n > 0 => \\positive\n    else        \\negative\n\n# Complex conditions are better-off expressed with the `switch`\n# expression, though:\ny = {}\nx = switch\n  | (typeof y) is \\number => \\number\n  | (typeof y) is \\string => \\string\n  | 'length' of y         => \\array\n  | otherwise             => \\object      # `otherwise` and `_` always matches.\n\n# Function bodies, declarations and assignments get a free `switch`, so\n# you don't need to type it again:\ntake = (n, [x, ...xs]) -->\n                        | n == 0 => []\n                        | _      => [x] ++ take (n - 1), xs\n\n\n########################################################################\n## 5. Comprehensions\n########################################################################\n\n# While the functional helpers for dealing with lists and objects are\n# right there in the JavaScript's standard library (and complemented on\n# the prelude-ls, which is a \"standard library\" for LiveScript),\n# comprehensions will usually allow you to do this stuff faster and with\n# a nice syntax:\noneToTwenty = [1 to 20]\nevens       = [x for x in oneToTwenty when x % 2 == 0]\n\n# `when` and `unless` can be used as filters in the comprehension.\n\n# Object comprehension works in the same way, except that it gives you\n# back an object rather than an Array:\ncopy = { [k, v] for k, v of source }\n\n\n########################################################################\n## 4. OOP\n########################################################################\n\n# While LiveScript is a functional language in most aspects, it also has\n# some niceties for imperative and object oriented programming. One of\n# them is class syntax and some class sugar inherited from CoffeeScript:\nclass Animal\n  (@name, kind) ->\n    @kind = kind\n  action: (what) -> \"*#{@name} (a #{@kind}) #{what}*\"\n\nclass Cat extends Animal\n  (@name) -> super @name, 'cat'\n  purr: -> @action 'purrs'\n\nkitten = new Cat 'Mei'\nkitten.purr!      # => \"*Mei (a cat) purrs*\"\n\n# Besides the classical single-inheritance pattern, you can also provide\n# as many mixins as you would like for a class. Mixins are just plain\n# objects:\nHuggable =\n  hug: -> @action 'is hugged'\n\nclass SnugglyCat extends Cat implements Huggable\n\nkitten = new SnugglyCat 'Purr'\nkitten.hug!     # => \"*Mei (a cat) is hugged*\"\n```\n\n## Further reading\n\nThere's just so much more to LiveScript, but this should be enough to\nget you started writing little functional things in it. The\n[official website](http://livescript.net/) has a lot of information on the\nlanguage, and a nice online compiler for you to try stuff out!\n\nYou may also want to grab yourself some\n[prelude.ls](http://gkz.github.io/prelude-ls/), and check out the `#livescript`\nchannel on the Freenode network."
