
package pages

const Fortran95 = "Fortran is one of the oldest computer languages. It was developed in the 1950s \nby IBM for numeric calculations (Fortran is an abbreviation of \"Formula \nTranslation\"). Despite its age, it is still used for high-performance computing\nsuch as weather prediction. However, the language has changed considerably over\nthe years, although mostly maintaining backwards compatibility; well known\nversions are FORTRAN 77, Fortran 90, Fortran 95, Fortran 2003, Fortran 2008 and\nFortran 2015.\n\nThis overview will discuss the features of Fortran 95 since it is the most\nwidely implemented of the more recent specifications and the later versions are\nlargely similar (by comparison FORTRAN 77 is a very different language).\n\n```fortran\n\n! This is a comment.\n\n\nprogram example   !declare a program called example.\n\n    ! Code can only exist inside programs, functions, subroutines or modules.\n    ! Using indentation is not required but it is recommended.\n\n\n    ! Declaring Variables\n    ! ===================\n    \n    ! All declarations must come before statements and expressions.\n    \n    implicit none    !prevents dynamic declaration of variables (recommended!)\n    ! Implicit none must be redeclared in every function/program/module...\n    \n    ! IMPORTANT - Fortran is case insensitive.\n    real z\n    REAL Z2\n\n    real :: v,x    ! WARNING: default initial values are compiler dependent!    \n    real :: a = 3, b=2E12, c = 0.01\n    integer :: i, j, k=1, m\n    real, parameter :: PI = 3.1415926535897931    !declare a constant.\n    logical :: y = .TRUE. , n = .FALSE.    !boolean type.\n    complex :: w = (0,1)    !sqrt(-1)\n    character (len=3) :: month    !string of 3 characters.\n    \n    real :: array(6)     !declare an array of 6 reals.\n    real, dimension(4) :: arrayb    !another way to declare an array.\n    integer :: arrayc(-10:10)   !an array with a custom index.\n    real :: array2d(3,2)    !multidimensional array.\n    \n    ! The '::' separators are not always necessary but are recommended.\n\n    ! many other variable attributes also exist:\n    real, pointer :: p    !declare a pointer.\n\n    integer, parameter :: LP = selected_real_kind(20)\n    real (kind = LP) :: d    !long precision variable.\n\n    ! WARNING: initialising variables during declaration causes problems\n    ! in functions since this automatically implies the 'save' attribute\n    ! whereby values are saved between function calls. In general, separate\n    ! declaration and initialisation code except for constants!\n    \n    \n    ! Strings\n    ! =======\n\n    character :: a_char = 'i'\n    character (len = 6) :: a_str = \"qwerty\"\n    character (len = 30) :: str_b\n    character (len = *), parameter :: a_long_str = \"This is a long string.\"\n    !can have automatic counting of length using (len=*) but only for constants.\n    \n    str_b = a_str // \" keyboard\"    !concatenate strings using // operator.\n\n\n    ! Assignment & Arithmetic\n    ! =======================\n\n    Z = 1    !assign to variable z declared above (case insensitive).\n    j = 10 + 2 - 3\n    a = 11.54  /  (2.3 * 3.1)\n    b = 2**3    !exponentiation\n\n\n    ! Control Flow Statements & Operators\n    ! ===================================\n\n    ! Single-line if statement\n    if (z == a) b = 4  !condition always need surrounding parentheses.\n\n    if (z /= a) then !z not equal to a\n    ! Other symbolic comparisons are < > <= >= == /=\n      b = 4\n    else if (z .GT. a) then !z greater than a\n    ! Text equivalents to symbol operators are .LT. .GT. .LE. .GE. .EQ. .NE.  \n      b = 6\n    else if (z < a) then !'then' must be on this line.\n      b = 5 !execution block must be on a new line.\n    else\n      b = 10\n    end if !end statement needs the 'if' (or can use 'endif').\n\n\n    if (.NOT. (x < c .AND. v >= a .OR. z == z)) then   !boolean operators.\n      inner: if (.TRUE.) then    !can name if-construct.\n        b = 1\n      endif inner    !then must name endif statement.\n    endif\n\n\n    i = 20\n    select case (i)\n      case (0)    !case i == 0\n        j=0\n      case (1:10)    !cases i is 1 to 10 inclusive.\n        j=1\n      case (11:)    !all cases where i>=11\n        j=2\n      case default\n        j=3\n    end select\n\n\n    month = 'jan'\n    ! Condition can be integer, logical or character type.\n    ! Select constructions can also be named.\n    monthly: select case (month)\n      case (\"jan\")\n         j = 0\n      case default\n         j = -1\n    end select monthly\n\n\n    do i=2,10,2    !loops from 2 to 10 (inclusive) in increments of 2.\n      innerloop: do j=1,3    !loops can be named too.\n        exit    !quits the loop.\n      end do innerloop\n    cycle    !jump to next loop iteration.\n    enddo\n\n    \n    ! Goto statement exists but it is heavily discouraged though.\n    goto 10    \n    stop 1    !stops code immediately (returning specified condition code).\n10  j = 201    !this line is labeled as line 10\n    \n    \n    ! Arrays\n    ! ======\n    array = (/1,2,3,4,5,6/)\n    array = [1,2,3,4,5,6]    !using Fortran 2003 notation.\n    arrayb = [10.2,3e3,0.41,4e-5]\n    array2d =  reshape([1.0,2.0,3.0,4.0,5.0,6.0], [3,2])\n    \n    ! Fortran array indexing starts from 1.\n    ! (by default but can be defined differently for specific arrays).\n    v = array(1)    !take first element of array.\n    v = array2d(2,2)\n    \n    print *, array(3:5)    !print all elements from 3rd to 5th (inclusive).\n    print *, array2d(1,:)    !print first column of 2d array.\n    \n    array = array*3 + 2    !can apply mathematical expressions to arrays.\n    array = array*array    !array operations occur element-wise.\n    !array = array*array2d    !these arrays would not be compatible.\n    \n    ! There are many built-in functions that operate on arrays.\n    c = dot_product(array,array)    !this is the dot product.\n    ! Use matmul() for matrix maths.\n    c = sum(array)\n    c = maxval(array)\n    print *, minloc(array)\n    c = size(array)\n    print *, shape(array)\n    m = count(array > 0)\n    \n    ! Loop over an array (could have used Product() function normally).\n    v = 1\n    do i = 1, size(array)\n        v = v*array(i)\n    end do\n    \n    ! Conditionally execute element-wise assignments.\n    array = [1,2,3,4,5,6]\n    where (array > 3)\n        array = array + 1\n    elsewhere (array == 2)\n        array = 1\n    elsewhere\n        array = 0\n    end where\n    \n    ! Implied-DO loops are a compact way to create arrays.\n    array = [ (i, i = 1,6) ]    !creates an array of [1,2,3,4,5,6]\n    array = [ (i, i = 1,12,2) ]    !creates an array of [1,3,5,7,9,11]\n    array = [ (i**2, i = 1,6) ]    !creates an array of  [1,4,9,16,25,36]\n    array = [ (4,5, i = 1,3) ]    !creates an array of [4,5,4,5,4,5]\n    \n\n    ! Input/Output\n    ! ============\n    \n    print *, b    !print the variable 'b' to the command line\n\n    ! We can format our printed output.\n    print \"(I6)\", 320    !prints '   320'\n    print \"(I6.4)\", 3    !prints '  0003' \n    print \"(F6.3)\", 4.32    !prints ' 4.320'\n    \n    ! The letter indicates the expected type and the number afterwards gives \n    ! the number of characters to use for printing the value.\n    ! Letters can be I (integer), F (real), E (engineering format), \n    ! L (logical), A (characters) ...\n    print \"(I3)\", 3200    !print '***' since the number doesn't fit.\n    \n    ! we can have multiple format specifications.\n    print \"(I5,F6.2,E6.2)\", 120, 43.41, 43.41\n    print \"(3I5)\", 10, 20, 30    !3 repeats of integers (field width = 5).\n    print \"(2(I5,F6.2))\", 120, 43.42, 340, 65.3   !repeated grouping of formats.\n\n    ! We can also read input from the terminal.\n    read *, v\n    read \"(2F6.2)\", v, x    !read two numbers\n\n    ! To read a file.\n    open(unit=11, file=\"records.txt\", status=\"old\") \n    ! The file is referred to by a 'unit number', an integer that you pick in\n    ! the range 9:99. Status can be one of {'old','replace','new'}.\n    read(unit=11, fmt=\"(3F10.2)\") a, b, c\n    close(11)\n\n    ! To write a file.\n    open(unit=12, file=\"records.txt\", status=\"replace\")\n    write(12, \"(F10.2,F10.2,F10.2)\") c, b, a\n    close(12)\n\n    ! There are more features available than discussed here and alternative \n    ! variants due to backwards compatibility with older Fortran versions.\n    \n    \n    ! Built-in Functions\n    ! ==================\n\n    ! Fortran has around 200 functions/subroutines intrinsic to the language.\n    ! Examples - \n    call cpu_time(v)    !sets 'v' to a time in seconds.\n    k = ior(i,j)    !bitwise OR of 2 integers.\n    v = log10(x)    !log base 10.\n    i = floor(b)    !returns the closest integer less than or equal to x.\n    v = aimag(w)    !imaginary part of a complex number.\n    \n\n    ! Functions & Subroutines\n    ! =======================\n    \n    ! A subroutine runs some code on some input values and can cause\n    ! side-effects or modify the input values.\n    \n    call routine(a,c,v)    !subroutine call.\n    \n    ! A function takes a list of input parameters and returns a single value.\n    ! However the input parameters may still be modified and side effects \n    ! executed.\n    \n    m = func(3,2,k)  !function call.\n    \n    ! Function calls can also be evoked within expressions.\n    Print *, func2(3,2,k) \n    \n    ! A pure function is a function that doesn't modify its input parameters\n    ! or cause any side-effects.\n    m = func3(3,2,k)\n\n\ncontains ! Zone for defining sub-programs internal to the program.\n\n    ! Fortran has a couple of slightly different ways to define functions.\n\n    integer function func(a,b,c)    !a function returning an integer value.\n        implicit none   !best to use implicit none in function definitions too.\n        integer :: a,b,c !type of input parameters defined inside the function.\n        if (a >= 2) then\n            func = a + b + c !the return variable defaults to the function name.\n            return !can return the current value from the function at any time.\n        endif\n        func = a + c\n        ! Don't need a return statement at the end of a function.\n    end function func\n\n\n    function func2(a,b,c) result(f)    !return variable declared to be 'f'.\n        implicit none\n        integer, intent(in) :: a,b    !can declare and enforce that variables \n                                      !are not modified by the function.\n        integer, intent(inout) :: c\n        integer :: f     !function return type declared inside the function.\n        integer :: cnt = 0    !GOTCHA - initialisation implies variable is\n                              !saved between function calls.\n        f = a + b - c\n        c = 4    !altering the value of an input variable.\n        cnt  = cnt + 1    !count number of function calls.\n    end function func2\n\n\n    pure function func3(a,b,c)  !a pure function can have no side-effects.\n        implicit none\n        integer, intent(in) :: a,b,c\n        integer :: func3\n        func3 = a*b*c\n    end function func3\n\n\n    subroutine routine(d,e,f)\n        implicit none\n        real, intent(inout) :: f\n        real, intent(in) :: d,e\n        f = 2*d + 3*e + f\n    end subroutine routine\n\n\nend program example   ! End of Program Definition -----------------------\n\n\n! Functions and Subroutines declared externally to the program listing need \n! to be declared to the program using an Interface declaration (even if they\n! are in the same source file!) (see below). It is easier to define them within\n! the 'contains' section of a module or program.\n\nelemental real function func4(a) result(res)\n! An elemental function is a Pure function that takes a scalar input variable\n! but can also be used on an array where it will be separately applied to all \n! of the elements of an array and return a new array.\n    real, intent(in) :: a\n    res = a**2 + 1.0\nend function func4\n\n\n! Modules\n! =======\n\n! A module is a useful way to collect related declarations, functions and \n! subroutines together for reusability.\n\nmodule fruit\n    real :: apple\n    real :: pear\n    real :: orange\nend module fruit\n\n\nmodule fruity\n    ! Declarations must be in the order: modules, interfaces, variables.\n    ! (can declare modules and interfaces in programs too).\n    \n    use fruit, only: apple, pear    ! use apple and pear from fruit module.\n    implicit none    !comes after module imports.\n\n    private    !make things private to the module (default is public).\n    ! Declare some variables/functions explicitly public.\n    public :: apple,mycar,create_mycar\n    ! Declare some variables/functions private to the module (redundant here).\n    private :: func4\n    \n    ! Interfaces\n    ! ==========\n    ! Explicitly declare an external function/procedure within the module\n    ! (better in general to put functions/procedures in the 'contains' section).\n    interface\n        elemental real function func4(a) result(res)\n            real, intent(in) :: a\n        end function func4\n    end interface\n    \n    ! Overloaded functions can be defined using named interfaces.\n    interface myabs\n        ! Can use 'module procedure' keyword to include functions already\n        ! defined within the module.\n        module procedure real_abs, complex_abs\n    end interface \n        \n    ! Derived Data Types\n    ! ==================\n    ! Can create custom structured data collections.\n    type car\n        character (len=100) :: model\n        real :: weight    !(kg)\n        real :: dimensions(3)    !i.e. length-width-height (metres).\n        character :: colour\n    end type car\n    \n    type(car) :: mycar    !declare a variable of your custom type.\n    ! See create_mycar() routine for usage.\n    \n    ! Note: There are no executable statements in modules.\n    \ncontains\n\n    subroutine create_mycar(mycar)\n        ! Demonstrates usage of a derived data type.\n        implicit none\n        type(car),intent(out) :: mycar\n        \n        ! Access type elements using '%' operator.\n        mycar%model = \"Ford Prefect\"\n        mycar%colour = 'r'\n        mycar%weight = 1400\n        mycar%dimensions(1) = 5.0    !default indexing starts from 1!\n        mycar%dimensions(2) = 3.0\n        mycar%dimensions(3) = 1.5\n        \n    end subroutine\n\n    real function real_abs(x)\n        real :: x\n        if (x<0) then\n            real_abs = -x\n        else\n            real_abs = x\n        end if\n    end function real_abs\n    \n    real function complex_abs(z)\n        complex :: z\n        ! long lines can be continued using the continuation character '&'\n        complex_abs = sqrt(real(z)**2 + &\n                                         aimag(z)**2)\n    end function complex_abs\n\n\nend module fruity\n\n```\n\n### More Resources\n\nFor more information on Fortran:\n\n+ [wikipedia](https://en.wikipedia.org/wiki/Fortran)\n+ [Fortran_95_language_features](https://en.wikipedia.org/wiki/Fortran_95_language_features)\n+ [fortranwiki.org](http://fortranwiki.org)\n+ [www.fortran90.org/](http://www.fortran90.org)\n+ [list of Fortran 95 tutorials](http://www.dmoz.org/Computers/Programming/Languages/Fortran/FAQs%2C_Help%2C_and_Tutorials/Fortran_90_and_95/)\n+ [Fortran wikibook](https://en.wikibooks.org/wiki/Fortran)\n+ [Fortran resources](http://www.fortranplus.co.uk/resources/fortran_resources.pdf)\n+ [Mistakes in Fortran 90 Programs That Might Surprise You](http://www.cs.rpi.edu/~szymansk/OOF90/bugs.html)"
