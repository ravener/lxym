
package pages

const Vala = "In GNOME's own words, \"Vala is a programming language that aims to bring modern programming language features to GNOME developers without imposing any additional runtime requirements and without using a different ABI compared to applications and libraries written in C.\"\n\nVala has aspects of Java and C#, so it'll be natural to those who know either.\n\n[Read more here.](https://wiki.gnome.org/Projects/Vala)\n\n```vala\n\n// Single line comment\n\n/* Multiline\nComment */\n\n/**\n* Documentation comment\n*/\n\n/* Data Types */\n\nchar character = 'a'\nunichar unicode_character = 'u' // 32-bit unicode character\n\nint i = 2; // ints can also have guaranteed sizes (e.g. int64, uint64)\nuint j = -6; // Won't compile; unsigned ints can only be positive\n\nlong k;\n\nshort l;\nushort m;\n\nstring text = \"Hello,\"; // Note that the == operator will check string content\n\nstring verbatim = \"\"\"This is a verbatim (a.k.a. raw) string. Special characters\n(e.g. \\n and \"\") are not interpreted. They may also be multiple lines long.\"\"\";\n\n// String Templates allow for easy string formatting\nstring string_template = @\"$text world\"; // \"$text\" evaluates to \"Hello,\"\n\nint test = 5;\nint test2 = 10;\nstring template2 = @\"$(test * test2) is a number.\"; // Expression evaluation\n\nstring template_slice = string_template[7:12]; // => \"world\"\n\n// Most data types have methods for parsing.\n\nbool parse_bool = bool.parse(\"false\"); // => false\nint parse_int = int.parse(\"-52\"); // => -52\nstring parse_string = parse_int.to_string(); // => \"-52\"\n\n/* Basic I/O */\n\nstdout.printf(parse_string); // Prints to console\nstring input = stdin.read_line(); // Gets input from console\n\nstderr.printf(\"Error message\"); // Error printing\n\n/* Arrays */\n\nint[] int_array = new int[10]; // Array of ints with 10 slots\nint better_int_array[10]; // Above expression, shortened\nint_array.length; // => 10;\n\nint[] int_array2 = {5, 10, 15, 20}; // Can be created on-the-fly\n\nint[] array_slice = int_array2[1:3]; // Slice (copy of data)\nunowned int[] array_slice_ref = int_array2[1:3]; // Reference to data\n\n// Multi-dimensional Arrays (defined with a number of commas in the brackets)\n\nint[,] multi_array = new int[6,4]; // 6 is the number of arrays, 4 is their size\nint[,] multi_array2 = {{7, 4, 6, 4},\n                       {3, 2, 4, 6},\n                       {5, 9, 5, 1}}; // new int[3,4]\nmulti_array2[2,3] = 12; // 2 is the array, 3 is the index in the array\nint first_d = multi_array2.length[0] // => 3\nint second_d = multi_array2.length[1] // => 4\n\n// Stacked arrays (e.g. int[][]) where array lengths vary are not supported.\n\n// Multi-dimensional arrays cannot be sliced, nor can they be converted to one-\n// dimensional.\n\nint[] add_to_array = {};\nadd_to_array += 12; // Arrays can be dynamically added to\n\nadd_to_array.resize(20); // Array now has 20 slots\n\nuint8[] chars = \"test message\".data;\nchars.move(5, 0, 7);\nstdout.printf((string) chars); // Casts the array to a string and prints it\n\n/* Control Flow */\n\nint a = 1;\nint b = 2;\nint[] foreach_demo = {2, 4, 6, 8};\n\nwhile (b > a) { // While loop; checks if expression is true before executing\n  b--;\n}\n\ndo {\n  b--;\n}\nwhile (b > a); // Do While loop; executes the code in \"do\" before while (b > a)\n\nfor (a = 0; a < 10; a++) { stdout.printf(\"%d\\n\", a); } // for loop\n\nforeach (int foreach_demo_var in foreach_demo) {\n  stdout.printf(\"%d\\n\", foreach_demo_var);\n} // foreach works on any iterable collection\n\nif (a == 0) {\n  stdout.printf(\"%d\\n\", a);\n} else if (a > 1) {\n  stdout.printf(\"%d\\n\", a);\n} else {\n  stdout.printf(\"A is less than 0\");\n} // if-then-else\n\nswitch (a) {\n  case 1:\n    stdout.printf(\"A is 1\\n\");\n    break;\n  case 5:\n  case 10:\n    stdout.printf(\"A is 5 or 10\\n\");\n    break;\n  default:\n    stdout.printf(\"???\\n\")\n    break;\n} // switch statement\n\n/* Type Casting and Inference */\n\nint cast_to_float = 10;\nfloat casted_float = (float) cast_to_float; // static casting; no runtime checks\n\n// For runtime checks, use dynamic casting.\n// Dynamically casted objects must be the following:\n// - Object's class is the same class as the desired type\n// - Object's class is a subclass of the desired type\n// - Desired class is an interface implemented by the object's class\n\nfloat dyna_casted_float = cast_to_float as float // Won't compile\n\nvar inferred_string = \"hello\"; // Type inference\n\n/* Methods (a.k.a. functions) */\n\nint method_demo(string arg1, Object arg2) { // Returns int and takes args\n    return 1;\n}\n\n// Vala methods cannot be overloaded.\n\nvoid some_method(string text) { }\nvoid some_method(int number) { }  // Won't compile\n\n// To achieve similar functionality, use default argument values.\n\nvoid some_better_method(string text, int number = 0) { }\n\nsome_better_method(\"text\");\nsome_better_method(\"text\", 12);\n\n// varargs (variable-length argument lists) are also supported.\n\nvoid method_with_varargs(int arg1, ...) {\n    var varargs_list = va_list(); // gets the varargs list\n\n    string arg_string = varargs_list.arg(); // gets arguments, one after another\n    int int_vararg = varargs_list.arg();\n\n    stdout.printf(\"%s, %d\\n\", arg_string, int_vararg)\n}\n\nstring? ok_to_be_null(int? test_int) { } // \"?\" denotes possible null value\n\n// Delegates\n\ndelegate void DelegateDemo(char char_a);\n\nvoid delegate_match(char char_a) { // Matches DelegateDemo's signature\n  stdout.printf(\"%d\\n\");\n}\n\nvoid call_delegate(DelegateDemo d, char char_b) { // Takes a delegate arg\n  d(char_b) // calls delegate\n}\n\nvoid final_delegate_demo() {\n  call_delegate(delegate_match); // Passes matching method as argument\n}\n\n// Lambdas (a.k.a. Anonymous Methods) are defined with \"=>\"\n\n(a) => { stdout.printf(\"%d\\n\", a); } // Prints \"a\"\n\n/* Namespaces */\n\nnamespace NamespaceDemo {\n  // Allows you to organize variable names\n  int namespace_int = 12;\n}\nnamespace_int += 5; // Won't compile\n\nusing NamespaceDemo;\nnamespace_int += 5; // Valid\n\n/* Structs and Enums */\n\nstruct Closet {\n  public uint shirts; // Default access modifier is private\n  public uint jackets;\n}\n\nCloset struct_init_1 = Closet(); // or Closet struct_init_1 = {};\nCloset struct_init_2 = {15, 3};\nvar struct_init_3 = Closet() { // Type inference also works\n  shirts = 15;\n  jackets = 3;\n}\n\nenum HouseSize { // An example of an enum\n  SMALL,\n  MODERATE,\n  BIG\n}\n\n/* Classes and Object-Oriented Programming */\n\nclass Message : GLib.Object { // Class Message extends GLib's Object\n  private string sender; // a private field\n  public string text {get; set;} // a public property (more on that later)\n  protected bool is_digital = true; // protected (this class and subclasses)\n  internal bool sent = false; // internal (classes in same package)\n\n  public void send(string sender) { // public method\n    this.sender = sender;\n    sent = true;\n  }\n\n  public Message() { // Constructor\n    // ...\n  }\n\n}\n\n// Since method overloading isn't possible, you can't overload constructors.\n// However, you can use named constructors to achieve the same functionality.\n\npublic class Calculator : GLib.Object {\n\n    public Calculator() {\n    }\n\n    public Calculator.with_name(string name) {\n    }\n\n    public Calculator.model(string model_id, string name = \"\") {\n      this.with_name(@\"$model_id $name\"); // Chained constructors with \"this\"\n    }\n    ~Calculator() { } // Only needed if you're using manual memory management\n}\n\nvar calc1 = new Calculator.with_name(\"Temp\");\nvar calc2 = new Calculator.model(\"TI-84\");\n\n// Signals (a.k.a. events or event listeners) are a way to execute multiple\n// methods with the same signature at the same time.\n\npublic class SignalDemo : GLib.Object {\n  public signal void sig_demo(int sig_demo_int); // Must be public\n\n  public static int main(string[] args) {\n    // main method; program does not compile without it\n\n    var sig_demo_class = new SignalDemo(); // New instance of class\n\n    sig_demo_class.sig_demo.connect((ob, sig_int) => { // Lambda used as handler\n        stdout.printf(\"%d\\n\", sig_int); // \"ob\" is object on which it is emitted\n      });\n\n    sig_demo_class.sig_demo(27); // Signal is emitted\n\n    return 0;\n  }\n}\n\n// You may use the connect() method and attach as many handlers as you'd like.\n// They'll all run at around the same time when the signal is emitted.\n\n// Properties (getters and setters)\n\nclass Animal : GLib.Object {\n  private int _legs; // prefixed with underscore to prevent name clashes\n\n  public int legs {\n    get { return _legs; }\n    set { _legs = value; }\n  }\n\n  public int eyes { get; set; default = 5; } // Shorter way\n  public int kingdom { get; private set; default = \"Animalia\"} // Read-only\n\n  public static void main(string args[]) {\n    rabbit = new Animal();\n\n    // All GLib.Objects have a signal \"notify\" emitted when a property changes.\n\n    // If you specify a specific property, replace all underscores with dashes\n    // to conform to the GObject naming convention.\n\n    rabbit.notify[\"eyes\"].connect((s, p) => { // Remove the [\"eyes\"] for all\n      stdout.printf(\"Property '%s' has changed!\\n\", p.name);\n    });\n\n    rabbit.legs = 2;\n    rabbit.legs += 2;\n    rabbit.eyes = 2;\n\n  }\n}\n\n// Inheritance: Vala classes may inherit 1 class. Inheritance is not implicit.\n\nclass SuperDemo : GLib.Object {\n  public int data1;\n  protected int data2;\n  internal int data3;\n  private int data4;\n\n  public static void test_method {  } // Statics can be called w/out an object\n}\nclass SubDemo : SuperDemo {\n  public static void main(string args[]) {\n    stdout.printf((string) data1); // Will compile\n    stdout.printf((string) data2); // Protected can be accessed by subclasses\n    stdout.printf((string) data3); // Internal is accessible to package\n    stdout.printf((string) data4); // Won't compile\n  }\n}\n\n// Abstract Classes and Methods\n\npublic abstract class OperatingSystem : GLib.Object {\n  public void turn_on() {\n    stdout.printf(\"Booted successfully.\\n\");\n  }\n  public abstract void use_computer();\n}\n\npublic class Linux : OperatingSystem {\n  public override void use_computer() { // Abstract methods must be overridden\n    stdout.printf(\"Beep boop\\n\");\n  }\n}\n\n// Add default behavior to an abstract method by making it \"virtual\".\n\npublic abstract class HardDrive : GLib.Object {\n  public virtual void die() {\n    stdout.printf(\"CLICK-CLICK-CLICK\\n\");\n  }\n}\npublic class MyHD : HardDrive {\n  public override void die() {\n    return;\n  }\n}\n\n// Interfaces: classes can implement any number of these.\n\ninterface Laptop { // May only contain abstracts or virtuals\n  public abstract void turn_on();\n  public abstract void turn_off();\n\n  public abstract int cores; // Won't compile; fields cannot be abstract\n  public abstract int cores {get; set;} // Will compile\n\n  public virtual void keyboard() { // Virtuals are allowed (unlike Java/C#)\n    stdout.printf(\"Clickity-clack\\n\");\n  }\n}\n\n// The ability to use virtuals in Vala means that multiple inheritance is\n// possible (albeit somewhat confined)\n\n// Interfaces cannot implement interfaces, but they may specify that certain\n// interfaces or classes must be also implemented (pre-requisites).\n\npublic interface CellPhone : Collection, GLib.Object {}\n\n// You can get the type info of a class at runtime dynamically.\n\nbool type_info = object is TypeName; // uses \"is\" to get a bool\n\nType type_info2 = object.get_type();\nvar type_name = type_info2.name();\n\nType type_info3 = typeof(Linux);\nLinux type_demo = (Linux) Object.new(type_info3);\n\n// Generics\n\nclass Computer<OperatingSystem> : GLib.Object {\n  private OperatingSystem os;\n\n  public void install_os(OperatingSystem os) {\n    this.os = os;\n  }\n  public OperatingSystem retrieve_os() {\n    return this.os;\n  }\n}\n\nvar new_computer = new Computer<Linux>();\n\n/* Other Features */\n\n// Assertions: crash if a statement is not true (at runtime)\n\nbool is_true = true;\nassert(is_true);\n\n// Contract Programming\n\nint contract_demo(int arg1, int arg2) {\n  requires(arg1 > 0 && arg1 < 10) // Notice the lack of semicolon\n  requires(arg2 >= 12)\n  ensures(result >= 0)\n}\n\n// Error Handling\n\nvoid error_demo(int int_ex) throws GError {\n  if (int_ex != 1) {\n    throw new GError(\"TEST MESSAGE\");\n  }\n}\nvoid error_demo2() {\n  try {\n    error_demo(0);\n  } catch (GError ge) {\n    stdout.printf(\"%s\\n\", ge.message);\n  }\n}\n\n// Main Loop\n\nvoid main() {\n\n  var main_loop = new MainLoop();\n  var time = new TimeoutSource(2000);\n\n  time.set_callback(() => { // Executes the following lambda after 2000ms\n      stdout.printf(\"2000ms have passed\\n\");\n      main_loop.quit();\n      return false;\n  });\n\n  time.attach(main_loop.get_context());\n\n  loop.run();\n}\n\n// Pointers (manual memory management)\n\nObject* pointer_obj = new Object(); // Creates Object instance and gives pointer\n\npointer_obj->some_method(); // Executes some_method\npointer_obj->some_data; // Returns some_data\n\ndelete pointer_obj;\n\nint more = 57;\nint* more_pointer = &i; // & = address-of\nint indirection_demo = more_pointer*; // indirection\n\n// Profiles: affect which Vala features are avaliable and which libraries the\n// C-code will use.\n// - gobject (default)\n// posix\n// dova\n// Use \"--profile=whatever\" when compiling.\n\n```\n* More Vala documentation can be found [here](https://valadoc.org/).\n* [Alternate construction syntax](https://wiki.gnome.org/Projects/Vala/Tutorial#GObject-Style_Construction) similar to GObject\n* More on contract programming [here](http://en.wikipedia.org/wiki/Contract_programming)\n* Collections library can be found [here](https://wiki.gnome.org/Projects/Vala/Tutorial#Collections)\n* [Multithreading](https://wiki.gnome.org/Projects/Vala/Tutorial#Multi-Threading)\n* Read about building GUIs with GTK+ and Vala [here](http://archive.is/7C7bw).\n* D-Bus [integration](https://wiki.gnome.org/Projects/Vala/Tutorial#D-Bus_Integration)"
