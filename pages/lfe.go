
package pages

const Lfe = "Lisp Flavoured Erlang(LFE) is a functional, concurrent, general-purpose programming \nlanguage and Lisp dialect(Lisp-2) built on top of Core Erlang and the Erlang Virtual Machine(BEAM). \n\nLFE can be obtained from [LFE](https://github.com/rvirding/lfe)\n\nThe classic starting point is [LFE DOCS.](http://docs.lfe.io)\n\nAnother new site is being built to replace it.[LFE DEV.](http://docs.lfe.io/dev)\n\n\n\n```lisp\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; 0. Syntax\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; General form.\n\n;; Lisp comprises of two syntax called: the ATOM and the S-expression.\n;; `forms` are known as grouped S-expressions.\n\n8  ; an atom; it evaluates to itself\n\n:ERLANG ;Atom; evaluates to the symbol :ERLANG.\n\nt  ; another atom which denotes true.\n\n(* 2 21) ; an S- expression\n\n'(8 :foo t)  ;another one\n\n\n;;; Comments\n\n;; Single line comments start with a semicolon; use two for normal\n;; comments, three for section comments, and four fo file-level\n;; comments.\n\n;; Block Comment\n\n   #| comment text |#\n\n;;; Environment\n\n;; LFE is the de-facto standard.\n\n;; Libraries can be used directly from the Erlang ecosystem. Rebar3 is the build tool.\n\n;; LFE is usually developed with a text editor(preferably Emacs) and a REPL\n;; (Read Evaluate Print Loop) running at the same time. The REPL \n;; allows for interactive exploration of the program as it is \"live\"\n;; in the system.\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; 1. Literals and Special Syntactic Rules\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; Integers\n\n1234 -123\t        ; Regular decimal notation\n#b0 #b10101\t        ; Binary notation\n#0 #10101\t        ; Binary notation (alternative form)\n#o377 #o-111\t    ; Octal notation\n#d123456789 #d+123\t; Explicitly decimal notation\n#xc0ffe 0x-01\t    ; Hexadecimal notation\n#2r1010 #8r377 \t    ;Notation with explicit base (up to 36)\n#\\a #$ #\\ä #\\🐭     ;Character notation (the value is the Unicode code point of the character)\n#\\x1f42d;\t        ;Character notation with the value in hexadecimal\n\n;;; Floating point numbers\n1.0 +2.0 -1.5 1.0e10 1.111e-10     \n\n;;; Strings\n\n\"any text between double quotes where \\\" and other special characters like \\n can be escaped\".\n; List String\n\"Cat: \\x1f639;\" ; writing unicode in string for regular font ending with semicolon.\n\n#\"This is a binary string \\n with some \\\"escaped\\\" and quoted (\\x1f639;) characters\"\n; Binary strings are just strings but function different in the VM. \n; Other ways of writing it are:  #B(\"a\"), #\"a\", and #B(97).\n\n\n;;; Character escaping\n\n\\b\t; => Backspace\n\\t\t; => Tab\n\\n\t; => Newline\n\\v\t; => Vertical tab\n\\f\t; => Form Feed\n\\r\t; => Carriage Return\n\\e\t; => Escape\n\\s\t; => Space\n\\d\t; => Delete\n\n;;; Binaries\n;; It is used to create binaries with any contents.\n#B((#\"a\" binary) (#\"b\" binary))\t               ; #\"ab\" (Evaluated form)\n\n;;; Lists are: () or (foo bar baz)\n\n;;; Tuples are written in: #(value1 value2 ...). Empty tuple #() is also valid.\n\n;;; Maps are written as: #M(key1 value1 key2 value2 ...). Empty map #M() is also valid.\n\n;;; Symbols: Things that cannot be parsed. Eg: foo, Foo, foo-bar, :foo\n| foo | ; explicit construction of symbol by wrapping vertical bars.\n\n;;; Evaluation \n\n;; #.(... some expression ...). E.g. '#.(+ 1 1) will evaluate the (+ 1 1) while it            ;; reads the expression and then be effectively '2.\n\n;; List comprehension in LFE REPL\n\nlfe> (list-comp\n          ((<- x '(0 1 2 3)))\n          (trunc (math:pow 3 x)))\n       (1 3 9 27)\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 2. Core forms\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; These forms are same as those found at Common Lisp and Scheme.\n\n(quote e)\n(cons head tail)\n(car e)\n(cdr e)\n(list e ... )\n(tuple e ... )\n(binary seg ... )\n(map key val ...), (map-get m k), (map-set m k v ...), (map-update m k v ...)\n\n(lambda (arg ...) ...)\n  (match-lambda\n    ((arg ... ) {{(when e ...)}} ...) ; Matches clauses\n    ... )\n(let ((pat {{(when e ...)}} e)\n      ...)\n  ... )\n(let-function ((name lambda|match-lambda) ; Only define local\n               ... )                      ; functions\n  ... )\n(letrec-function ((name lambda|match-lambda) ; Only define local\n                  ... )                      ; functions\n  ... )\n(let-macro ((name lambda-match-lambda) ; Only define local\n            ...)                       ; macros\n  ...)\n(progn ... )\n(if test true-expr {{false-expr}})\n(case e\n  (pat {{(when e ...)}} ...)\n   ... ))\n(receive\n  (pat {{(when e ...)}} ... )\n  ...\n  (after timeout ... ))\n(catch ... )\n(try\n  e\n  {{(case ((pat {{(when e ...)}} ... )\n          ... ))}}\n  {{(catch\n     ; Next must be tuple of length 3!\n     (((tuple type value ignore) {{(when e ...)}}\n      ... )\n     ... )}}\n  {{(after ... )}})\n\n(funcall func arg ... )\n(call mod func arg ... ) - Call to Erlang Mod:Func(Arg, ... )\n(define-module name declaration ... )\n(extend-module declaration ... ) - Define/extend module and declarations.\n(define-function name lambda|match-lambda)\n(define-macro name lambda|match-lambda) - Define functions/macros at top-level.\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 3. Macros\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Macros are part of the language to allow you to create abstractions \n;; on top of the core language and standard library that move you closer \n;; toward being able to directly express the things you want to express.\n\n;; Top-level function\n\n(defun name (arg ...) ...)\n\n;; Adding comments in functions\n\n(defun name\n  \"Toplevel function with pattern-matching arguments\"\n  ((argpat ...) ...)\n  ...)\n\n;; Top-level macro\n\n(defmacro name (arg ...) ...)\n(defmacro name arg ...)\n\n;; Top-level macro with pattern matching arguments\n\n(defmacro name\n  ((argpat ...) ...)\n  ...)\n\n;; Top-level macro using Scheme inspired syntax-rules format \n\n(defsyntax name\n  (pat exp)\n  ...)\n\n;;; Local macros in macro or syntax-rule format\n\n(macrolet ((name (arg ... ) ... )\n            ... )\n    ... )\n    \n(syntaxlet ((name (pat exp) ...)\n             ...)\n ...)\n\n;; Like CLISP\n\n(prog1 ...)\n(prog2 ...)\n\n;; Erlang LFE module\n\n(defmodule name ...)\n\n;; Erlang LFE record\n\n(defrecord name ...)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 4. Patterns and Guards\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Using patterns in LFE compared to that of Erlang\n\n;; Erlang                     ;; LFE\n;; {ok, X}                       (tuple 'ok x)\n;; error                         'error\n;; {yes, [X|Xs]}                 (tuple 'yes (cons x xs))\n;; <<34,F/float>>                (binary 34 (f float))\n;; [P|Ps]=All                    (= (cons p ps) all)\n\n  _    ; => is don't care while pattern matching\n  \n  (= pattern1 pattern2)     ; => easier, better version of pattern matching\n  \n;; Guards\n\n;; Whenever pattern occurs(let, case, receive, lc, etc) it can be followed by an optional\n;; guard which has the form (when test ...).\n\n(progn gtest ...)             ;; => Sequence of guard tests\n(if gexpr gexpr gexpr)\n(type-test e)\n(guard-bif ...)               ;; => Guard BIFs, arithmetic, boolean and comparison operators\n\n;;; REPL\n\nlfe>(set (tuple len status msg) #(8 ok \"Trillian\"))\n    #(8 ok \"Trillian\")\nlfe>msg\n    \"Trillian\"\n\n;;; Program illustrating use of Guards\n\n(defun right-number?\n        ((x) (when (orelse (== x 42) (== x 276709)))\n          'true)\n        ((_) 'false))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 5. Functions\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; A simple function using if.\n\n(defun max (x y)\n  \"The max function.\"\n  (if (>= x y) x y))\n\n;; Same function using more clause\n\n(defun max\n  \"The max function.\"\n  ((x y) (when (>= x y)) x)\n  ((x y) y))\n\n;; Same function using similar style but using local functions defined by flet or fletrec\n\n(defun foo (x y)\n  \"The max function.\"\n  (flet ((m (a b) \"Local comment.\"\n            (if (>= a b) a b)))\n    (m x y)))\n\n;; LFE being Lisp-2 has separate namespaces for variables and functions\n;; Both variables and function/macros are lexically scoped.\n;; Variables are bound by lambda, match-lambda and let.\n;; Functions are bound by top-level defun, flet and fletrec.\n;; Macros are bound by top-level defmacro/defsyntax and by macrolet/syntaxlet.\n\n;; (funcall func arg ...) like CL to call lambdas/match-lambdas \n;; (funs) bound to variables are used.\n\n;; separate bindings and special for apply.\napply _F (...), \napply _F/3 ( a1, a2, a3 )\n    \n;; Cons'ing in function heads\n(defun sum (l) (sum l 0))\n  (defun sum\n    (('() total) total)\n    (((cons h t) total) (sum t (+ h total))))\n    \n;; ``cons`` literal instead of constructor form\n      (defun sum (l) (sum l 0))\n      (defun sum\n        (('() total) total)\n        ((`(,h . ,t) total) (sum t (+ h total))))\n\n;; Matching records in function heads\n\n(defun handle_info\n  (('ping (= (match-state remote-pid 'undefined) state))\n    (gen_server:cast (self) 'ping)\n    `#(noreply ,state))\n  (('ping state)\n   `#(noreply ,state)))\n\n;; Receiving Messages\n      (defun universal-server ()\n        (receive\n          ((tuple 'become func)\n           (funcall func))))\n           \n;; another way for receiving messages\n\n (defun universal-server ()\n        (receive\n          (`#(become ,func)\n            (funcall func))))\n\n;; Composing a complete function for specific tasks\n\n(defun compose (f g)\n  (lambda (x)\n   (funcall f\n     (funcall g x))))\n\n(defun check ()\n  (let* ((sin-asin (compose #'sin/1 #'asin/1))\n         (expected (sin (asin 0.5)))\n         (compose-result (funcall sin-asin 0.5)))\n    (io:format \"Expected answer: ~p~n\" (list expected))\n    (io:format \"Answer with compose: ~p~n\" (list compose-result))))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 6. Concurrency\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Message passing as done by Erlang's light-weight \"processes\".\n\n(defmodule messenger-back\n (export (print-result 0) (send-message 2)))\n\n(defun print-result ()\n  (receive\n    ((tuple pid msg)\n      (io:format \"Received message: '~s'~n\" (list msg))\n      (io:format \"Sending message to process ~p ...~n\" (list pid))\n      (! pid (tuple msg))\n      (print-result))))\n\n(defun send-message (calling-pid msg)\n  (let ((spawned-pid (spawn 'messenger-back 'print-result ())))\n    (! spawned-pid (tuple calling-pid msg))))\n    \n;; Multiple simultaneous HTTP Requests:\n\n(defun parse-args (flag)\n  \"Given one or more command-line arguments, extract the passed values.\n\n  For example, if the following was passed via the command line:\n\n    $ erl -my-flag my-value-1 -my-flag my-value-2\n\n  One could then extract it in an LFE program by calling this function:\n\n    (let ((args (parse-args 'my-flag)))\n      ...\n      )\n  In this example, the value assigned to the arg variable would be a list\n  containing the values my-value-1 and my-value-2.\"\n  (let ((`#(ok ,data) (init:get_argument flag)))\n    (lists:merge data)))\n\n(defun get-pages ()\n  \"With no argument, assume 'url parameter was passed via command line.\"\n  (let ((urls (parse-args 'url)))\n    (get-pages urls)))\n\n(defun get-pages (urls)\n  \"Start inets and make (potentially many) HTTP requests.\"\n  (inets:start)\n  (plists:map\n    (lambda (x)\n      (get-page x)) urls))\n\n(defun get-page (url)\n  \"Make a single HTTP request.\"\n  (let* ((method 'get)\n         (headers '())\n         (request-data `#(,url ,headers))\n         (http-options ())\n         (request-options '(#(sync false))))\n    (httpc:request method request-data http-options request-options)\n    (receive\n      (`#(http #(,request-id #(error ,reason)))\n       (io:format \"Error: ~p~n\" `(,reason)))\n      (`#(http #(,request-id ,result))\n       (io:format \"Result: ~p~n\" `(,result))))))\n\n\n;; Check out Erlang's documentation for more concurrency and OTP docs.\n```\n\n## Further Reading\n\n*    [LFE DOCS](http://docs.lfe.io)\n*    [LFE GitBook](https://lfe.gitbooks.io/reference-guide/index.html)\n*    [LFE Wiki](https://en.wikipedia.org/wiki/LFE_(programming_language))\n\n## Extra Info\n*    [LFE PDF](http://www.erlang-factory.com/upload/presentations/61/Robertvirding-LispFlavouredErlang.pdf)\n*    [LFE mail](https://groups.google.com/d/msg/lisp-flavoured-erlang/XA5HeLbQQDk/TUHabZCHXB0J)\n\n## Credits\n\nLots of thanks to Robert Virding for creating LFE, Duncan McGreggor for documenting it and other LFE contributors who made LFE awesome."
