
package pages

const Neat = "Neat is basically a smaller version of D1 with some experimental syntax and a focus on terseness without losing the basic C-like syntax.\n\n[Read more here.](https://github.com/FeepingCreature/fcc/wiki)\n\n```c\n// single line comments start with //\n/*\n  multiline comments look like this\n*/\n/+\n  or this\n  /+ these can be nested too, same as D +/\n+/\n\n// Module name. This has to match the filename/directory.\nmodule LearnNeat;\n\n// Make names from another module visible in this one.\nimport std.file;\n// You can import multiple things at once.\nimport std.math, std.util;\n// You can even group up imports!\nimport std.(process, socket);\n\n// Global functions!\nvoid foo() { }\n\n// Main function, same as in C.\n// string[] == \"array of strings\".\n// \"string\" is just an alias for char[],\nvoid main(string[] args) {\n  // Call functions with \"function expression\".\n  writeln \"Hello World\";\n  // You can do it like in C too... if you really want.\n  writeln (\"Hello World\");\n  // Declare a variable with \"type identifier\"\n  string arg = (\"Hello World\");\n  writeln arg;\n  // (expression, expression) forms a tuple.\n  // There are no one-value tuples though.\n  // So you can always use () in the mathematical sense.\n  // (string) arg; <- is an error\n\n  /*\n    byte: 8 bit signed integer\n      char: 8 bit UTF-8 byte component.\n    short: 16 bit signed integer\n    int: 32 bit signed integer\n    long: 64 bit signed integer\n\n    float: 32 bit floating point\n    double: 64 bit floating point\n    real: biggest native size floating point (80 bit on x86).\n\n    bool: true or false\n  */\n  int a = 5;\n  bool b = true;\n  // as in C, && and || are short-circuit evaluating.\n  b = b && false;\n  assert(b == false);\n  // \"\" are \"format strings\". So $variable will be substituted at runtime\n  // with a formatted version of the variable.\n  writeln \"$a\";\n  // This will just print $a.\n  writeln `$a`;\n  // you can format expressions with $()\n  writeln \"$(2+2)\";\n  // Note: there is no special syntax for characters.\n  char c = \"a\";\n  // Cast values by using type: expression.\n  // There are three kinds of casts:\n  // casts that just specify conversions that would be happening automatically\n  // (implicit casts)\n  float f = float:5;\n  float f2 = 5; // would also work\n  // casts that require throwing away information or complicated computation -\n  // those must always be done explicitly\n  // (conversion casts)\n  int i = int:f;\n  // int i = f; // would not work!\n  // and, as a last attempt, casts that just reinterpret the raw data.\n  // Those only work if the types have the same size.\n  string s = \"Hello World\";\n  // Arrays are (length, pointer) pairs.\n  // This is a tuple type. Tuple types are (type, type, type).\n  // The type of a tuple expression is a tuple type. (duh)\n  (int, char*) array = (int, char*): s;\n  // You can index arrays and tuples using the expression[index] syntax.\n  writeln \"pointer is $(array[1]) and length is $(array[0])\";\n  // You can slice them using the expression[from .. to] syntax.\n  // Slicing an array makes another array.\n  writeln \"$(s[0..5]) World\";\n  // Alias name = expression gives the expression a name.\n  // As opposed to a variable, aliases do not have an address\n  // and can not be assigned to. (Unless the expression is assignable)\n  alias range = 0 .. 5;\n  writeln \"$(s[range]) World\";\n  // You can iterate over ranges.\n  for int i <- range {\n    write \"$(s[i])\";\n  }\n  writeln \" World\";\n  // Note that if \"range\" had been a variable, it would be 'empty' now!\n  // Range variables can only be iterated once.\n  // The syntax for iteration is \"expression <- iterable\".\n  // Lots of things are iterable.\n  for char c <- \"Hello\" { write \"$c\"; }\n  writeln \" World\";\n  // For loops are \"for test statement\";\n  alias test = char d <- \"Hello\";\n  for test write \"$d\";\n  writeln \" World\\t\\x05\"; // note: escapes work\n  // Pointers: function the same as in C, btw. The usual.\n  // Do note: the pointer star sticks with the TYPE, not the VARIABLE!\n  string* p;\n  assert(p == null); // default initializer\n  p = &s;\n  writeln \"$(*p)\";\n  // Math operators are (almost) standard.\n  int x = 2 + 3 * 4 << 5;\n  // Note: XOR is \"xor\". ^ is reserved for exponentiation (once I implement that).\n  int y = 3 xor 5;\n  int z = 5;\n  assert(z++ == 5);\n  assert(++z == 7);\n  writeln \"x $x y $y z $z\";\n  // As in D, ~ concatenates.\n  string hewo = \"Hello \" ~ \"World\";\n  // == tests for equality, \"is\" tests for identity.\n  assert  (hewo == s);\n  assert !(hewo is s);\n  // same as\n  assert  (hewo !is s);\n\n  // Allocate arrays using \"new array length\"\n  int[] integers = new int[] 10;\n  assert(integers.length == 10);\n  assert(integers[0] == 0); // zero is default initializer\n  integers = integers ~ 5; // This allocates a new array!\n  assert(integers.length == 11);\n\n  // This is an appender array.\n  // Instead of (length, pointer), it tracks (capacity, length, pointer).\n  // When you append to it, it will use the free capacity if it can.\n  // If it runs out of space, it reallocates - but it will free the old array automatically.\n  // This makes it convenient for building arrays.\n  int[auto~] appender;\n  appender ~= 2;\n  appender ~= 3;\n  appender.free(); // same as {mem.free(appender.ptr); appender = null;}\n\n  // Scope variables are automatically freed at the end of the current scope.\n  scope int[auto~] someOtherAppender;\n  // This is the same as:\n  int[auto~] someOtherAppender2;\n  onExit { someOtherAppender2.free; }\n\n  // You can do a C for loop too\n  // - but why would you want to?\n  for (int i = 0; i < 5; ++i) { }\n  // Otherwise, for and while are the same.\n  while int i <- 0..4 {\n    assert(i == 0);\n    break; // continue works too\n  } then assert(false); // if we hadn't break'd, this would run at the end\n  // This is the height of loopdom - the produce-test-consume loop.\n  do {\n    int i = 5;\n  } while (i == 5) {\n    assert(i == 5);\n    break; // otherwise we'd go back up to do {\n  }\n\n  // This is a nested function.\n  // Nested functions can access the surrounding function.\n  string returnS() { return s; }\n  writeln returnS();\n\n  // Take the address of a function using &\n  // The type of a global function is ReturnType function(ParameterTypeTuple).\n  void function() foop = &foo;\n\n  // Similarly, the type of a nested function is ReturnType delegate(ParameterTypeTuple).\n  string delegate() returnSp = &returnS;\n  writeln returnSp();\n  // Class member functions and struct member functions also fit into delegate variables.\n  // In general, delegates are functions that carry an additional context pointer.\n  // (\"fat pointers\" in C)\n\n  // Allocate a \"snapshot\" with \"new delegate\".\n  // Snapshots are not closures! I used to call them closures too,\n  // but then my Haskell-using friends yelled at me so I had to stop.\n  // The difference is that snapshots \"capture\" their surrounding context\n  // when \"new\" is used.\n  // This allows things like this\n  int delegate(int) add(int a) {\n    int add_a(int b) { return a + b; }\n    // This does not work - the context of add_a becomes invalid\n    // when add returns.\n    // return &add_a;\n    // Instead:\n    return new &add_a;\n  }\n  int delegate(int) dg = add 2;\n  assert (dg(3) == 5);\n  // or\n  assert (((add 2) 3) == 5);\n  // or\n  assert (add 2 3 == 5);\n  // add can also be written as\n  int delegate(int) add2(int a) {\n    // this is an implicit, nameless nested function.\n    return new λ(int b) { return a + b; }\n  }\n  // or even\n  auto add3(int a) { return new λ(int b) -> a + b; }\n  // hahahaaa\n  auto add4 = λ(int a) -> new λ(int b) -> a + b;\n  assert(add4 2 3 == 5);\n  // If your keyboard doesn't have a λ (you poor sod)\n  // you can use \\ too.\n  auto add5 = \\(int a) -> new \\(int b) -> a + b;\n  // Note!\n  auto nestfun = λ() { } // There is NO semicolon needed here!\n  // \"}\" can always substitute for \"};\".\n  // This provides syntactic consistency with built-in statements.\n\n\n  // This is a class.\n  // Note: almost all elements of Neat can be used on the module level\n  //       or just as well inside a function.\n  class C {\n    int a;\n    void writeA() { writeln \"$a\"; }\n    // It's a nested class - it exists in the context of main().\n    // so if you leave main(), any instances of C become invalid.\n    void writeS() { writeln \"$s\"; }\n  }\n  C cc = new C;\n  // cc is a *reference* to C. Classes are always references.\n  cc.a = 5; // Always used for property access.\n  auto ccp = &cc;\n  (*ccp).a = 6;\n  // or just\n  ccp.a = 7;\n  cc.writeA();\n  cc.writeS(); // to prove I'm not making things up\n  // Interfaces work same as in D, basically. Or Java.\n  interface E { void doE(); }\n  // Inheritance works same as in D, basically. Or Java.\n  class D : C, E {\n    override void writeA() { writeln \"hahahahaha no\"; }\n    override void doE() { writeln \"eeeee\"; }\n    // all classes inherit from Object. (toString is defined in Object)\n    override string toString() { return \"I am a D\"; }\n  }\n  C cd = new D;\n  // all methods are always virtual.\n  cd.writeA();\n  E e = E:cd; // dynamic class cast!\n  e.doE();\n  writeln \"$e\"; // all interfaces convert to Object implicitly.\n\n  // Templates!\n  // Templates are parameterized namespaces, taking a type as a parameter.\n  template Templ(T) {\n    alias hi = 5, hii = 8;\n    // Templates always have to include something with the same name as the template\n    // - this will become the template's _value_.\n    // Static ifs are evaluated statically, at compile-time.\n    // Because of this, the test has to be a constant expression,\n    // or something that can be optimized to a constant.\n    static if (types-equal (T, int)) {\n      alias Templ = hi;\n    } else {\n      alias Templ = hii;\n    }\n  }\n  assert(Templ!int == 5);\n  assert(Templ!float == 8);\n}\n```\n\n## Topics Not Covered\n\n * Extended iterator types and expressions\n * Standard library\n * Conditions (error handling)\n * Macros"
