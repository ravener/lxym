
package pages

const Rust = "Rust is a programming language developed by Mozilla Research.\nRust combines low-level control over performance with high-level convenience and\nsafety guarantees.\n\nIt achieves these goals without requiring a garbage collector or runtime, making\nit possible to use Rust libraries as a \"drop-in replacement\" for C.\n\nRust’s first release, 0.1, occurred in January 2012, and for 3 years development\nmoved so quickly that until recently the use of stable releases was discouraged\nand instead the general advice was to use nightly builds.\n\nOn May 15th 2015, Rust 1.0 was released with a complete guarantee of backward\ncompatibility. Improvements to compile times and other aspects of the compiler are\ncurrently available in the nightly builds. Rust has adopted a train-based release\nmodel with regular releases every six weeks. Rust 1.1 beta was made available at\nthe same time of the release of Rust 1.0.\n\nAlthough Rust is a relatively low-level language, it has some functional\nconcepts that are generally found in higher-level languages. This makes\nRust not only fast, but also easy and efficient to code in.\n\n```rust\n// This is a comment. Line comments look like this...\n// and extend multiple lines like this.\n\n/// Documentation comments look like this and support markdown notation.\n/// # Examples\n///\n/// ```\n/// let five = 5\n/// ```\n\n///////////////\n// 1. Basics //\n///////////////\n\n#[allow(dead_code)]\n// Functions\n// `i32` is the type for 32-bit signed integers\nfn add2(x: i32, y: i32) -> i32 {\n    // Implicit return (no semicolon)\n    x + y\n}\n\n#[allow(unused_variables)]\n#[allow(unused_assignments)]\n#[allow(dead_code)]\n// Main function\nfn main() {\n    // Numbers //\n\n    // Immutable bindings\n    let x: i32 = 1;\n\n    // Integer/float suffixes\n    let y: i32 = 13i32;\n    let f: f64 = 1.3f64;\n\n    // Type inference\n    // Most of the time, the Rust compiler can infer what type a variable is, so\n    // you don’t have to write an explicit type annotation.\n    // Throughout this tutorial, types are explicitly annotated in many places,\n    // but only for demonstrative purposes. Type inference can handle this for\n    // you most of the time.\n    let implicit_x = 1;\n    let implicit_f = 1.3;\n\n    // Arithmetic\n    let sum = x + y + 13;\n\n    // Mutable variable\n    let mut mutable = 1;\n    mutable = 4;\n    mutable += 2;\n\n    // Strings //\n\n    // String literals\n    let x: &str = \"hello world!\";\n\n    // Printing\n    println!(\"{} {}\", f, x); // 1.3 hello world\n\n    // A `String` – a heap-allocated string\n    let s: String = \"hello world\".to_string();\n\n    // A string slice – an immutable view into another string\n    // The string buffer can be statically allocated like in a string literal\n    // or contained in another object (in this case, `s`)\n    let s_slice: &str = &s;\n\n    println!(\"{} {}\", s, s_slice); // hello world hello world\n\n    // Vectors/arrays //\n\n    // A fixed-size array\n    let four_ints: [i32; 4] = [1, 2, 3, 4];\n\n    // A dynamic array (vector)\n    let mut vector: Vec<i32> = vec![1, 2, 3, 4];\n    vector.push(5);\n\n    // A slice – an immutable view into a vector or array\n    // This is much like a string slice, but for vectors\n    let slice: &[i32] = &vector;\n\n    // Use `{:?}` to print something debug-style\n    println!(\"{:?} {:?}\", vector, slice); // [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]\n\n    // Tuples //\n\n    // A tuple is a fixed-size set of values of possibly different types\n    let x: (i32, &str, f64) = (1, \"hello\", 3.4);\n\n    // Destructuring `let`\n    let (a, b, c) = x;\n    println!(\"{} {} {}\", a, b, c); // 1 hello 3.4\n\n    // Indexing\n    println!(\"{}\", x.1); // hello\n\n    //////////////\n    // 2. Types //\n    //////////////\n\n    // Struct\n    struct Point {\n        x: i32,\n        y: i32,\n    }\n\n    let origin: Point = Point { x: 0, y: 0 };\n\n    // A struct with unnamed fields, called a ‘tuple struct’\n    struct Point2(i32, i32);\n\n    let origin2 = Point2(0, 0);\n\n    // Basic C-like enum\n    enum Direction {\n        Left,\n        Right,\n        Up,\n        Down,\n    }\n\n    let up = Direction::Up;\n\n    // Enum with fields\n    enum OptionalI32 {\n        AnI32(i32),\n        Nothing,\n    }\n\n    let two: OptionalI32 = OptionalI32::AnI32(2);\n    let nothing = OptionalI32::Nothing;\n\n    // Generics //\n\n    struct Foo<T> { bar: T }\n\n    // This is defined in the standard library as `Option`\n    enum Optional<T> {\n        SomeVal(T),\n        NoVal,\n    }\n\n    // Methods //\n\n    impl<T> Foo<T> {\n        // Methods take an explicit `self` parameter\n        fn bar(&self) -> &T { // self is borrowed\n            &self.bar\n        }\n        fn bar_mut(&mut self) -> &mut T { // self is mutably borrowed\n            &mut self.bar\n        }\n        fn into_bar(self) -> T { // here self is consumed\n            self.bar\n        }\n    }\n\n    let a_foo = Foo { bar: 1 };\n    println!(\"{}\", a_foo.bar()); // 1\n\n    // Traits (known as interfaces or typeclasses in other languages) //\n\n    trait Frobnicate<T> {\n        fn frobnicate(self) -> Option<T>;\n    }\n\n    impl<T> Frobnicate<T> for Foo<T> {\n        fn frobnicate(self) -> Option<T> {\n            Some(self.bar)\n        }\n    }\n\n    let another_foo = Foo { bar: 1 };\n    println!(\"{:?}\", another_foo.frobnicate()); // Some(1)\n\n    /////////////////////////\n    // 3. Pattern matching //\n    /////////////////////////\n\n    let foo = OptionalI32::AnI32(1);\n    match foo {\n        OptionalI32::AnI32(n) => println!(\"it’s an i32: {}\", n),\n        OptionalI32::Nothing  => println!(\"it’s nothing!\"),\n    }\n\n    // Advanced pattern matching\n    struct FooBar { x: i32, y: OptionalI32 }\n    let bar = FooBar { x: 15, y: OptionalI32::AnI32(32) };\n\n    match bar {\n        FooBar { x: 0, y: OptionalI32::AnI32(0) } =>\n            println!(\"The numbers are zero!\"),\n        FooBar { x: n, y: OptionalI32::AnI32(m) } if n == m =>\n            println!(\"The numbers are the same\"),\n        FooBar { x: n, y: OptionalI32::AnI32(m) } =>\n            println!(\"Different numbers: {} {}\", n, m),\n        FooBar { x: _, y: OptionalI32::Nothing } =>\n            println!(\"The second number is Nothing!\"),\n    }\n\n    /////////////////////\n    // 4. Control flow //\n    /////////////////////\n\n    // `for` loops/iteration\n    let array = [1, 2, 3];\n    for i in array.iter() {\n        println!(\"{}\", i);\n    }\n\n    // Ranges\n    for i in 0u32..10 {\n        print!(\"{} \", i);\n    }\n    println!(\"\");\n    // prints `0 1 2 3 4 5 6 7 8 9 `\n\n    // `if`\n    if 1 == 1 {\n        println!(\"Maths is working!\");\n    } else {\n        println!(\"Oh no...\");\n    }\n\n    // `if` as expression\n    let value = if true {\n        \"good\"\n    } else {\n        \"bad\"\n    };\n\n    // `while` loop\n    while 1 == 1 {\n        println!(\"The universe is operating normally.\");\n        // break statement gets out of the while loop.\n        //  It avoids useless iterations.\n        break\n    }\n\n    // Infinite loop\n    loop {\n        println!(\"Hello!\");\n        // break statement gets out of the loop\n        break\n    }\n\n    /////////////////////////////////\n    // 5. Memory safety & pointers //\n    /////////////////////////////////\n\n    // Owned pointer – only one thing can ‘own’ this pointer at a time\n    // This means that when the `Box` leaves its scope, it can be automatically deallocated safely.\n    let mut mine: Box<i32> = Box::new(3);\n    *mine = 5; // dereference\n    // Here, `now_its_mine` takes ownership of `mine`. In other words, `mine` is moved.\n    let mut now_its_mine = mine;\n    *now_its_mine += 2;\n\n    println!(\"{}\", now_its_mine); // 7\n    // println!(\"{}\", mine); // this would not compile because `now_its_mine` now owns the pointer\n\n    // Reference – an immutable pointer that refers to other data\n    // When a reference is taken to a value, we say that the value has been ‘borrowed’.\n    // While a value is borrowed immutably, it cannot be mutated or moved.\n    // A borrow is active until the last use of the borrowing variable.\n    let mut var = 4;\n    var = 3;\n    let ref_var: &i32 = &var;\n\n    println!(\"{}\", var); // Unlike `mine`, `var` can still be used\n    println!(\"{}\", *ref_var);\n    // var = 5; // this would not compile because `var` is borrowed\n    // *ref_var = 6; // this would not either, because `ref_var` is an immutable reference\n    ref_var; // no-op, but counts as a use and keeps the borrow active\n    var = 2; // ref_var is no longer used after the line above, so the borrow has ended\n\n    // Mutable reference\n    // While a value is mutably borrowed, it cannot be accessed at all.\n    let mut var2 = 4;\n    let ref_var2: &mut i32 = &mut var2;\n    *ref_var2 += 2;         // '*' is used to point to the mutably borrowed var2\n\n    println!(\"{}\", *ref_var2); // 6 , // var2 would not compile.\n    // ref_var2 is of type &mut i32, so stores a reference to an i32, not the value.\n    // var2 = 2; // this would not compile because `var2` is borrowed.\n    ref_var2; // no-op, but counts as a use and keeps the borrow active until here\n}\n```\n\n## Further reading\n\nThere’s a lot more to Rust—this is just the basics of Rust so you can understand\nthe most important things. To learn more about Rust, read [The Rust Programming\nLanguage](http://doc.rust-lang.org/book/index.html) and check out the\n[/r/rust](http://reddit.com/r/rust) subreddit. The folks on the #rust channel on\nirc.mozilla.org are also always keen to help newcomers.\n\nYou can also try out features of Rust with an online compiler at the official\n[Rust playpen](http://play.rust-lang.org) or on the main\n[Rust website](http://rust-lang.org)."
