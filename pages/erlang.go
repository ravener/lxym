
package pages

const Erlang = "```erlang\n% Percent sign starts a one-line comment.\n\n%% Two percent characters shall be used to comment functions.\n\n%%% Three percent characters shall be used to comment modules.\n\n% We use three types of punctuation in Erlang.\n% Commas (`,`) separate arguments in function calls, data constructors, and\n% patterns.\n% Periods (`.`) (followed by whitespace) separate entire functions and\n% expressions in the shell.\n% Semicolons (`;`) separate clauses. We find clauses in several contexts:\n% function definitions and in `case`, `if`, `try..catch`, and `receive`\n% expressions.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% 1. Variables and pattern matching.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% In Erlang new variables are bound with an `=` statement.\nNum = 42.  % All variable names must start with an uppercase letter.\n\n% Erlang has single-assignment variables; if you try to assign a different\n% value to the variable `Num`, you’ll get an error.\nNum = 43. % ** exception error: no match of right hand side value 43\n\n% In most languages, `=` denotes an assignment statement. In Erlang, however,\n% `=` denotes a pattern-matching operation. When an empty variable is used on the\n% left hand side of the `=` operator to is bound (assigned), but when a bound\n% variable is used on the left hand side the following behaviour is observed.\n% `Lhs = Rhs` really means this: evaluate the right side (`Rhs`), and then\n% match the result against the pattern on the left side (`Lhs`).\nNum = 7 * 6.\n\n% Floating-point number.\nPi = 3.14159.\n\n% Atoms are used to represent different non-numerical constant values. Atoms\n% start with lowercase letters, followed by a sequence of alphanumeric\n% characters or the underscore (`_`) or at (`@`) sign.\nHello = hello.\nOtherNode = example@node.\n\n% Atoms with non alphanumeric values can be written by enclosing the atoms\n% with apostrophes.\nAtomWithSpace = 'some atom with space'.\n\n% Tuples are similar to structs in C.\nPoint = {point, 10, 45}.\n\n% If we want to extract some values from a tuple, we use the pattern-matching\n% operator `=`.\n{point, X, Y} = Point.  % X = 10, Y = 45\n\n% We can use `_` as a placeholder for variables that we’re not interested in.\n% The symbol `_` is called an anonymous variable. Unlike regular variables,\n% several occurrences of `_` in the same pattern don’t have to bind to the\n% same value.\nPerson = {person, {name, {first, joe}, {last, armstrong}}, {footsize, 42}}.\n{_, {_, {_, Who}, _}, _} = Person.  % Who = joe\n\n% We create a list by enclosing the list elements in square brackets and\n% separating them with commas.\n% The individual elements of a list can be of any type.\n% The first element of a list is the head of the list. If you imagine removing\n% the head from the list, what’s left is called the tail of the list.\nThingsToBuy = [{apples, 10}, {pears, 6}, {milk, 3}].\n\n% If `T` is a list, then `[H|T]` is also a list, with head `H` and tail `T`.\n% The vertical bar (`|`) separates the head of a list from its tail.\n% `[]` is the empty list.\n% We can extract elements from a list with a pattern-matching operation. If we\n% have a nonempty list `L`, then the expression `[X|Y] = L`, where `X` and `Y`\n% are unbound variables, will extract the head of the list into `X` and the tail\n% of the list into `Y`.\n[FirstThing|OtherThingsToBuy] = ThingsToBuy.\n% FirstThing = {apples, 10}\n% OtherThingsToBuy = [{pears, 6}, {milk, 3}]\n\n% There are no strings in Erlang. Strings are really just lists of integers.\n% Strings are enclosed in double quotation marks (`\"`).\nName = \"Hello\".\n[72, 101, 108, 108, 111] = \"Hello\".\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% 2. Sequential programming.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Modules are the basic unit of code in Erlang. All the functions we write are\n% stored in modules. Modules are stored in files with `.erl` extensions.\n% Modules must be compiled before the code can be run. A compiled module has the\n% extension `.beam`.\n-module(geometry).\n-export([area/1]). % the list of functions exported from the module.\n\n% The function `area` consists of two clauses. The clauses are separated by a\n% semicolon, and the final clause is terminated by dot-whitespace.\n% Each clause has a head and a body; the head consists of a function name\n% followed by a pattern (in parentheses), and the body consists of a sequence of\n% expressions, which are evaluated if the pattern in the head is successfully\n% matched against the calling arguments. The patterns are matched in the order\n% they appear in the function definition.\narea({rectangle, Width, Ht}) -> Width * Ht;\narea({circle, R})            -> 3.14159 * R * R.\n\n% Compile the code in the file geometry.erl.\nc(geometry).  % {ok,geometry}\n\n% We need to include the module name together with the function name in order to\n% identify exactly which function we want to call.\ngeometry:area({rectangle, 10, 5}).  % 50\ngeometry:area({circle, 1.4}).  % 6.15752\n\n% In Erlang, two functions with the same name and different arity (number of\n% arguments) in the same module represent entirely different functions.\n-module(lib_misc).\n-export([sum/1]). % export function `sum` of arity 1\n                  % accepting one argument: list of integers.\nsum(L) -> sum(L, 0).\nsum([], N)    -> N;\nsum([H|T], N) -> sum(T, H+N).\n\n% Funs are \"anonymous\" functions. They are called this way because they have\n% no name. However, they can be assigned to variables.\nDouble = fun(X) -> 2 * X end. % `Double` points to an anonymous function\n                              % with handle: #Fun<erl_eval.6.17052888>\nDouble(2).  % 4\n\n% Functions accept funs as their arguments and can return funs.\nMult = fun(Times) -> ( fun(X) -> X * Times end ) end.\nTriple = Mult(3).\nTriple(5).  % 15\n\n% List comprehensions are expressions that create lists without having to use\n% funs, maps, or filters.\n% The notation `[F(X) || X <- L]` means \"the list of `F(X)` where `X` is taken\n% from the list `L`.\"\nL = [1,2,3,4,5].\n[2 * X || X <- L].  % [2,4,6,8,10]\n% A list comprehension can have generators and filters, which select subset of\n% the generated values.\nEvenNumbers = [N || N <- [1, 2, 3, 4], N rem 2 == 0]. % [2, 4]\n\n% Guards are constructs that we can use to increase the power of pattern\n% matching. Using guards, we can perform simple tests and comparisons on the\n% variables in a pattern.\n% You can use guards in the heads of function definitions where they are\n% introduced by the `when` keyword, or you can use them at any place in the\n% language where an expression is allowed.\nmax(X, Y) when X > Y -> X;\nmax(X, Y) -> Y.\n\n% A guard is a series of guard expressions, separated by commas (`,`).\n% The guard `GuardExpr1, GuardExpr2, ..., GuardExprN` is true if all the guard\n% expressions `GuardExpr1`, `GuardExpr2`, ..., `GuardExprN` evaluate to `true`.\nis_cat(A) when is_atom(A), A =:= cat -> true;\nis_cat(A) -> false.\nis_dog(A) when is_atom(A), A =:= dog -> true;\nis_dog(A) -> false.\n\n% We won't dwell on the `=:=` operator here; just be aware that it is used to\n% check whether two Erlang expressions have the same value *and* the same type.\n% Contrast this behaviour to that of the `==` operator:\n1 + 2 =:= 3.   % true\n1 + 2 =:= 3.0. % false\n1 + 2 ==  3.0. % true\n\n% A guard sequence is either a single guard or a series of guards, separated\n% by semicolons (`;`). The guard sequence `G1; G2; ...; Gn` is true if at\n% least one of the guards `G1`, `G2`, ..., `Gn` evaluates to `true`.\nis_pet(A) when is_atom(A), (A =:= dog);(A =:= cat) -> true;\nis_pet(A)                                             -> false.\n\n% Warning: not all valid Erlang expressions can be used as guard expressions;\n% in particular, our `is_cat` and `is_dog` functions cannot be used within the\n% guard sequence in `is_pet`'s definition. For a description of the\n% expressions allowed in guard sequences, refer to the specific section\n% in the Erlang reference manual:\n% http://erlang.org/doc/reference_manual/expressions.html#guards\n\n\n% Records provide a method for associating a name with a particular element in a\n% tuple.\n% Record definitions can be included in Erlang source code files or put in files\n% with the extension `.hrl`, which are then included by Erlang source code\n% files.\n-record(todo, {\n  status = reminder,  % Default value\n  who = joe,\n  text\n}).\n\n% We have to read the record definitions into the shell before we can define a\n% record. We use the shell function `rr` (short for read records) to do this.\nrr(\"records.hrl\").  % [todo]\n\n% Creating and updating records:\nX = #todo{}.\n% #todo{status = reminder, who = joe, text = undefined}\nX1 = #todo{status = urgent, text = \"Fix errata in book\"}.\n% #todo{status = urgent, who = joe, text = \"Fix errata in book\"}\nX2 = X1#todo{status = done}.\n% #todo{status = done, who = joe, text = \"Fix errata in book\"}\n\n% `case` expressions.\n% `filter` returns a list of all elements `X` in a list `L` for which `P(X)` is\n% true.\nfilter(P, [H|T]) ->\n  case P(H) of\n    true -> [H|filter(P, T)];\n    false -> filter(P, T)\n  end;\nfilter(P, []) -> [].\nfilter(fun(X) -> X rem 2 == 0 end, [1, 2, 3, 4]). % [2, 4]\n\n% `if` expressions.\nmax(X, Y) ->\n  if\n    X > Y -> X;\n    X < Y -> Y;\n    true -> nil\n  end.\n\n% Warning: at least one of the guards in the `if` expression must evaluate to\n% `true`; otherwise, an exception will be raised.\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% 3. Exceptions.\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Exceptions are raised by the system when internal errors are encountered or\n% explicitly in code by calling `throw(Exception)`, `exit(Exception)`, or\n% `erlang:error(Exception)`.\ngenerate_exception(1) -> a;\ngenerate_exception(2) -> throw(a);\ngenerate_exception(3) -> exit(a);\ngenerate_exception(4) -> {'EXIT', a};\ngenerate_exception(5) -> erlang:error(a).\n\n% Erlang has two methods of catching an exception. One is to enclose the call to\n% the function that raises the exception within a `try...catch` expression.\ncatcher(N) ->\n  try generate_exception(N) of\n    Val -> {N, normal, Val}\n  catch\n    throw:X -> {N, caught, thrown, X};\n    exit:X -> {N, caught, exited, X};\n    error:X -> {N, caught, error, X}\n  end.\n\n% The other is to enclose the call in a `catch` expression. When you catch an\n% exception, it is converted into a tuple that describes the error.\ncatcher(N) -> catch generate_exception(N).\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% 4. Concurrency\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Erlang relies on the actor model for concurrency. All we need to write\n% concurrent programs in Erlang are three primitives: spawning processes,\n% sending messages and receiving messages.\n\n% To start a new process, we use the `spawn` function, which takes a function\n% as argument.\n\nF = fun() -> 2 + 2 end. % #Fun<erl_eval.20.67289768>\nspawn(F). % <0.44.0>\n\n% `spawn` returns a pid (process identifier); you can use this pid to send\n% messages to the process. To do message passing, we use the `!` operator.\n% For all of this to be useful, we need to be able to receive messages. This is\n% achieved with the `receive` mechanism:\n\n-module(calculateGeometry).\n-compile(export_all).\ncalculateArea() ->\n    receive\n      {rectangle, W, H} ->\n        W * H;\n      {circle, R} ->\n        3.14 * R * R;\n      _ ->\n        io:format(\"We can only calculate area of rectangles or circles.\")\n    end.\n\n% Compile the module and create a process that evaluates `calculateArea` in the\n% shell.\nc(calculateGeometry).\nCalculateArea = spawn(calculateGeometry, calculateArea, []).\nCalculateArea ! {circle, 2}. % 12.56000000000000049738\n\n% The shell is also a process; you can use `self` to get the current pid.\nself(). % <0.41.0>\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% 5. Testing with EUnit\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Unit tests can be written using EUnits's test generators and assert macros\n-module(fib).\n-export([fib/1]).\n-include_lib(\"eunit/include/eunit.hrl\").\n\nfib(0) -> 1;\nfib(1) -> 1;\nfib(N) when N > 1 -> fib(N-1) + fib(N-2).\n\nfib_test_() ->\n    [?_assert(fib(0) =:= 1),\n     ?_assert(fib(1) =:= 1),\n     ?_assert(fib(2) =:= 2),\n     ?_assert(fib(3) =:= 3),\n     ?_assert(fib(4) =:= 5),\n     ?_assert(fib(5) =:= 8),\n     ?_assertException(error, function_clause, fib(-1)),\n     ?_assert(fib(31) =:= 2178309)\n    ].\n\n% EUnit will automatically export to a test() function to allow running the tests\n% in the erlang shell\nfib:test()\n\n% The popular erlang build tool Rebar is also compatible with EUnit\n% ```\n% rebar eunit\n% ```\n\n```\n\n## References\n\n* [\"Learn You Some Erlang for great good!\"](http://learnyousomeerlang.com/)\n* [\"Programming Erlang: Software for a Concurrent World\" by Joe Armstrong](http://pragprog.com/book/jaerlang/programming-erlang)\n* [Erlang/OTP Reference Documentation](http://www.erlang.org/doc/)\n* [Erlang - Programming Rules and Conventions](http://www.erlang.se/doc/programming_rules.shtml)"
