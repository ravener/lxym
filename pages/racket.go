
package pages

const Racket = "Racket is a general purpose, multi-paradigm programming language in the Lisp/Scheme family.\n\nFeedback is appreciated! You can reach me at [@th3rac25](http://twitter.com/th3rac25) or th3rac25 [at] [google's email service]\n\n\n```racket\n#lang racket ; defines the language we are using\n\n;;; Comments\n\n;; Single line comments start with a semicolon\n\n#| Block comments\n   can span multiple lines and...\n    #|\n       they can be nested!\n    |#\n|#\n\n;; S-expression comments discard the following expression,\n;; useful to comment expressions when debugging\n#; (this expression is discarded)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 1. Primitive Datatypes and Operators\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; Numbers\n9999999999999999999999 ; integers\n#b111                  ; binary => 7\n#o111                  ; octal => 73\n#x111                  ; hexadecimal => 273\n3.14                   ; reals\n6.02e+23\n1/2                    ; rationals\n1+2i                   ; complex numbers\n\n;; Function application is written (f x y z ...)\n;; where f is a function and x, y, z, ... are operands\n;; If you want to create a literal list of data, use ' to stop it from\n;; being evaluated\n'(+ 1 2) ; => (+ 1 2)\n;; Now, some arithmetic operations\n(+ 1 1)  ; => 2\n(- 8 1)  ; => 7\n(* 10 2) ; => 20\n(expt 2 3) ; => 8\n(quotient 5 2) ; => 2\n(remainder 5 2) ; => 1\n(/ 35 5) ; => 7\n(/ 1 3) ; => 1/3\n(exact->inexact 1/3) ; => 0.3333333333333333\n(+ 1+2i  2-3i) ; => 3-1i\n\n;;; Booleans\n#t ; for true\n#f ; for false -- any value other than #f is true\n(not #t) ; => #f\n(and 0 #f (error \"doesn't get here\")) ; => #f\n(or #f 0 (error \"doesn't get here\"))  ; => 0\n\n;;; Characters\n#\\A ; => #\\A\n#\\λ ; => #\\λ\n#\\u03BB ; => #\\λ\n\n;;; Strings are fixed-length array of characters.\n\"Hello, world!\"\n\"Benjamin \\\"Bugsy\\\" Siegel\"   ; backslash is an escaping character\n\"Foo\\tbar\\41\\x21\\u0021\\a\\r\\n\" ; includes C escapes, Unicode\n\"λx:(μα.α→α).xx\"              ; can include Unicode characters\n\n;; Strings can be added too!\n(string-append \"Hello \" \"world!\") ; => \"Hello world!\"\n\n;; A string can be treated like a list of characters\n(string-ref \"Apple\" 0) ; => #\\A\n\n;; format can be used to format strings:\n(format \"~a can be ~a\" \"strings\" \"formatted\")\n\n;; Printing is pretty easy\n(printf \"I'm Racket. Nice to meet you!\\n\")\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 2. Variables\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; You can create a variable using define\n;; a variable name can use any character except: ()[]{}\",'`;#|\\\n(define some-var 5)\nsome-var ; => 5\n\n;; You can also use unicode characters\n(define ⊆ subset?)\n(⊆ (set 3 2) (set 1 2 3)) ; => #t\n\n;; Accessing a previously unassigned variable is an exception\n; x ; => x: undefined ...\n\n;; Local binding: `me' is bound to \"Bob\" only within the (let ...)\n(let ([me \"Bob\"])\n  \"Alice\"\n  me) ; => \"Bob\"\n\n;; let* is like let, but allows you to use previous bindings in creating later bindings\n(let* ([x 1]\n       [y (+ x 1)])\n       (* x y))\n\n;; finally, letrec allows you to define recursive and mutually recursive functions\n(letrec ([is-even? (lambda (n)\n                       (or (zero? n)\n                           (is-odd? (sub1 n))))]\n           [is-odd? (lambda (n)\n                      (and (not (zero? n))\n                           (is-even? (sub1 n))))])\n    (is-odd? 11))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 3. Structs and Collections\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Structs\n; By default, structs are immutable\n(struct dog (name breed age))\n(define my-pet\n  (dog \"lassie\" \"collie\" 5))\nmy-pet ; => #<dog>\n; returns whether the variable was constructed with the dog constructor\n(dog? my-pet) ; => #t\n; accesses the name field of the variable constructed with the dog constructor\n(dog-name my-pet) ; => \"lassie\"\n\n; You can explicitly declare a struct to be mutable with the #:mutable option\n(struct rgba-color (red green blue alpha) #:mutable)\n(define burgundy\n   (rgba-color 144 0 32 1.0))\n(set-rgba-color-green! burgundy 10)\n(rgba-color-green burgundy) ; => 10\n\n;;; Pairs (immutable)\n;; `cons' constructs pairs, `car' and `cdr' extract the first\n;; and second elements\n(cons 1 2) ; => '(1 . 2)\n(car (cons 1 2)) ; => 1\n(cdr (cons 1 2)) ; => 2\n\n;;; Lists\n\n;; Lists are linked-list data structures, made of `cons' pairs and end\n;; with a `null' (or '()) to mark the end of the list\n(cons 1 (cons 2 (cons 3 null))) ; => '(1 2 3)\n;; `list' is a convenience variadic constructor for lists\n(list 1 2 3) ; => '(1 2 3)\n;; a quote can also be used for a literal list value\n'(1 2 3) ; => '(1 2 3)\n;; a quasiquote (represented by the backtick character) with commas \n;; can be used to evaluate functions\n`(1 ,(+ 1 1) 3) ; => '(1 2 3)\n\n;; With lists, car/cdr work slightly differently\n(car '(1 2 3)) ; => 1\n(cdr '(1 2 3)) ; => '(2 3)\n\n;; Racket also has predefined functions on top of car and cdr, to extract parts of a list\n(cadr (list 1 2 3)) ; => 2\n(car (cdr (list 1 2 3))) ; => 2\n\n(cddr (list 1 2 3)) ; => '(3)\n(cdr (cdr (list 1 2 3))) ; => '(3)\n\n(caddr (list 1 2 3)) ; => 3\n(car (cdr (cdr (list 1 2 3)))) ; => 3\n\n;; Can still use `cons' to add an item to the beginning of a list\n(cons 4 '(1 2 3)) ; => '(4 1 2 3)\n\n;; Use `append' to add lists together\n(append '(1 2) '(3 4)) ; => '(1 2 3 4)\n\n;; Lists are a very basic type, so there is a *lot* of functionality for\n;; them, a few examples:\n(map add1 '(1 2 3))          ; => '(2 3 4)\n(map + '(1 2 3) '(10 20 30)) ; => '(11 22 33)\n(filter even? '(1 2 3 4))    ; => '(2 4)\n(count even? '(1 2 3 4))     ; => 2\n(take '(1 2 3 4) 2)          ; => '(1 2)\n(drop '(1 2 3 4) 2)          ; => '(3 4)\n\n;;; Vectors\n\n;; Vectors are fixed-length arrays\n#(1 2 3) ; => '#(1 2 3)\n\n;; Use `vector-append' to add vectors together\n(vector-append #(1 2 3) #(4 5 6)) ; => #(1 2 3 4 5 6)\n\n;;; Sets\n\n;; Create a set from a list\n(list->set '(1 2 3 1 2 3 3 2 1 3 2 1)) ; => (set 1 2 3)\n\n;; Add a member with `set-add'\n;; (Functional: returns the extended set rather than mutate the input)\n(set-add (set 1 2 3) 4) ; => (set 1 2 3 4)\n\n;; Remove one with `set-remove'\n(set-remove (set 1 2 3) 1) ; => (set 2 3)\n\n;; Test for existence with `set-member?'\n(set-member? (set 1 2 3) 1) ; => #t\n(set-member? (set 1 2 3) 4) ; => #f\n\n;;; Hashes\n\n;; Create an immutable hash table (mutable example below)\n(define m (hash 'a 1 'b 2 'c 3))\n\n;; Retrieve a value\n(hash-ref m 'a) ; => 1\n\n;; Retrieving a non-present value is an exception\n; (hash-ref m 'd) => no value found\n\n;; You can provide a default value for missing keys\n(hash-ref m 'd 0) ; => 0\n\n;; Use `hash-set' to extend an immutable hash table\n;; (Returns the extended hash instead of mutating it)\n(define m2 (hash-set m 'd 4))\nm2 ; => '#hash((b . 2) (a . 1) (d . 4) (c . 3))\n\n;; Remember, these hashes are immutable!\nm ; => '#hash((b . 2) (a . 1) (c . 3))  <-- no `d'\n\n;; Use `hash-remove' to remove keys (functional too)\n(hash-remove m 'a) ; => '#hash((b . 2) (c . 3))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 4. Functions\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Use `lambda' to create functions.\n;; A function always returns the value of its last expression\n(lambda () \"Hello World\") ; => #<procedure>\n;; Can also use a unicode `λ'\n(λ () \"Hello World\")     ; => same function\n\n;; Use parens to call all functions, including a lambda expression\n((lambda () \"Hello World\")) ; => \"Hello World\"\n((λ () \"Hello World\"))      ; => \"Hello World\"\n\n;; Assign a function to a var\n(define hello-world (lambda () \"Hello World\"))\n(hello-world) ; => \"Hello World\"\n\n;; You can shorten this using the function definition syntactic sugar:\n(define (hello-world2) \"Hello World\")\n\n;; The () in the above is the list of arguments for the function\n(define hello\n  (lambda (name)\n    (string-append \"Hello \" name)))\n(hello \"Steve\") ; => \"Hello Steve\"\n;; ... or equivalently, using a sugared definition:\n(define (hello2 name)\n  (string-append \"Hello \" name))\n\n;; You can have multi-variadic functions too, using `case-lambda'\n(define hello3\n  (case-lambda\n    [() \"Hello World\"]\n    [(name) (string-append \"Hello \" name)]))\n(hello3 \"Jake\") ; => \"Hello Jake\"\n(hello3) ; => \"Hello World\"\n;; ... or specify optional arguments with a default value expression\n(define (hello4 [name \"World\"])\n  (string-append \"Hello \" name))\n\n;; Functions can pack extra arguments up in a list\n(define (count-args . args)\n  (format \"You passed ~a args: ~a\" (length args) args))\n(count-args 1 2 3) ; => \"You passed 3 args: (1 2 3)\"\n;; ... or with the unsugared `lambda' form:\n(define count-args2\n  (lambda args\n    (format \"You passed ~a args: ~a\" (length args) args)))\n\n;; You can mix regular and packed arguments\n(define (hello-count name . args)\n  (format \"Hello ~a, you passed ~a extra args\" name (length args)))\n(hello-count \"Finn\" 1 2 3)\n; => \"Hello Finn, you passed 3 extra args\"\n;; ... unsugared:\n(define hello-count2\n  (lambda (name . args)\n    (format \"Hello ~a, you passed ~a extra args\" name (length args))))\n\n;; And with keywords\n(define (hello-k #:name [name \"World\"] #:greeting [g \"Hello\"] . args)\n  (format \"~a ~a, ~a extra args\" g name (length args)))\n(hello-k)                 ; => \"Hello World, 0 extra args\"\n(hello-k 1 2 3)           ; => \"Hello World, 3 extra args\"\n(hello-k #:greeting \"Hi\") ; => \"Hi World, 0 extra args\"\n(hello-k #:name \"Finn\" #:greeting \"Hey\") ; => \"Hey Finn, 0 extra args\"\n(hello-k 1 2 3 #:greeting \"Hi\" #:name \"Finn\" 4 5 6)\n                                         ; => \"Hi Finn, 6 extra args\"\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 5. Equality\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; for numbers use `='\n(= 3 3.0) ; => #t\n(= 2 1)   ; => #f\n\n;; `eq?' returns #t if 2 arguments refer to the same object (in memory),\n;; #f otherwise.\n;; In other words, it's a simple pointer comparison.\n(eq? '() '()) ; => #t, since there exists only one empty list in memory\n(let ([x '()] [y '()])\n  (eq? x y))  ; => #t, same as above\n\n(eq? (list 3) (list 3)) ; => #f\n(let ([x (list 3)] [y (list 3)])\n  (eq? x y))            ; => #f — not the same list in memory!\n\n(let* ([x (list 3)] [y x])\n  (eq? x y)) ; => #t, since x and y now point to the same stuff\n\n(eq? 'yes 'yes) ; => #t\n(eq? 'yes 'no)  ; => #f\n\n(eq? 3 3)   ; => #t — be careful here\n            ; It’s better to use `=' for number comparisons.\n(eq? 3 3.0) ; => #f\n\n(eq? (expt 2 100) (expt 2 100))               ; => #f\n(eq? (integer->char 955) (integer->char 955)) ; => #f\n\n(eq? (string-append \"foo\" \"bar\") (string-append \"foo\" \"bar\")) ; => #f\n\n;; `eqv?' supports the comparison of number and character datatypes.\n;; for other datatypes, `eqv?' and `eq?' return the same result.\n(eqv? 3 3.0)                                   ; => #f\n(eqv? (expt 2 100) (expt 2 100))               ; => #t\n(eqv? (integer->char 955) (integer->char 955)) ; => #t\n\n(eqv? (string-append \"foo\" \"bar\") (string-append \"foo\" \"bar\"))   ; => #f\n\n;; `equal?' supports the comparison of the following datatypes:\n;; strings, byte strings, pairs, mutable pairs, vectors, boxes,\n;; hash tables, and inspectable structures.\n;; for other datatypes, `equal?' and `eqv?' return the same result.\n(equal? 3 3.0)                                                   ; => #f\n(equal? (string-append \"foo\" \"bar\") (string-append \"foo\" \"bar\")) ; => #t\n(equal? (list 3) (list 3))                                       ; => #t\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 6. Control Flow\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; Conditionals\n\n(if #t               ; test expression\n    \"this is true\"   ; then expression\n    \"this is false\") ; else expression\n; => \"this is true\"\n\n;; In conditionals, all non-#f values are treated as true\n(member 'Groucho '(Harpo Groucho Zeppo)) ; => '(Groucho Zeppo)\n(if (member 'Groucho '(Harpo Groucho Zeppo))\n    'yep\n    'nope)\n; => 'yep\n\n;; `cond' chains a series of tests to select a result\n(cond [(> 2 2) (error \"wrong!\")]\n      [(< 2 2) (error \"wrong again!\")]\n      [else 'ok]) ; => 'ok\n\n;;; Pattern Matching\n\n(define (fizzbuzz? n)\n  (match (list (remainder n 3) (remainder n 5))\n    [(list 0 0) 'fizzbuzz]\n    [(list 0 _) 'fizz]\n    [(list _ 0) 'buzz]\n    [_          #f]))\n\n(fizzbuzz? 15) ; => 'fizzbuzz\n(fizzbuzz? 37) ; => #f\n\n;;; Loops\n\n;; Looping can be done through (tail-) recursion\n(define (loop i)\n  (when (< i 10)\n    (printf \"i=~a\\n\" i)\n    (loop (add1 i))))\n(loop 5) ; => i=5, i=6, ...\n\n;; Similarly, with a named let\n(let loop ((i 0))\n  (when (< i 10)\n    (printf \"i=~a\\n\" i)\n    (loop (add1 i)))) ; => i=0, i=1, ...\n\n;; See below how to add a new `loop' form, but Racket already has a very\n;; flexible `for' form for loops:\n(for ([i 10])\n  (printf \"i=~a\\n\" i)) ; => i=0, i=1, ...\n(for ([i (in-range 5 10)])\n  (printf \"i=~a\\n\" i)) ; => i=5, i=6, ...\n\n;;; Iteration Over Other Sequences\n;; `for' allows iteration over many other kinds of sequences:\n;; lists, vectors, strings, sets, hash tables, etc...\n\n(for ([i (in-list '(l i s t))])\n  (displayln i))\n\n(for ([i (in-vector #(v e c t o r))])\n  (displayln i))\n\n(for ([i (in-string \"string\")])\n  (displayln i))\n\n(for ([i (in-set (set 'x 'y 'z))])\n  (displayln i))\n\n(for ([(k v) (in-hash (hash 'a 1 'b 2 'c 3 ))])\n  (printf \"key:~a value:~a\\n\" k v))\n\n;;; More Complex Iterations\n\n;; Parallel scan of multiple sequences (stops on shortest)\n(for ([i 10] [j '(x y z)]) (printf \"~a:~a\\n\" i j))\n; => 0:x 1:y 2:z\n\n;; Nested loops\n(for* ([i 2] [j '(x y z)]) (printf \"~a:~a\\n\" i j))\n; => 0:x, 0:y, 0:z, 1:x, 1:y, 1:z\n\n;; Conditions\n(for ([i 1000]\n      #:when (> i 5)\n      #:unless (odd? i)\n      #:break (> i 10))\n  (printf \"i=~a\\n\" i))\n; => i=6, i=8, i=10\n\n;;; Comprehensions\n;; Very similar to `for' loops -- just collect the results\n\n(for/list ([i '(1 2 3)])\n  (add1 i)) ; => '(2 3 4)\n\n(for/list ([i '(1 2 3)] #:when (even? i))\n  i) ; => '(2)\n\n(for/list ([i 10] [j '(x y z)])\n  (list i j)) ; => '((0 x) (1 y) (2 z))\n\n(for/list ([i 1000] #:when (> i 5) #:unless (odd? i) #:break (> i 10))\n  i) ; => '(6 8 10)\n\n(for/hash ([i '(1 2 3)])\n  (values i (number->string i)))\n; => '#hash((1 . \"1\") (2 . \"2\") (3 . \"3\"))\n\n;; There are many kinds of other built-in ways to collect loop values:\n(for/sum ([i 10]) (* i i)) ; => 285\n(for/product ([i (in-range 1 11)]) (* i i)) ; => 13168189440000\n(for/and ([i 10] [j (in-range 10 20)]) (< i j)) ; => #t\n(for/or ([i 10] [j (in-range 0 20 2)]) (= i j)) ; => #t\n;; And to use any arbitrary combination, use `for/fold'\n(for/fold ([sum 0]) ([i '(1 2 3 4)]) (+ sum i)) ; => 10\n;; (This can often replace common imperative loops)\n\n;;; Exceptions\n\n;; To catch exceptions, use the `with-handlers' form\n(with-handlers ([exn:fail? (lambda (exn) 999)])\n  (+ 1 \"2\")) ; => 999\n(with-handlers ([exn:break? (lambda (exn) \"no time\")])\n  (sleep 3)\n  \"phew\") ; => \"phew\", but if you break it => \"no time\"\n\n;; Use `raise' to throw exceptions or any other value\n(with-handlers ([number?    ; catch numeric values raised\n                 identity]) ; return them as plain values\n  (+ 1 (raise 2))) ; => 2\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 7. Mutation\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Use `set!' to assign a new value to an existing variable\n(define n 5)\n(set! n (add1 n))\nn ; => 6\n\n;; Use boxes for explicitly mutable values (similar to pointers or\n;; references in other languages)\n(define n* (box 5))\n(set-box! n* (add1 (unbox n*)))\n(unbox n*) ; => 6\n\n;; Many Racket datatypes are immutable (pairs, lists, etc), some come in\n;; both mutable and immutable flavors (strings, vectors, hash tables,\n;; etc...)\n\n;; Use `vector' or `make-vector' to create mutable vectors\n(define vec (vector 2 2 3 4))\n(define wall (make-vector 100 'bottle-of-beer))\n;; Use vector-set! to update a slot\n(vector-set! vec 0 1)\n(vector-set! wall 99 'down)\nvec ; => #(1 2 3 4)\n\n;; Create an empty mutable hash table and manipulate it\n(define m3 (make-hash))\n(hash-set! m3 'a 1)\n(hash-set! m3 'b 2)\n(hash-set! m3 'c 3)\n(hash-ref m3 'a)   ; => 1\n(hash-ref m3 'd 0) ; => 0\n(hash-remove! m3 'a)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 8. Modules\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Modules let you organize code into multiple files and reusable\n;; libraries; here we use sub-modules, nested in the whole module that\n;; this text makes (starting from the \"#lang\" line)\n\n(module cake racket/base ; define a `cake' module based on racket/base\n\n  (provide print-cake) ; function exported by the module\n\n  (define (print-cake n)\n    (show \"   ~a   \" n #\\.)\n    (show \" .-~a-. \" n #\\|)\n    (show \" | ~a | \" n #\\space)\n    (show \"---~a---\" n #\\-))\n\n  (define (show fmt n ch) ; internal function\n    (printf fmt (make-string n ch))\n    (newline)))\n\n;; Use `require' to get all `provide'd names from a module\n(require 'cake) ; the ' is for a local submodule\n(print-cake 3)\n; (show \"~a\" 1 #\\A) ; => error, `show' was not exported\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 9. Classes and Objects\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Create a class fish% (-% is idiomatic for class bindings)\n(define fish%\n  (class object%\n    (init size) ; initialization argument\n    (super-new) ; superclass initialization\n    ;; Field\n    (define current-size size)\n    ;; Public methods\n    (define/public (get-size)\n      current-size)\n    (define/public (grow amt)\n      (set! current-size (+ amt current-size)))\n    (define/public (eat other-fish)\n      (grow (send other-fish get-size)))))\n\n;; Create an instance of fish%\n(define charlie\n  (new fish% [size 10]))\n\n;; Use `send' to call an object's methods\n(send charlie get-size) ; => 10\n(send charlie grow 6)\n(send charlie get-size) ; => 16\n\n;; `fish%' is a plain \"first class\" value, which can get us mixins\n(define (add-color c%)\n  (class c%\n    (init color)\n    (super-new)\n    (define my-color color)\n    (define/public (get-color) my-color)))\n(define colored-fish% (add-color fish%))\n(define charlie2 (new colored-fish% [size 10] [color 'red]))\n(send charlie2 get-color)\n;; or, with no names:\n(send (new (add-color fish%) [size 10] [color 'red]) get-color)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 10. Macros\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Macros let you extend the syntax of the language\n\n;; Let's add a while loop\n(define-syntax-rule (while condition body ...)\n  (let loop ()\n    (when condition\n      body ...\n      (loop))))\n\n(let ([i 0])\n  (while (< i  10)\n    (displayln i)\n    (set! i (add1 i))))\n\n;; Macros are hygienic, you cannot clobber existing variables!\n(define-syntax-rule (swap! x y) ; -! is idiomatic for mutation\n  (let ([tmp x])\n    (set! x y)\n    (set! y tmp)))\n\n(define tmp 2)\n(define other 3)\n(swap! tmp other)\n(printf \"tmp = ~a; other = ~a\\n\" tmp other)\n;; The variable `tmp` is renamed to `tmp_1`\n;; in order to avoid name conflict\n;; (let ([tmp_1 tmp])\n;;   (set! tmp other)\n;;   (set! other tmp_1))\n\n;; But they are still code transformations, for example:\n(define-syntax-rule (bad-while condition body ...)\n  (when condition\n    body ...\n    (bad-while condition body ...)))\n;; this macro is broken: it generates infinite code, if you try to use\n;; it, the compiler will get in an infinite loop\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 11. Contracts\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Contracts impose constraints on values exported from modules\n\n(module bank-account racket\n  (provide (contract-out\n            [deposit (-> positive? any)] ; amounts are always positive\n            [balance (-> positive?)]))\n\n  (define amount 0)\n  (define (deposit a) (set! amount (+ amount a)))\n  (define (balance) amount)\n  )\n\n(require 'bank-account)\n(deposit 5)\n\n(balance) ; => 5\n\n;; Clients that attempt to deposit a non-positive amount are blamed\n;; (deposit -5) ; => deposit: contract violation\n;; expected: positive?\n;; given: -5\n;; more details....\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; 12. Input & output\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Racket has this concept of \"port\", which is very similar to file\n;; descriptors in other languages\n\n;; Open \"/tmp/tmp.txt\" and write \"Hello World\"\n;; This would trigger an error if the file's already existed\n(define out-port (open-output-file \"/tmp/tmp.txt\"))\n(displayln \"Hello World\" out-port)\n(close-output-port out-port)\n\n;; Append to \"/tmp/tmp.txt\"\n(define out-port (open-output-file \"/tmp/tmp.txt\"\n                                   #:exists 'append))\n(displayln \"Hola mundo\" out-port)\n(close-output-port out-port)\n\n;; Read from the file again\n(define in-port (open-input-file \"/tmp/tmp.txt\"))\n(displayln (read-line in-port))\n; => \"Hello World\"\n(displayln (read-line in-port))\n; => \"Hola mundo\"\n(close-input-port in-port)\n\n;; Alternatively, with call-with-output-file you don't need to explicitly\n;; close the file\n(call-with-output-file \"/tmp/tmp.txt\"\n  #:exists 'update ; Rewrite the content\n  (λ (out-port)\n    (displayln \"World Hello!\" out-port)))\n\n;; And call-with-input-file does the same thing for input\n(call-with-input-file \"/tmp/tmp.txt\"\n  (λ (in-port)\n    (displayln (read-line in-port))))\n```\n\n## Further Reading\n\nStill up for more? Try [Getting Started with Racket](http://docs.racket-lang.org/getting-started/)"
