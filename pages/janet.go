
package pages

const Janet = "[Janet](https://janet-lang.org/) is a Lisp-like (Clojure-like),\nlexically-scoped, dynamically-typed, garbage-collected, C-based, high-level\nlanguage. The entire language (core library, interpreter, compiler, assembler,\nPEG) is about 300-500 kB and should run on many constrained systems.\n\nI encourage you to try out the code snippets below in the Janet\nrepl (either by [installing Janet](https://janet-lang.org/docs/index.html),\nor else by using the repl embedded in the Janet homepage).\n\nAs we only have a scant *y* minutes, we'll survey the basics here and\nleave the remaining details for the manual. So please, keep your arms and\nlegs inside the vehicle at all times, and on with the scenic tour!\n\n```janet\n# A comment.\n\n# Some literal values.\ntrue\nfalse\nnil\n\n# Typical style for symbols (identifiers-for / names-of things).\ndo-stuff\npants-on-fire!\nfoo->bar  # Evidently for converting foos to bars.\nfully-charged?\n_  # Usually used as a dummy variable.\n\n# Keywords are like symbols that start with a colon, are treated like\n# constants, and are typically used as map keys or pieces of syntax in\n# macros.\n:a\n:some-val\n\n# Numbers #####################################################################\n5\n1e3    # => 1000\n1_000  # => 1000\n2e-03  # => 0.002\n0xff   # => 255\n\n# You can specify a radix (base) like so:\n16rff   # => 255 (same as 0xff)\n2r1101  # =>  13\n\n# Some numbers in the math library:\nmath/pi  # => 3.14159\nmath/e   # => 2.71828\n\n# Strings #####################################################################\n\"hello\"\n\"hey\\tthere\"  # contains a tab\n\n# For multi-line strings, use one or more backticks. No escapes allowed.\n``a long\nmulti-line\nstring``  # => \"a long\\nmulti-line\\nstring\"\n\n# Strings and data structures in Janet come in two varieties: mutable and\n# immutable. The literal for the mutable variety is written with a `@` in\n# front of it.\n\n# A mutable string (aka \"buffer\").\n@\"this\"\n@`a multi-line\none here`\n\n(string \"con\" \"cat\" \"enate\")  # => \"concatenate\"\n\n# To get a substring:\n(string/slice \"abcdefgh\" 2 5)  # => \"cde\"\n# To find a substring:\n(string/find \"de\" \"abcdefgh\")  # => 3\n\n# See the string library for more (splitting, replacement, etc.)\n\n# Arrays and Tuples ###########################################################\n# Arrays are mutable, tuples are immutable.\n\n# Arrays (mutable)\n@(4 5 6)\n@[4 5 6]\n\n# Tuples (immutable)\n# Note that an open paren usually indicates a function call, so if you want a\n# literal tuple with parens, you need to \"quote\" it (with a starting single\n# quote mark).\n'(4 5 6)\n[4 5 6]  # ... or just use square brackets.\n\n# Tables and Structs (AKA: \"maps\", \"hashmaps\", \"dictionaries\")\n@{:a 1 :b 2 :c 3}  # table  (mutable)\n{:a 1 :b 2 :c 3}   # struct (immutable)\n\n# More about how to work with arrays/tuples and tables/structs below.\n\n# Bindings ####################################################################\n# ... or \"Name Some Things!\" (that is, bind a value to a symbol)\n(def x 4.7)  # Define a constant, `x`.\nx            # => 4.7\n(quote x)    # => x (the symbol x)\n'x           # => x (the symbol x (shorthand))\n(print x)    # prints 4.7\n\n# Since we used `def`, can't change to what `x` refers:\n(set x 5.6)  # Error, `x` is a constant.\n\n(var y 10)\n(set y 12)  # Works, since `y` was made var.\n\n# Note that bindings are local to the scope they're called in. `let`\n# creates a local scope and makes some bindings all in one shot:\n(let [a 2\n      b 3]\n  (print \"Hello from inside this local scope.\")\n  (* a b))  # => 6\n\n# Destructuring is supported, both for arrays/tuples ...\n(def a [\"foos\" \"bars\" \"moos\"])\n(let [[s1 _ s2] a]\n  (print s1 s2))  # foosmoos\n\n# ... and for tables/structs.\n(def t {:a \"ayy\" :b \"bee\" :c \"sea\"})\n(let [{:a a :b b} t]\n  (print a b))  # ayybee\n\n# You can even destructure right in a `def`:\n(def [aa1 aa2] a)\naa1  # => foos\naa2  # => bars\n\n(def {:c body-of-water :b insect-friend} t)\nbody-of-water  # => sea\ninsect-friend  # => bee\n\n# Note that keywords evaluate to themselves, whereas symbols evaluate\n# to whatever value they're bound to (unless you quote them).\n\n# Operators ###################################################################\n# Janet supports the usual ensemble of operators.\n# +, -, *, /, and so on. Note:\n(/ 5 3)  # =>  1.66667\n(% 5 3)  # =>  2 (remainder)\n(- 5)    # => -5 (or you can just write `-5`)\n\n(++ i)    # increments\n(-- i)    # decrements\n(+= i 3)  # add 3 to `i`\n(*= i 3)  # triple `i`\n# ... and so on for the other operations on numbers.\n\n# Comparison\n# =  <  >  not=  <=  >=\n(< 2 7 12)  # => true\n\n# Functions ###################################################################\n# Call them:\n(- 5 3)  # => 2 (Yes, operators and functions work the same.)\n(math/sin (/ math/pi 2))  # => 1\n(range 5)  # => @[0 1 2 3 4]\n\n# Create them:\n(defn mult-by-2\n  ``First line of docstring.\n\n  Some more of the docstring.\n\n  Possibly more!``\n  [x]\n  (print \"Hi.\")\n  (print \"Will compute using: \" x)\n  (* 2 x))\n\n(print (mult-by-2 6))  # => 12 (after printing \"Hi\" and so forth)\n\n# If you have a function named \"main\" in your file, `janet` will automatically\n# call it for you when you run the file.\n\n# Interactively read a function's docs from within the repl:\n(doc mult-by-2)\n\n# Note, functions have to be defined before they can be used in a function,\n# so if you design top-down, you'll need to write your functions from the\n# bottom of the file up.\n\n# You can make anonymous functions as well:\n(fn [x] (+ x x))\n(fn my-func [x] (+ x x))  # This one's less anonymous.\n\n# Use `do` to make some side-effecting calls and then evaluate to\n# the last form in the `do`:\n(def n (do\n         (print \"hi\")\n         (do-some-side-effecting 42)\n         3))\nn  # => 3\n\n# You might say that function bodies provide an \"implicit do\".\n\n# Operations on data structures ###############################################\n# (Making all these mutable so we can ... mutate them.)\n(def s @\"Hello, World!\")\n(def a @[:a :b :c :d :e])\n(def t @{:a 1 :b 2})\n\n(length s)  # => 13\n(length a)  # =>  5\n(length t)  # =>  2\n\n# Getting values:\n(s 7)   # => 87 (which is the code point for \"W\")\n(a 1)   # => :b\n(t :a)  # => 1\n(keys t)    # => @[:a :b]\n(values t)  # => @[1 2]\n\n# Changing values (for mutable data structures):\n(put s 2 87)   # @\"HeWlo, World!\"\n(put a 2 :x)   # @[:a :b :x :d :e]\n(put t :b 42)  # @{:a 1 :b 42}\n\n# Adding & removing values (again, for mutable data structures):\n(buffer/push-string s \"??\")  # @\"HeWlo, World!??\"\n(array/push a :f)  # @[:a :b :x :d :e :f]\n(array/pop a)      # => :f, and it's also removed from `a`.\n(put t :x 88)      # @{:a 1 :b 42 :x 88}\n\n# See the manual for a wide variety of functions for working with\n# buffers/strings, arrays/tuples, and tables/struct.\n\n# Flow control ################################################################\n(if some-condition\n  42\n  38)\n\n# Only `nil` and `false` are falsey. Everything else is truthy.\n\n(if got-it?\n  71)  # No false-branch value. Returns `nil` if `got-it?` is falsey.\n\n(var i 10)\n(while (pos? i)\n  (print \"... \" i)\n  (-- i))\n# Now `i` is 0.\n\n# `case` compares the dispatch value to each of the options.\n(var x 2)\n(case x\n  1 \"won\"\n  2 \"too\"\n  3 \"tree\"\n  \"unknown\")  # => \"too\"\n\n# `cond` evaluates conditions until it gets a `true`.\n(set x 8)\n(cond\n  (= x 1) \"won\"\n  (= x 2) \"too\"\n  (< x 10) \"tree\"\n  \"oof!\")  # => \"tree\"\n\n(when (avoided-wipeout?)\n  (do-side-effecty-thing 88)\n  (smell-the-roses)\n  (paint-fencepost-error))\n\n# Pattern matching.\n# `match` is like a high-powered switch expression. If you switch on a data\n# structure, it can look inside to try and match on its contents. For example,\n# matching on a table or struct:\n(def t {:a 1 :b 2 :c 3})\n(match t\n  {:yar v} (print \"matches key :yar! \" v)\n  {:moo v} (print \"matches key :moo! \" v)\n  {:c   v} (print \"matches key :c! \"   v)\n  _ (print \"no match\"))  # => prints \"matches key :c! 3\"\n\n# Iterating ###################################################################\n# Iterate over an integer range:\n(for i 0 5\n  (print i))  # prints 0, 1, 2, 3, 4\n\n# There's also the more general `loop`:\n(loop [i :range [0 10] :when (even? i)]\n  (print i))\n\n# Loop over an array/tuple:\n(def words [\"foo\" \"bar\" \"baz\"])\n(each word words\n  (print word))\n\n# Loop over a table/struct:\n(def t {:a 1 :b 2})\n(eachp [k v] t  # Loop over each pair in `t`.\n  (print k \" --> \" v))\n\n# Can also use `eachk` to loop over keys in a table or struct.\n\n# Functional programming ######################################################\n# You'll find many familiar old friends here.\n(filter even?\n        (map (fn [x]\n               (* x x))\n             (range 10)))  # => @[0 4 16 36 64]\n\n(reduce + 0 (range 5))  # => 10\n\n# ...and lots more (see the API docs).\n\n# Errata ######################################################################\n(type a)                # => the type of `a` (as a keyword)\n(describe a)            # => a human-readable description of `a`\n(string/format \"%j\" a)  # => Janet values, nicely-formatted\n```\n\nThis tour didn't cover a number of other features such as modules, fibers,\nPEGs, macros, etc., but should give you a taste of what Janet is like. See\nthe [Janet manual](https://janet-lang.org/docs/index.html) and the [Janet API\ndocs](https://janet-lang.org/api/index.html) for more info."
