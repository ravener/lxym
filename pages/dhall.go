
package pages

const Dhall = "Dhall is a programmable configuration language that provides a non-repetitive\nalternative to YAML.\n\nYou can think of Dhall as: JSON + functions + types + imports\n\nNote that while Dhall is programmable, Dhall is not Turing-complete.  Many\nof Dhall's features take advantage of this restriction to provide stronger\nsafety guarantees and more powerful tooling.\n\n```haskell\n-- Single-line comment\n\n{- Multi-line comment\n\n   Unicode is fine üôÇ\n\n   This file is a valid Dhall expression that evaluates to a large record\n   collecting the results of each step.\n\n   You can view the results by interpreting the file:\n\n       $ dhall --file learndhall.dhall\n\n   {- Comments can be nested -}\n-}\n\nlet greeting = \"Hello, world!\"\n\nlet fruits = \"üçãüçìüççüçâüçå\"\n\nlet interpolation = \"Enjoy some delicious fruit: ${fruits}\"\n\nlet multilineText {- Inline comments work, too -} =\n        ''\n        Leading whitespace is stripped from multi-line text literals.\n\n        That means you can freely indent or dedent a text literal without\n        changing the result.\n\n            Relative indentation within the literal is still preserved.\n\n        Other than that, the text literal is preserved verbatim, similar to a\n        \"literal\" YAML multiline string.\n        ''\n\nlet bool = True\n\n-- Type annotations on bindings are optional, but helpful, so we'll use them\nlet annotation : Bool = True\n\nlet renderedBool : Text = if bool then \"True\" else \"False\"\n\n-- Natural numbers are non-negative and are unsigned\nlet naturalNumber : Natural = 42\n\n-- Integers may be negative, but require an explicit sign, even if positive\nlet positiveInteger : Integer = +1\n\nlet negativeInteger : Integer = -12\n\nlet pi : Double = 3.14159265359\n\n{- You can use a wider character range for identifiers (such as quotation\n   marks and whitespace) if you quote them using backticks\n-}\nlet `Avogadro's Number` : Double = 6.0221409e+23\n\nlet origin : { x : Double, y : Double } = { x = 0.0, y = 0.0 }\n\nlet somePrimes : List Natural = [ 2, 3, 5, 7, 11 ]\n\n{- A schema is the same thing as a type\n\n   Types begin with an uppercase letter by convention, but this convention is\n   not enforced\n-}\nlet Profile : Type\n        = { person :\n              { name : Text\n              , age  : Natural\n              }\n          , address :\n              { country : Text\n              , state   : Text\n              , city    : Text\n              }\n          }\n\nlet john : Profile =\n        { person =\n            { name = \"John Doe\"\n            , age  = 67\n            }\n        , address =\n            { country = \"United States\"\n            , state   = \"Pennsylvania\"\n            , city    = \"Philadelphia\"\n            }\n        }\n\nlet philadelphia : Text = john.address.city\n\n{- Enum alternatives also begin with an uppercase letter by convention.  This\n   convention is not enforced\n-}\nlet DNA : Type = < Adenine | Cytosine | Guanine | Thymine >\n\nlet dnaSequence : List DNA = [ DNA.Thymine, DNA.Guanine, DNA.Guanine ]\n\nlet compactDNASequence : List DNA =\n        let a = DNA.Adenine\n        let c = DNA.Cytosine\n        let g = DNA.Guanine\n        let t = DNA.Thymine\n        in  [ c, t, t, a, t, c, g, g, c ]\n\n-- You can transform enums by providing a record with one field per alternative\nlet theLetterG : Text =\n            merge\n            { Adenine  = \"A\"\n            , Cytosine = \"C\"\n            , Guanine  = \"G\"\n            , Thymine  = \"T\"\n            }\n            DNA.Guanine\n\nlet presentOptionalValue : Optional Natural = Some 1\n\nlet absentOptionalValue : Optional Natural = None Natural\n\nlet points : List { x : Double, y : Double } =\n        [ { x = 1.1, y = -4.2 }\n        , { x = 4.4, y = -3.0 }\n        , { x = 8.2, y = -5.5 }\n        ]\n\n{- `Natural -> List Natural` is the type of a function whose input type is a\n   `Natural` and whose output type is a `List Natural`\n\n   All functions in Dhall are anonymous functions (a.k.a. \"lambdas\"),\n   which you can optionally give a name\n\n   For example, the following function is equivalent to this Python code:\n\n       lambda n : [ n, n + 1 ]\n\n   ... and this JavaScript code:\n\n       function (n) { return [ n, n + 1 ]; }\n-}\nlet exampleFunction : Natural -> List Natural =\n        \\(n : Natural) -> [ n, n + 1 ]\n\n-- Dhall also supports Unicode syntax, but this tutorial will stick to ASCII\nlet unicodeFunction : Natural ‚Üí List Natural =\n        Œª(n : Natural) ‚Üí [ n, n + 1 ]\n\n-- You don't need to parenthesize function arguments\nlet exampleFunctionApplication : List Natural =\n        exampleFunction 2\n\nlet functionOfMultipleArguments : Natural -> Natural -> List Natural =\n        \\(x : Natural) -> \\(y : Natural) -> [ x, y ]\n\nlet functionAppliedToMultipleArguments : List Natural =\n        functionOfMultipleArguments 2 3\n\n{- Same as `exampleFunction` except we gave the function's input type a\n   name: \"n\"\n-}\nlet namedArgumentType : forall (n : Natural) -> List Natural =\n        \\(n : Natural) -> [ n, n + 1 ]\n\n{- If you name a function's input type, you can use that name later within the\n   same type\n\n   This lets you write a function that works for more than one type of input\n   (a.k.a. a \"polymorphic\" function)\n-}\nlet duplicate : forall (a : Type) -> a -> List a =\n        \\(a : Type) -> \\(x : a) -> [ x, x ] \n\nlet duplicatedNumber : List Natural =\n        duplicate Natural 2\n\nlet duplicatedBool : List Bool =\n        duplicate Bool False\n\n{- The language also has some built-in polymorphic functions, such as:\n\n       List/head : forall (a : Type) -> List a -> Optional a\n-}\nlet firstPrime : Optional Natural = List/head Natural somePrimes\n\nlet functionOfARecord : { x : Natural, y : Natural } -> List Natural =\n        \\(args : { x : Natural, y : Natural }) -> [ args.x, args.y ]\n\nlet functionAppliedToARecord : List Natural =\n        functionOfARecord { x = 2, y = 5 }\n\n{- All type conversions are explicit\n\n   `Natural/show` is a built-in function of the following type:\n\n       Natural/show : Natural -> Text\n\n   ... that converts `Natural` numbers to their `Text` representation\n-}\nlet typeConversion : Natural -> Text =\n        \\(age : Natural) -> \"I am ${Natural/show age} years old!\"\n\n-- A \"template\" is the same thing as a function whose output type is `Text`\nlet mitLicense : { year : Natural, copyrightHolder : Text } -> Text =\n        \\(args : { year : Natural, copyrightHolder : Text }) ->\n''\nCopyright ${Natural/show args.year} ${args.copyrightHolder}\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n''\n\n-- Template instantiation is the same thing as function application\nlet templatedLicense : Text =\n        mitLicense { year = 2019, copyrightHolder = \"Jane Smith\" }\n\n{- You can import expressions by URL\n\n   Also, like Bash, you can import code from your local filesystem (not shown)\n\n   Security-conscious users can pin remotely-imported expressions by adding a\n   semantic integrity check.  The interpreter rejects any attempt to tamper with\n   an expression pinned in this way.  However, behavior-preserving refactors\n   of imported content will not perturb the hash.\n\n   Imported expressions pinned in this way are also locally cached in a\n   content-addressable store (typically underneath `~/.cache/dhall`)\n-}\nlet Natural/sum : List Natural -> Natural =\n      https://prelude.dhall-lang.org/Natural/sum\n      sha256:33f7f4c3aff62e5ecf4848f964363133452d420dcde045784518fb59fa970037\n\nlet twentyEight : Natural = Natural/sum somePrimes\n\n-- A \"package\" is the same thing as a (possibly nested) record that you can import\nlet Prelude = https://prelude.dhall-lang.org/package.dhall\n\nlet false : Bool = Prelude.Bool.not True\n\n-- You can import the raw contents of a file by adding `as Text` to an import\nlet sourceCode : Text = https://prelude.dhall-lang.org/Bool/not as Text\n\n-- You can import environment variables, too:\nlet presentWorkingDirectory = env:PWD as Text\n\n-- You can provide a fallback expression if an import fails\nlet home : Optional Text = Some env:HOME ? None Text\n\n-- Fallback expressions can contain alternative imports of their own\nlet possiblyCustomPrelude =\n        env:DHALL_PRELUDE\n      ? https://prelude.dhall-lang.org/package.dhall\n\n{- Tie everything together by auto-generating configurations for 10 build users\n   using the `generate` function:\n\n       Prelude.List.generate\n           : Natural -> forall (a : Type) -> (Natural -> a) -> List a\n-}\nlet buildUsers =\n        let makeUser = \\(user : Text) ->\n              let home       = \"/home/${user}\"\n              let privateKey = \"${home}/.ssh/id_ed25519\"\n              let publicKey  = \"${privateKey}.pub\"\n              in  { home = home\n                  , privateKey = privateKey\n                  , publicKey = publicKey\n                  }\n\n        let buildUser =\n                \\(index : Natural) -> makeUser \"build${Natural/show index}\"\n\n        let Config =\n              { home : Text\n              , privateKey : Text\n              , publicKey : Text\n              }\n\n        in  Prelude.List.generate 10 Config buildUser\n\n-- Present all of the results in a final record\nin  { greeting = greeting\n    , fruits = fruits\n    , interpolation = interpolation\n    , multilineText = multilineText\n    , bool = bool\n    , annotation = annotation\n    , renderedBool = renderedBool\n    , naturalNumber = naturalNumber\n    , positiveInteger = positiveInteger\n    , negativeInteger = negativeInteger\n    , pi = pi\n    , `Avogadro's Number` = `Avogadro's Number`\n    , origin = origin\n    , somePrimes = somePrimes\n    , john = john\n    , philadelphia = philadelphia\n    , dnaSequence = dnaSequence\n    , compactDNASequence = compactDNASequence\n    , theLetterG = theLetterG\n    , presentOptionalValue = presentOptionalValue\n    , absentOptionalValue = absentOptionalValue\n    , points = points\n    , exampleFunction = exampleFunction\n    , unicodeFunction = unicodeFunction\n    , exampleFunctionApplication = exampleFunctionApplication\n    , functionOfMultipleArguments = functionOfMultipleArguments\n    , functionAppliedToMultipleArguments = functionAppliedToMultipleArguments\n    , namedArgumentType = namedArgumentType\n    , duplicate = duplicate\n    , duplicatedNumber = duplicatedNumber\n    , duplicatedBool = duplicatedBool\n    , firstPrime = firstPrime\n    , functionOfARecord = functionOfARecord\n    , functionAppliedToARecord = functionAppliedToARecord\n    , typeConversion = typeConversion\n    , mitLicense = mitLicense\n    , templatedLicense = templatedLicense\n    , twentyEight = twentyEight\n    , false = false\n    , sourceCode = sourceCode\n    , presentWorkingDirectory = presentWorkingDirectory\n    , home = home\n    , buildUsers = buildUsers\n    }\n```\n\nTo learn more, visit the official website, which also lets you try the\nlanguage live in your browser:\n\n* [https://dhall-lang.org](http://dhall-lang.org/)"
