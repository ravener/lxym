
package pages

const Cypher = "Cypher is the Neo4j’s query language to manipulate graphs easily. It reuses syntax from SQL and mixes it with kind of ascii-art to represent graphs.\nThis tutorial assumes that you already know graph concepts like nodes and relationships.\n\n[Read more here.](https://neo4j.com/developer/cypher-query-language/)\n\n\nNodes\n---\n\n**Represents a record in a graph.**\n\n`()`\nIt's an empty *node*, to indicate that there is a *node*, but it's not relevant for the query.\n\n`(n)`\nIt's a *node* referred by the variable **n**, reusable in the query. It begins with lowercase and uses camelCase.\n\n`(p:Person)`\nYou can add a *label* to your node, here **Person**. It's like a type / a class / a category. It begins with uppercase and uses camelCase.\n\n`(p:Person:Manager)`\nA node can have many *labels*.\n\n`(p:Person {name : 'Théo Gauchoux', age : 22})`\nA node can have some *properties*, here **name** and **age**. It begins with lowercase and uses camelCase.\n\nThe types allowed in properties :\n\n - Numeric\n - Boolean\n - String\n - List of previous primitive types\n\n*Warning : there isn't datetime property in Cypher ! You can use String with a specific pattern or a Numeric from a specific date.*\n\n`p.name`\nYou can access to a property with the dot style.\n\n\nRelationships (or Edges)\n---\n\n**Connects two nodes**\n\n`[:KNOWS]`\nIt's a *relationship* with the *label* **KNOWS**. It's a *label* as the node's label. It begins with uppercase and use UPPER\\_SNAKE\\_CASE.\n\n`[k:KNOWS]`\nThe same *relationship*, referred by the variable **k**, reusable in the query, but it's not necessary.\n\n`[k:KNOWS {since:2017}]`\nThe same *relationship*, with *properties* (like *node*), here **since**.\n\n`[k:KNOWS*..4]`\nIt's a structural information to use in a *path* (seen later). Here, **\\*..4** says \"Match the pattern, with the relationship **k** which be repeated between 1 and 4 times.\n\n\nPaths\n---\n\n**The way to mix nodes and relationships.**\n\n`(a:Person)-[:KNOWS]-(b:Person)`\nA path describing that **a** and **b** know each other.\n\n`(a:Person)-[:MANAGES]->(b:Person)`\nA path can be directed. This path describes that **a** is the manager of **b**.\n\n`(a:Person)-[:KNOWS]-(b:Person)-[:KNOWS]-(c:Person)`\nYou can chain multiple relationships. This path describes the friend of a friend.\n\n`(a:Person)-[:MANAGES]->(b:Person)-[:MANAGES]->(c:Person)`\nA chain can also be directed. This path describes that **a** is the boss of **b** and the big boss of **c**.\n\nPatterns often used (from Neo4j doc) :\n\n```\n// Friend-of-a-friend \n(user)-[:KNOWS]-(friend)-[:KNOWS]-(foaf)\n\n// Shortest path\npath = shortestPath( (user)-[:KNOWS*..5]-(other) )\n\n// Collaborative filtering\n(user)-[:PURCHASED]->(product)<-[:PURCHASED]-()-[:PURCHASED]->(otherProduct)\n\n// Tree navigation \n(root)<-[:PARENT*]-(leaf:Category)-[:ITEM]->(data:Product)\n\n```\n\n\nCreate queries\n---\n\nCreate a new node\n```\nCREATE (a:Person {name:\"Théo Gauchoux\"})\nRETURN a\n```\n*`RETURN` allows to have a result after the query. It can be multiple, as `RETURN a, b`.*\n\nCreate a new relationship (with 2 new nodes)\n```\nCREATE (a:Person)-[k:KNOWS]-(b:Person)\nRETURN a,k,b\n```\n\nMatch queries\n---\n\nMatch all nodes\n```\nMATCH (n)\nRETURN n\n```\n\nMatch nodes by label\n```\nMATCH (a:Person)\nRETURN a\n```\n\nMatch nodes by label and property\n```\nMATCH (a:Person {name:\"Théo Gauchoux\"})\nRETURN a\n```\n\nMatch nodes according to relationships (undirected)\n```\nMATCH (a)-[:KNOWS]-(b)\nRETURN a,b\n```\n\nMatch nodes according to relationships (directed)\n```\nMATCH (a)-[:MANAGES]->(b)\nRETURN a,b\n```\n\nMatch nodes with a `WHERE` clause\n```\nMATCH (p:Person {name:\"Théo Gauchoux\"})-[s:LIVES_IN]->(city:City)\nWHERE s.since = 2015\nRETURN p,state\n```\n\nYou can use `MATCH WHERE` clause with `CREATE` clause\n```\nMATCH (a), (b)\nWHERE a.name = \"Jacquie\" AND b.name = \"Michel\"\nCREATE (a)-[:KNOWS]-(b)\n```\n\n\nUpdate queries\n---\n\nUpdate a specific property of a node\n```\nMATCH (p:Person)\nWHERE p.name = \"Théo Gauchoux\"\nSET p.age = 23\n```\n\nReplace all properties of a node\n```\nMATCH (p:Person)\nWHERE p.name = \"Théo Gauchoux\"\nSET p = {name: \"Michel\", age: 23}\n```\n\nAdd new property to a node\n```\nMATCH (p:Person)\nWHERE p.name = \"Théo Gauchoux\"\nSET p + = {studies: \"IT Engineering\"}\n```\n\nAdd a label to a node\n```\nMATCH (p:Person)\nWHERE p.name = \"Théo Gauchoux\"\nSET p:Internship\n```\n\n\nDelete queries\n---\n\nDelete a specific node (linked relationships must be deleted before)\n```\nMATCH (p:Person)-[relationship]-()\nWHERE p.name = \"Théo Gauchoux\"\nDELETE relationship, p\n```\n\nRemove a property in a specific node\n```\nMATCH (p:Person)\nWHERE p.name = \"Théo Gauchoux\"\nREMOVE p.age\n```\n*Pay attention to the `REMOVE`keyword, it's not `DELETE` !*\n\nRemove a label from a specific node\n```\nMATCH (p:Person)\nWHERE p.name = \"Théo Gauchoux\"\nDELETE p:Person\n```\n\nDelete entire database\n```\nMATCH (n)\nOPTIONAL MATCH (n)-[r]-()\nDELETE n, r\n```\n*Seriously, it's the `rm -rf /` of Cypher !*\n\n\nOther useful clauses\n---\n\n`PROFILE`\nBefore a query, show the execution plan of it.\n\n`COUNT(e)`\nCount entities (nodes or relationships) matching **e**.\n\n`LIMIT x`\nLimit the result to the x first results.\n\n\nSpecial hints\n---\n\n- There is just single-line comments in Cypher, with double-slash : // Comments\n- You can execute a Cypher script stored in a **.cql** file directly in Neo4j (it's an import). However, you can't have multiple statements in this file (separated by **;**).\n- Use the Neo4j shell to write Cypher, it's really awesome.\n- The Cypher will be the standard query language for all graph databases (known as **OpenCypher**)."
