
package pages

const Raku = "Raku (formerly Perl 6) is a highly capable, feature-rich programming language\nmade for at least the next hundred years.\n\nThe primary Raku compiler is called [Rakudo](http://rakudo.org), which runs on\nthe JVM and the [MoarVM](http://moarvm.com).\n\nMeta-note:\n\n* Although the pound sign (`#`) is used for sentences and notes, Pod-styled\n  comments (more below about them) are used whenever it's convenient.\n* `# OUTPUT:` is used to represent the output of a command to any standard\n   stream. If the output has a newline, it's represented by the `␤` symbol.\n   The output is always enclosed by angle brackets (`«` and `»`).\n* `#=>` represents the value of an expression, return value of a sub, etc.\n   In some cases, the value is accompanied by a comment.\n* Backticks are used to distinguish and highlight the language constructs\n  from the text.\n\n```perl6\n####################################################\n# 0. Comments\n####################################################\n\n# Single line comments start with a pound sign.\n\n#`( Multiline comments use #` and a quoting construct.\n  (), [], {}, 「」, etc, will work.\n)\n\n=for comment\nUse the same syntax for multiline comments to embed comments.\nfor #`(each element in) @array {\n    put #`(or print element) $_ #`(with newline);\n}\n\n# You can also use Pod-styled comments. For example:\n\n=comment This is a comment that extends until an empty\nnewline is found.\n\n=comment\nThe comment doesn't need to start in the same line as the directive.\n\n=begin comment\nThis comment is multiline.\n\nEmpty newlines can exist here too!\n=end comment\n\n####################################################\n# 1. Variables\n####################################################\n\n# In Raku, you declare a lexical variable using the `my` keyword:\nmy $variable;\n\n# Raku has 3 basic types of variables: scalars, arrays, and hashes.\n\n#\n# 1.1 Scalars\n#\n\n# Scalars represent a single value. They start with the `$` sigil:\nmy $str = 'String';\n\n# Double quotes allow for interpolation (which we'll see later):\nmy $str2 = \"$str\";\n\n# Variable names can contain but not end with simple quotes and dashes,\n# and can contain (and end with) underscores:\nmy $person's-belongings = 'towel'; # this works!\n\nmy $bool = True;             # `True` and `False` are Raku's boolean values.\nmy $inverse = !$bool;        # Invert a bool with the prefix `!` operator.\nmy $forced-bool = so $str;   # And you can use the prefix `so` operator\n$forced-bool = ?$str;        # to turn its operand into a Bool. Or use `?`.\n\n#\n# 1.2 Arrays and Lists\n#\n\n# Arrays represent multiple values. An array variable starts with the `@`\n# sigil. Unlike lists, from which arrays inherit, arrays are mutable.\n\nmy @array = 'a', 'b', 'c';\n# equivalent to:\nmy @letters = <a b c>;\n# In the previous statement, we use the quote-words (`<>`) term for array\n# of words, delimited by space. Similar to perl's qw, or Ruby's %w.\n\n@array = 1, 2, 4;\n\n# Array indices start at 0. Here the third element is being accessed.\nsay @array[2]; # OUTPUT: «4␤»\n\nsay \"Interpolate an array using []: @array[]\";\n# OUTPUT: «Interpolate an array using []: 1 2 3␤»\n\n@array[0]    = -1;     # Assigning a new value to an array index\n@array[0, 1] = 5, 6;   # Assigning multiple values\n\nmy @keys = 0, 2;\n@array[@keys] = @letters; # Assignment using an array containing index values\nsay @array;               # OUTPUT: «a 6 b␤»\n\n#\n# 1.3 Hashes, or key-value Pairs.\n#\n\n=begin comment\nHashes are pairs of keys and values. You can construct a `Pair` object\nusing the syntax `key => value`. Hash tables are very fast for lookup,\nand are stored unordered. Keep in mind that keys get \"flattened\" in hash\ncontext, and any duplicated keys are deduplicated.\n=end comment\nmy %hash = 'a' => 1, 'b' => 2;\n\n# Keys get auto-quoted when the fat comman (`=>`) is used. Trailing commas are\n# okay.\n%hash = a => 1, b => 2, ;\n\n# Even though hashes are internally stored differently than arrays,\n# Raku allows you to easily create a hash from an even numbered array:\n%hash = <key1 value1 key2 value2>;          # Or:\n%hash = \"key1\", \"value1\", \"key2\", \"value2\";\n\n%hash = key1 => 'value1', key2 => 'value2'; # same result as above\n\n# You can also use the \"colon pair\" syntax. This syntax is especially\n# handy for named parameters that you'll see later.\n%hash = :n(2),    # equivalent to `n => 2`\n        :is-even, # equivalent to `:is-even(True)` or `is-even => True`\n        :!is-odd, # equivalent to `:is-odd(False)` or `is-odd => False`\n;\n# The `:` (as in `:is-even`) and `:!` (as `:!is-odd`) constructs are known\n# as the `True` and `False` shortcuts respectively.\n\n=begin comment\nAs demonstrated in the example below, you can use {} to get the value from a key.\nIf it's a string without spaces, you can actually use the quote-words operator\n(`<>`). Since Raku doesn't have barewords, as Perl does, `{key1}` doesn't work\nthough.\n=end comment\nsay %hash{'n'};     # OUTPUT: «2␤», gets value associated to key 'n'\nsay %hash<is-even>; # OUTPUT: «True␤», gets value associated to key 'is-even'\n\n####################################################\n# 2. Subroutines\n####################################################\n\n# Subroutines, or functions as most other languages call them, are\n# created with the `sub` keyword.\nsub say-hello { say \"Hello, world\" }\n\n# You can provide (typed) arguments. If specified, the type will be checked\n# at compile-time if possible, otherwise at runtime.\nsub say-hello-to( Str $name ) {\n    say \"Hello, $name !\";\n}\n\n# A sub returns the last value of the block. Similarly, the semicolon in\n# the last expression can be omitted.\nsub return-value { 5 }\nsay return-value;      # OUTPUT: «5␤»\n\nsub return-empty { }\nsay return-empty;      # OUTPUT: «Nil␤»\n\n# Some control flow structures produce a value, for instance `if`:\nsub return-if {\n\tif True { \"Truthy\" }\n}\nsay return-if;         # OUTPUT: «Truthy␤»\n\n# Some don't, like `for`:\nsub return-for {\n    for 1, 2, 3 { 'Hi' }\n}\nsay return-for;        # OUTPUT: «Nil␤»\n\n=begin comment\nPositional arguments are required by default. To make them optional, use\nthe `?` after the parameters' names.\n\nIn the following example, the sub `with-optional` returns `(Any)` (Perl's\nnull-like value) if no argument is passed. Otherwise, it returns its argument.\n=end comment\nsub with-optional( $arg? ) {\n    $arg;\n}\nwith-optional;     # returns Any\nwith-optional();   # returns Any\nwith-optional(1);  # returns 1\n\n=begin comment\nYou can also give provide a default value when they're not passed. Doing\nthis make said parameter optional. Required parameters must come before\noptional ones.\n\nIn the sub `greeting`, the parameter `$type` is optional.\n=end comment\nsub greeting( $name, $type = \"Hello\" ) {\n  say \"$type, $name!\";\n}\n\ngreeting(\"Althea\");                 # OUTPUT: «Hello, Althea!␤»\ngreeting(\"Arthur\", \"Good morning\"); # OUTPUT: «Good morning, Arthur!␤»\n\n=begin comment\nYou can also, by using a syntax akin to the one of hashes (yay unified syntax!),\ndeclared named parameters and thus pass named arguments to a subroutine.\nBy default, named parameter are optional and will default to `Any`.\n=end comment\nsub with-named( $normal-arg, :$named ) {\n\tsay $normal-arg + $named;\n}\nwith-named(1, named => 6); # OUTPUT: «7␤»\n\n=begin comment\nThere's one gotcha to be aware of, here: If you quote your key, Raku\nwon't be able to see it at compile time, and you'll have a single `Pair`\nobject as a positional parameter, which means the function subroutine\n`with-named(1, 'named' => 6);` fails.\n=end comment\nwith-named(2, :named(5));  # OUTPUT: «7␤»\n\n# Similar to positional parameters, you can provide your named arguments with\n# default values.\nsub named-def( :$def = 5 ) {\n    say $def;\n}\nnamed-def;            # OUTPUT: «5»\nnamed-def(def => 15); # OUTPUT: «15»\n\n=begin comment\nIn order to make a named parameter mandatory, you can append `!` to the\nparameter. This is the inverse of `?`, which makes a required parameter\noptional.\n=end comment\n\nsub with-mandatory-named( :$str! )  {\n    say \"$str!\";\n}\nwith-mandatory-named(str => \"My String\"); # OUTPUT: «My String!␤»\n# with-mandatory-named;   # runtime error: \"Required named parameter not passed\"\n# with-mandatory-named(3);# runtime error: \"Too many positional parameters passed\"\n\n=begin comment\nIf a sub takes a named boolean argument, you can use the same \"short boolean\"\nhash syntax we discussed earlier.\n=end comment\nsub takes-a-bool( $name, :$bool ) {\n    say \"$name takes $bool\";\n}\ntakes-a-bool('config', :bool);  # OUTPUT: «config takes True␤»\ntakes-a-bool('config', :!bool); # OUTPUT: «config takes False␤»\n\n=begin comment\nSince parenthesis can be omitted when calling a subroutine, you need to use\n`&` in order to distinguish between a call to a sub with no arguments and\nthe code object.\n\nFor instance, in this example we must use `&` to store the sub `say-hello`\n(i.e., the sub's code object) in a variable, not a subroutine call.\n=end comment\nmy &s = &say-hello;\nmy &other-s = sub { say \"Anonymous function!\" }\n\n=begin comment\nA sub can have a \"slurpy\" parameter, or what one'd call a\n\"doesn't-matter-how-many\" parameter. This is Raku's way of supporting variadic\nfunctions. For this, you must use `*@` (slurpy) which will \"take everything\nelse\". You can have as many parameters *before* a slurpy one, but not *after*.\n=end comment\nsub as-many($head, *@rest) {\n    @rest.join(' / ') ~ \" !\";\n}\nsay as-many('Happy', 'Happy', 'Birthday');          # OUTPUT: «Happy / Birthday !␤»\nsay as-many('Happy', ['Happy', 'Birthday'], 'Day'); # OUTPUT: «Happy / Birthday / Day !␤»\n\n# Note that the splat (the *) did not consume the parameter before it.\n\n=begin comment\nThere are other two variations of slurpy parameters in Raku. The previous one\n(namely, `*@`), known as flattened slurpy, flattens passed arguments. The other\ntwo are `**@` and `+@` known as unflattened slurpy and \"single argument rule\"\nslurpy respectively. The unflattened slurpy doesn't flatten its listy\narguments (or Iterable ones).\n=end comment\nsub b(**@arr) { @arr.perl.say };\nb(['a', 'b', 'c']);             # OUTPUT: «[[\"a\", \"b\", \"c\"],]»\nb(1, $('d', 'e', 'f'), [2, 3]); # OUTPUT: «[1, (\"d\", \"e\", \"f\"), [2, 3]]»\nb(1, [1, 2], ([3, 4], 5));      # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»\n\n=begin comment\nOn the other hand, the \"single argument rule\" slurpy follows the \"single argument\nrule\" which dictates how to handle the slurpy argument based upon context and\nroughly states that if only a single argument is passed and that argument is\nIterable, that argument is used to fill the slurpy parameter array. In any\nother case, `+@` works like `**@`.\n=end comment\nsub c(+@arr) { @arr.perl.say };\nc(['a', 'b', 'c']);             # OUTPUT: «[\"a\", \"b\", \"c\"]␤»\nc(1, $('d', 'e', 'f'), [2, 3]); # OUTPUT: «[1, (\"d\", \"e\", \"f\"), [2, 3]]␤»\nc(1, [1, 2], ([3, 4], 5));      # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»\n\n=begin comment\nYou can call a function with an array using the \"argument list flattening\"\noperator `|` (it's not actually the only role of this operator,\nbut it's one of them).\n=end comment\nsub concat3($a, $b, $c) {\n    say \"$a, $b, $c\";\n}\nconcat3(|@array); # OUTPUT: «a, b, c␤»\n                  # `@array` got \"flattened\" as a part of the argument list\n\n####################################################\n# 3. Containers\n####################################################\n\n=begin comment\nIn Raku, values are actually stored in \"containers\". The assignment\noperator asks the container on the left to store the value on its right.\nWhen passed around, containers are marked as immutable which means that,\nin a function, you'll get an error if you try to mutate one of your\narguments. If you really need to, you can ask for a mutable container by\nusing the `is rw` trait.\n=end comment\nsub mutate( $n is rw ) {\n    $n++; # postfix ++ operator increments its argument but returns its old value\n}\nmy $m = 42;\nmutate $m; #=> 42, the value is incremented but the old value is returned\nsay $m;    # OUTPUT: «43␤»\n\n=begin comment\nThis works because we are passing the container $m to the `mutate` sub.\nIf we try to just pass a number instead of passing a variable, it won't work\nbecause there is no container being passed and integers are immutable by\nthemselves:\n\nmutate 42; # Parameter '$n' expected a writable container, but got Int value\n=end comment\n\n=begin comment\nSimilar error would be obtained, if a bound variable is passed to\nto the subroutine. In Raku, you bind a value to a variable using the binding\noperator `:=`.\n=end comment\nmy $v := 50; # binding 50 to the variable $v\n# mutate $v;   # Parameter '$n' expected a writable container, but got Int value\n\n=begin comment\nIf what you want is a copy instead, use the `is copy` trait which will\ncause the argument to be copied and allow you to modify the argument\ninside the routine without modifying the passed argument.\n\nA sub itself returns a container, which means it can be marked as `rw`.\nAlternatively, you can explicitly mark the returned container as mutable\nby using `return-rw` instead of `return`.\n=end comment\nmy $x = 42;\nmy $y = 45;\nsub x-store is rw { $x }\nsub y-store       { return-rw $y }\n\n# In this case, the parentheses are mandatory or else Raku thinks that\n# `x-store` and `y-store` are identifiers.\nx-store() = 52;\ny-store() *= 2;\n\nsay $x; # OUTPUT: «52␤»\nsay $y; # OUTPUT: «90␤»\n\n####################################################\n# 4.Control Flow Structures\n####################################################\n\n#\n# 4.1 if/if-else/if-elsif-else/unless\n#\n\n=begin comment\nBefore talking about `if`, we need to know which values are \"truthy\"\n(represent `True`), and which are \"falsey\" (represent `False`). Only these\nvalues are falsey: 0, (), {}, \"\", Nil, a type (like `Str`, `Int`, etc.) and\nof course, `False` itself. Any other value is truthy.\n=end comment\nmy $number = 5;\nif $number < 5 {\n    say \"Number is less than 5\"\n}\nelsif $number == 5 {\n    say \"Number is equal to 5\"\n}\nelse {\n    say \"Number is greater than 5\"\n}\n\nunless False {\n    say \"It's not false!\";\n}\n\n# `unless` is the equivalent of `if not (X)` which inverts the sense of a\n# conditional statement. However, you cannot use `else` or `elsif` with it.\n\n# As you can see, you don't need parentheses around conditions. However, you\n# do need the curly braces around the \"body\" block. For example,\n# `if (True) say 'It's true';` doesn't work.\n\n# You can also use their statement modifier (postfix) versions:\nsay \"Quite truthy\" if True;      # OUTPUT: «Quite truthy␤»\nsay \"Quite falsey\" unless False; # OUTPUT: «Quite falsey␤»\n\n=begin comment\nThe ternary operator (`??..!!`) is structured as follows `condition ??\nexpression1 !! expression2` and it returns expression1 if the condition is\ntrue. Otherwise, it returns expression2.\n=end comment\nmy $age = 30;\nsay $age > 18 ?? \"You are an adult\" !! \"You are under 18\";\n# OUTPUT: «You are an adult␤»\n\n#\n# 4.2 with/with-else/with-orwith-else/without\n#\n\n=begin comment\nThe `with` statement is like `if`, but it tests for definedness rather than\ntruth, and it topicalizes on the condition, much like `given` which will\nbe discussed later.\n=end comment\nmy $s = \"raku\";\nwith   $s.index(\"r\") { say \"Found a at $_\"      }\norwith $s.index(\"k\") { say \"Found c at $_\"      }\nelse                 { say \"Didn't find r or k\" }\n\n# Similar to `unless` that checks un-truthiness, you can use `without` to\n# check for undefined-ness.\nmy $input01;\nwithout $input01 {\n    say \"No input given.\"\n}\n# OUTPUT: «No input given.␤»\n\n# There are also statement modifier versions for both `with` and `without`.\nmy $input02 = 'Hello';\nsay $input02 with $input02;               # OUTPUT: «Hello␤»\nsay \"No input given.\" without $input02;\n\n#\n# 4.3 given/when, or Raku's switch construct\n#\n\n=begin comment\n`given...when` looks like other languages' `switch`, but is much more\npowerful thanks to smart matching and Raku's \"topic variable\", `$_`.\n\nThe topic variable `$_ `contains the default argument of a block, a loop's\ncurrent iteration (unless explicitly named), etc.\n\n`given` simply puts its argument into `$_` (like a block would do),\n and `when` compares it using the \"smart matching\" (`~~`) operator.\n\nSince other Raku constructs use this variable (as said before, like `for`,\nblocks, `with` statement etc), this means the powerful `when` is not only\napplicable along with a `given`, but instead anywhere a `$_` exists.\n=end comment\n\ngiven \"foo bar\" {\n    say $_;            # OUTPUT: «foo bar␤»\n\n    # Don't worry about smart matching yet. Just know `when` uses it. This is\n    # equivalent to `if $_ ~~ /foo/`.\n    when /foo/ {\n        say \"Yay !\";\n    }\n\n    # smart matching anything with `True` is `True`, i.e. (`$a ~~ True`)\n    # so you can also put \"normal\" conditionals. For example, this `when` is\n    # equivalent to this `if`: `if $_ ~~ ($_.chars > 50) {...}`\n    # which means: `if $_.chars > 50 {...}`\n    when $_.chars > 50 {\n        say \"Quite a long string !\";\n    }\n\n    # same as `when *` (using the Whatever Star)\n    default {\n        say \"Something else\"\n    }\n}\n\n#\n# 4.4 Looping constructs\n#\n\n# The `loop` construct is an infinite loop if you don't pass it arguments, but\n# can also be a C-style `for` loop:\nloop {\n    say \"This is an infinite loop !\";\n    last;\n}\n# In the previous example, `last` breaks out of the loop very much\n# like the `break` keyword in other languages.\n\n# The `next` keyword skips to the next iteration, like `continue` in other\n# languages. Note that you can also use postfix conditionals, loops, etc.\nloop (my $i = 0; $i < 5; $i++) {\n    next if $i == 3;\n    say \"This is a C-style for loop!\";\n}\n\n# The `for` constructs iterates over a list of elements.\nmy @odd-array = 1, 3, 5, 7, 9;\n\n# Accessing the array's elements with the topic variable $_.\nfor @odd-array {\n    say \"I've got $_ !\";\n}\n\n# Accessing the array's elements with a \"pointy block\", `->`.\n# Here each element is read-only.\nfor @odd-array -> $variable {\n    say \"I've got $variable !\";\n}\n\n# Accessing the array's elements with a \"doubly pointy block\", `<->`.\n# Here each element is read-write so mutating `$variable` mutates\n# that element in the array.\nfor @odd-array <-> $variable {\n    say \"I've got $variable !\";\n}\n\n# As we saw with `given`, a `for` loop's default \"current iteration\" variable\n# is `$_`. That means you can use `when` in a `for`loop just like you were\n# able to in a `given`.\nfor @odd-array {\n    say \"I've got $_\";\n\n    # This is also allowed. A dot call with no \"topic\" (receiver) is sent to\n    # `$_` (topic variable) by default.\n    .say;\n\n    # This is equivalent to the above statement.\n    $_.say;\n}\n\nfor @odd-array {\n    # You can...\n    next if $_ == 3; # Skip to the next iteration (`continue` in C-like lang.)\n    redo if $_ == 4; # Re-do iteration, keeping the same topic variable (`$_`)\n    last if $_ == 5; # Or break out of loop (like `break` in C-like lang.)\n}\n\n# The \"pointy block\" syntax isn't specific to the `for` loop. It's just a way\n# to express a block in Raku.\nsub long-computation { \"Finding factors of large primes\" }\nif long-computation() -> $result {\n    say \"The result is $result.\";\n}\n\n####################################################\n# 5. Operators\n####################################################\n\n=begin comment\nSince Perl languages are very much operator-based languages, Raku\noperators are actually just funny-looking subroutines, in syntactic\ncategories, like infix:<+> (addition) or prefix:<!> (bool not).\n\nThe categories are:\n    - \"prefix\": before (like `!` in `!True`).\n    - \"postfix\": after (like `++` in `$a++`).\n    - \"infix\": in between (like `*` in `4 * 3`).\n    - \"circumfix\": around (like `[`-`]` in `[1, 2]`).\n    - \"post-circumfix\": around, after another term (like `{`-`}` in\n                   `%hash{'key'}`)\n\nThe associativity and precedence list are explained below.\n\nAlright, you're set to go!\n=end comment\n\n#\n# 5.1 Equality Checking\n#\n\n# `==` is numeric comparison\nsay 3 == 4; # OUTPUT: «False␤»\nsay 3 != 4; # OUTPUT: «True␤»\n\n# `eq` is string comparison\nsay 'a' eq 'b';  # OUTPUT: «False␤»\nsay 'a' ne 'b';  # OUTPUT: «True␤», not equal\nsay 'a' !eq 'b'; # OUTPUT: «True␤», same as above\n\n# `eqv` is canonical equivalence (or \"deep equality\")\nsay (1, 2) eqv (1, 3); # OUTPUT: «False␤»\nsay (1, 2) eqv (1, 2); # OUTPUT: «True␤»\nsay Int === Int;       # OUTPUT: «True␤»\n\n# `~~` is the smart match operator which aliases the left hand side to $_ and\n# then evaluates the right hand side.\n# Here are some common comparison semantics:\n\n# String or numeric equality\nsay 'Foo' ~~ 'Foo'; # OUTPUT: «True␤», if strings are equal.\nsay 12.5 ~~ 12.50;  # OUTPUT: «True␤», if numbers are equal.\n\n# Regex - For matching a regular expression against the left side.\n# Returns a `Match` object, which evaluates as True if regexp matches.\nmy $obj = 'abc' ~~ /a/;\nsay $obj;       # OUTPUT: «｢a｣␤»\nsay $obj.WHAT;  # OUTPUT: «(Match)␤»\n\n# Hashes\nsay 'key' ~~ %hash; # OUTPUT: «True␤», if key exists in hash.\n\n# Type - Checks if left side \"is of type\" (can check superclasses and roles).\nsay 1 ~~ Int;       # OUTPUT: «True␤»\n\n# Smart-matching against a boolean always returns that boolean (and will warn).\nsay 1 ~~ True;        # OUTPUT: «True␤», smartmatch against True always matches\nsay False.so ~~ True; # OUTPUT: «True␤», use .so for truthiness\n\n# General syntax is `$arg ~~ &bool-returning-function;`. For a complete list\n# of combinations, refer to the table at:\n# https://docs.raku.org/language/operators#index-entry-smartmatch_operator\n\n# Of course, you also use `<`, `<=`, `>`, `>=` for numeric comparison.\n# Their string equivalent are also available: `lt`, `le`, `gt`, `ge`.\nsay 3 > 4;       # OUTPUT: «False␤»\nsay 3 >= 4;      # OUTPUT: «False␤»\nsay 3 < 4;       # OUTPUT: «True␤»\nsay 3 <= 4;      # OUTPUT: «True␤»\nsay 'a' gt 'b';  # OUTPUT: «False␤»\nsay 'a' ge 'b';  # OUTPUT: «False␤»\nsay 'a' lt 'b';  # OUTPUT: «True␤»\nsay 'a' le 'b';  # OUTPUT: «True␤»\n\n#\n# 5.2 Range constructor\n#\n\nsay 3 .. 7;          # OUTPUT: «3..7␤»,   both included.\nsay 3 ..^ 7;         # OUTPUT: «3..^7␤»,  exclude right endpoint.\nsay 3 ^.. 7;         # OUTPUT: «3^..7␤»,  exclude left endpoint.\nsay 3 ^..^ 7;        # OUTPUT: «3^..^7␤», exclude both endpoints.\n\n# The range 3 ^.. 7 is similar like 4 .. 7 when we only consider integers.\n# But when we consider decimals:\n\nsay 3.5 ~~ 4 .. 7;\t # OUTPUT: «False␤»\nsay 3.5 ~~ 3 ^.. 7;\t # OUTPUT: «True␤»,\n\n# This is because the range `3 ^.. 7` only excludes anything strictly\n# equal to 3. Hence, it contains decimals greater than 3. This could\n# mathematically be described as 3.5 ∈ (3,7] or in set notation,\n# 3.5 ∈ { x | 3 < x ≤ 7 }.\n\nsay 3 ^.. 7 ~~ 4 .. 7; # OUTPUT: «False␤»\n\n# This also works as a shortcut for `0..^N`:\nsay ^10;             # OUTPUT: «^10␤», which means 0..^10\n\n# This also allows us to demonstrate that Raku has lazy/infinite arrays,\n# using the Whatever Star:\nmy @natural = 1..*; # 1 to Infinite! Equivalent to `1..Inf`.\n\n# You can pass ranges as subscripts and it'll return an array of results.\nsay @natural[^10]; # OUTPUT: «1 2 3 4 5 6 7 8 9 10␤», doesn't run out of memory!\n\n=begin comment\nNOTE: when reading an infinite list, Raku will \"reify\" the elements\nit needs, then keep them in memory. They won't be calculated more than once.\nIt also will never calculate more elements that are needed.\n=end comment\n\n# An array subscript can also be a closure. It'll be called with the array's\n# length as the argument. The following two examples are equivalent:\nsay join(' ', @array[15..*]);            # OUTPUT: «15 16 17 18 19␤»\nsay join(' ', @array[-> $n { 15..$n }]); # OUTPUT: «15 16 17 18 19␤»\n\n# NOTE: if you try to do either of those with an infinite array, you'll\n# trigger an infinite loop (your program won't finish).\n\n# You can use that in most places you'd expect, even when assigning to an array:\nmy @numbers = ^20;\n\n# Here the numbers increase by 6, like an arithmetic sequence; more on the\n# sequence (`...`) operator later.\nmy @seq =  3, 9 ... * > 95;  # 3 9 15 21 27 [...] 81 87 93 99;\n\n# In this example, even though the sequence is infinite, only the 15\n# needed values will be calculated.\n@numbers[5..*] = 3, 9 ... *;\nsay @numbers; # OUTPUT: «0 1 2 3 4 3 9 15 21 [...] 81 87␤», only 20 values\n\n#\n# 5.3 and (&&), or (||)\n#\n\n# Here `and` calls `.Bool` on both 3 and 4 and gets `True` so it returns\n# 4 since both are `True`.\nsay (3 and 4);     # OUTPUT: «4␤», which is truthy.\nsay (3 and 0);     # OUTPUT: «0␤»\nsay (0 and 4);     # OUTPUT: «0␤»\n\n# Here `or` calls `.Bool` on `0` and `False` which are both `False`\n# so it returns `False` since both are `False`.\nsay (0 or False); # OUTPUT: «False␤».\n\n# Both `and` and `or` have tighter versions which also shortcut circuits.\n# They're `&&` and `||` respectively.\n\n# `&&` returns the first operand that evaluates to `False`. Otherwise,\n# it returns the last operand.\nmy ($a, $b, $c, $d, $e) = 1, 0, False, True, 'pi';\nsay $a && $b && $c; # OUTPUT: «0␤», the first falsey value\nsay $a && $b && $c; # OUTPUT: «False␤», the first falsey value\nsay $a && $d && $e; # OUTPUT: «pi␤», last operand since everthing before is truthy\n\n# `||` returns the first argument that evaluates to `True`.\nsay $b || $a || $d; # OUTPUT: «1␤»\nsay $e || $d || $a; # OUTPUT: «pi␤»\n\n# And because you're going to want them, you also have compound assignment\n# operators:\n$a *= 2;        # multiply and assignment. Equivalent to $a = $a * 2;\n$b %%= 5;       # divisible by and assignment. Equivalent to $b = $b %% 2;\n$c div= 3;      # return divisor and assignment. Equivalent to $c = $c div 3;\n$d mod= 4;      # return remainder and assignment. Equivalent to $d = $d mod 4;\n@array .= sort; # calls the `sort` method and assigns the result back\n\n####################################################\n# 6. More on subs!\n####################################################\n\n# As we said before, Raku has *really* powerful subs. We're going\n# to see a few more key concepts that make them better than in any\n# other language :-).\n\n#\n# 6.1 Unpacking!\n#\n\n# Unpacking is the ability to \"extract\" arrays and keys\n# (AKA \"destructuring\"). It'll work in `my`s and in parameter lists.\nmy ($f, $g) = 1, 2;\nsay $f;                  # OUTPUT: «1␤»\nmy ($, $, $h) = 1, 2, 3; # keep the non-interesting values anonymous (`$`)\nsay $h;                  # OUTPUT: «3␤»\n\nmy ($head, *@tail) = 1, 2, 3; # Yes, it's the same as with \"slurpy subs\"\nmy (*@small) = 1;\n\nsub unpack_array( @array [$fst, $snd] ) {\n  say \"My first is $fst, my second is $snd! All in all, I'm @array[].\";\n  # (^ remember the `[]` to interpolate the array)\n}\nunpack_array(@tail);\n# OUTPUT: «My first is 2, my second is 3! All in all, I'm 2 3.␤»\n\n# If you're not using the array itself, you can also keep it anonymous,\n# much like a scalar:\nsub first-of-array( @ [$fst] ) { $fst }\nfirst-of-array(@small); #=> 1\n\n# However calling `first-of-array(@tail);` will throw an error (\"Too many\n# positional parameters passed\"), which means the `@tail` has too many\n# elements.\n\n# You can also use a slurpy parameter. You could keep `*@rest` anonymous\n# Here, `@rest` is `(3,)`, since `$fst` holds the `2`. This results\n# since the length (.elems) of `@rest` is 1.\nsub slurp-in-array(@ [$fst, *@rest]) {\n    say $fst + @rest.elems;           \n}\nslurp-in-array(@tail); # OUTPUT: «3␤»\n\n# You could even extract on a slurpy (but it's pretty useless ;-).)\nsub fst(*@ [$fst]) { # or simply: `sub fst($fst) { ... }`\n    say $fst;\n}\nfst(1);    # OUTPUT: «1␤»\n\n# Calling `fst(1, 2);` will throw an error (\"Too many positional parameters\n# passed\") though. After all, the `fst` sub declares only a single positional\n# parameter.\n\n=begin comment\nYou can also destructure hashes (and classes, which you'll learn about later).\nThe syntax is basically the same as\n`%hash-name (:key($variable-to-store-value-in))`.\nThe hash can stay anonymous if you only need the values you extracted.\n\nIn order to call the function, you must supply a hash wither created with\ncurly braces or with `%()` (recommended). Alternatively, you can pass\na variable that contains a hash.\n=end comment\n\nsub key-of( % (:value($val), :qua($qua)) ) {\n \tsay \"Got value $val, $qua time\" ~~\n        $qua == 1 ?? '' !! 's';\n}\n\nmy %foo-once = %(value => 'foo', qua => 1);\nkey-of({value => 'foo', qua => 2});  # OUTPUT: «Got val foo, 2 times.␤»\nkey-of(%(value => 'foo', qua => 0)); # OUTPUT: «Got val foo, 0 times.␤»\nkey-of(%foo-once);                   # OUTPUT: «Got val foo, 1 time.␤»\n\n# The last expression of a sub is returned automatically (though you may\n# indicate explicitly by using the `return` keyword, of course):\nsub next-index( $n ) {\n \t$n + 1;\n}\nmy $new-n = next-index(3); # $new-n is now 4\n\n=begin comment\nThis is true for everything, except for the looping constructs (due to\nperformance reasons): there's no reason to build a list if we're just going to\ndiscard all the results. If you still want to build one, you can use the\n`do` statement prefix or the `gather` prefix, which we'll see later:\n=end comment\n\nsub list-of( $n ) {\n \tdo for ^$n { $_ }\n}\nmy @list3 = list-of(3); #=> (0, 1, 2)\n\n#\n# 6.2 Lambdas (or anonymous subroutines)\n#\n\n# You can create a lambda by using a pointy block (`-> {}`), a\n# block (`{}`) or creating a `sub` without a name.\n\nmy &lambda1 = -> $argument {\n\t\"The argument passed to this lambda is $argument\"\n}\n\nmy &lambda2 = {\n\t\"The argument passed to this lambda is $_\"\n}\n\nmy &lambda3 = sub ($argument) {\n\t\"The argument passed to this lambda is $argument\"\n}\n\n=begin comment\nBoth pointy blocks and blocks are pretty much the same thing, except that\nthe former can take arguments, and that the latter can be mistaken as\na hash by the parser. That being said, blocks can declare what's known\nas placeholders parameters through the twigils `$^` (for positional\nparameters) and `$:` (for named parameters). More on them later on.\n=end comment\n\nmy &mult = { $^numbers * $:times }\nsay mult 4, :times(6); #=> «24␤»\n\n# Both pointy blocks and blocks are quite versatile when working with functions\n# that accepts other functions such as `map`, `grep`, etc. For example,\n# we add 3 to each value of an array using the `map` function with a lambda:\nmy @nums = 1..4;\nmy @res1 = map -> $v { $v + 3 }, @nums; # pointy block, explicit parameter\nmy @res2 = map { $_ + 3 },       @nums; # block using an implicit parameter\nmy @res3 = map { $^val + 3 },    @nums; # block with placeholder parameter\n\n=begin comment\nA sub (`sub {}`) has different semantics than a block (`{}` or `-> {}`):\nA block doesn't have a \"function context\" (though it can have arguments),\nwhich means that if you return from it, you're going to return from the\nparent function.\n=end comment\n\n# Compare:\nsub is-in( @array, $elem ) {\n   say map({ return True if $_ == $elem }, @array);\n   say 'Hi';\n}\n\n# with:\nsub truthy-array( @array ) {\n    say map sub ($i) { $i ?? return True !! return False }, @array;\n    say 'Hi';\n}\n\n=begin comment\nIn the `is-in` sub, the block will `return` out of the `is-in` sub once the\ncondition evaluates to `True`, the loop won't be run anymore and the\nfollowing statement won't be executed. The last statement is only executed\nif the block never returns.\n\nOn the contrary, the `truthy-array` sub will produce an array of `True` and\n`False`, which will printed, and always execute the last execute statement.\nThus, the `return` only returns from the anonymous `sub`\n=end comment\n\n=begin comment\nThe `anon` declarator can be used to create an anonymous sub from a\nregular subroutine. The regular sub knows its name but its symbol is\nprevented from getting installed in the lexical scope, the method table\nand everywhere else.\n=end comment\nmy $anon-sum = anon sub summation(*@a) { [+] @a }\nsay $anon-sum.name;     # OUTPUT: «summation␤»\nsay $anon-sum(2, 3, 5); # OUTPUT: «10␤»\n#say summation;         # Error: Undeclared routine: ...\n\n# You can also use the Whatever Star to create an anonymous subroutine.\n# (it'll stop at the furthest operator in the current expression).\n# The following is the same as `{$_ + 3 }`, `-> { $a + 3 }`,\n# `sub ($a) { $a + 3 }`, or even `{$^a + 3}` (more on this later).\nmy @arrayplus3v0 = map * + 3, @nums;\n\n# The following is the same as `-> $a, $b { $a + $b + 3 }`,\n# `sub ($a, $b) { $a + $b + 3 }`, or `{ $^a + $^b + 3 }` (more on this later).\nmy @arrayplus3v1 = map * + * + 3, @nums;\n\nsay (*/2)(4); # OUTPUT: «2␤», immediately execute the Whatever function created.\nsay ((*+3)/5)(5); # OUTPUT: «1.6␤», it works even in parens!\n\n# But if you need to have more than one argument (`$_`) in a block (without\n# wanting to resort to `-> {}`), you can also either `$^` and `$:` which\n# declared placeholder parameters or self-declared positional/named parameters.\nsay map { $^a + $^b + 3 }, @nums;\n\n# which is equivalent to the following which uses a `sub`:\nmap sub ($a, $b) { $a + $b + 3 }, @nums;\n\n# Placeholder parameters are sorted lexicographically so the following two\n# statements are equivalent:\nsay sort           { $^b <=> $^a }, @nums;\nsay sort -> $a, $b { $b  <=> $a  }, @nums;\n\n#\n# 6.3 Multiple Dispatch\n#\n\n# Raku can decide which variant of a `sub` to call based on the type of the\n# arguments, or on arbitrary preconditions, like with a type or `where`:\n\n# with types:\nmulti sub sayit( Int $n ) { # note the `multi` keyword here\n    say \"Number: $n\";\n}\nmulti sayit( Str $s ) {     # a multi is a `sub` by default\n    say \"String: $s\";\n}\nsayit \"foo\"; # OUTPUT: «String: foo␤»\nsayit 25;    # OUTPUT: «Number: 25␤»\nsayit True;  # fails at *compile time* with \"calling 'sayit' will never\n             # work with arguments of types ...\"\n\n# with arbitrary preconditions (remember subsets?):\nmulti is-big(Int $n where * > 50) { \"Yes!\" }    # using a closure\nmulti is-big(Int $n where {$_ > 50}) { \"Yes!\" } # similar to above\nmulti is-big(Int $ where 10..50)  { \"Quite.\" }  # Using smart-matching\nmulti is-big(Int $) { \"No\" }\n\nsubset Even of Int where * %% 2;\nmulti odd-or-even(Even) { \"Even\" } # Using the type. We don't name the argument.\nmulti odd-or-even($) { \"Odd\" }     # \"everything else\" hence the $ variable\n\n# You can even dispatch based on the presence of positional and named arguments:\nmulti with-or-without-you($with) {\n    say \"I wish I could but I can't\";\n}\nmulti with-or-without-you(:$with) {\n    say \"I can live! Actually, I can't.\";\n}\nmulti with-or-without-you {\n    say \"Definitely can't live.\";\n}\n\n=begin comment\nThis is very, very useful for many purposes, like `MAIN` subs (covered\nlater), and even the language itself uses it in several places.\n\nFor example, the `is` trait is actually a `multi sub` named `trait_mod:<is>`,\nand it works off that. Thus, `is rw`, is simply a dispatch to a function with\nthis signature `sub trait_mod:<is>(Routine $r, :$rw!) {}`\n=end comment\n\n####################################################\n# 7. About types...\n####################################################\n\n=begin comment\nRaku is gradually typed. This means you can specify the type of your\nvariables/arguments/return types, or you can omit the type annotations in\nin which case they'll default to `Any`. Obviously you get access to a few\nbase types, like `Int` and `Str`. The constructs for declaring types are\n`subset`, `class`, `role`, etc. which you'll see later.\n\nFor now, let us examine `subset` which is a \"sub-type\" with additional\nchecks. For example, \"a very big integer is an `Int` that's greater than 500\".\nYou can specify the type you're subtyping (by default, `Any`), and add\nadditional checks with the `where` clause.\n=end comment\nsubset VeryBigInteger of Int where * > 500;\n\n# Or the set of the whole numbers:\nsubset WholeNumber of Int where * >= 0;\nmy WholeNumber $whole-six    = 6;  # OK\n#my WholeNumber $nonwhole-one = -1; # Error: type check failed...\n\n# Or the set of Positive Even Numbers whose Mod 5 is 1. Notice we're\n# using the previously defined WholeNumber subset.\nsubset PENFO of WholeNumber where { $_ %% 2 and $_ mod 5 == 1 };\nmy PENFO $yes-penfo = 36;  # OK\n#my PENFO $no-penfo  = 2;  # Error: type check failed...\n\n####################################################\n# 8. Scoping\n####################################################\n\n=begin comment\nIn Raku, unlike many scripting languages, (such as Python, Ruby, PHP),\nyou must declare your variables before using them. The `my` declarator\nwe've used so far uses \"lexical scoping\". There are a few other declarators,\n(`our`, `state`, ..., ) which we'll see later. This is called\n\"lexical scoping\", where in inner blocks, you can access variables from\nouter blocks.\n=end comment\n\nmy $file_scoped = 'Foo';\nsub outer {\n    my $outer_scoped = 'Bar';\n    sub inner {\n        say \"$file_scoped $outer_scoped\";\n    }\n    &inner; # return the function\n}\nouter()();  # OUTPUT: «Foo Bar␤»\n\n# As you can see, `$file_scoped` and `$outer_scoped` were captured.\n# But if we were to try and use `$outer_scoped` outside the `outer` sub,\n# the variable would be undefined (and you'd get a compile time error).\n\n####################################################\n# 9. Twigils\n####################################################\n\n=begin comment\nThere are many special `twigils` (composed sigils) in Raku. Twigils\ndefine a variable's scope.\nThe `*` and `?` twigils work on standard variables:\n    * for dynamic variables\n    ? for compile-time variables\n\nThe `!` and the `.` twigils are used with Raku's objects:\n    ! for attributes (instance attribute)\n    . for methods (not really a variable)\n=end comment\n\n#\n# `*` twigil: Dynamic Scope\n#\n\n# These variables use the `*` twigil to mark dynamically-scoped variables.\n# Dynamically-scoped variables are looked up through the caller, not through\n# the outer scope.\n\nmy $*dyn_scoped_1 = 1;\nmy $*dyn_scoped_2 = 10;\n\nsub say_dyn {\n    say \"$*dyn_scoped_1 $*dyn_scoped_2\";\n}\n\nsub call_say_dyn {\n    # Defines $*dyn_scoped_1 only for this sub.\n    my $*dyn_scoped_1 = 25;\n\n    # Will change the value of the file scoped variable.\n    $*dyn_scoped_2 = 100;  \n\n    # $*dyn_scoped 1 and 2 will be looked for in the call.\n    say_dyn();  # OUTPUT: «25 100␤»\n\n    # The call to `say_dyn` uses the value of $*dyn_scoped_1 from inside\n    # this sub's lexical scope even though the blocks aren't nested (they're\n    # call-nested).                     \n}\nsay_dyn();      # OUTPUT: «1 10␤»\n\n# Uses $*dyn_scoped_1 as defined in `call_say_dyn` even though we are calling it\n# from outside.\ncall_say_dyn(); # OUTPUT: «25 100␤»\n\n# We changed the value of $*dyn_scoped_2 in `call_say_dyn` so now its\n# value has changed.\nsay_dyn();      # OUTPUT: «1 100␤»\n\n# TODO: Add information about remaining twigils\n\n####################################################\n# 10. Object Model\n####################################################\n\n=begin comment\nTo call a method on an object, add a dot followed by the method name:\n`$object.method`\n\nClasses are declared with the `class` keyword. Attributes are declared\nwith the `has` keyword, and methods declared with the `method` keyword.\n\nEvery attribute that is private uses the `!` twigil. For example: `$!attr`.\nImmutable public attributes use the `.` twigil which creates a read-only\nmethod named after the attribute. In fact, declaring an attribute with `.`\nis equivalent to declaring the same attribute with `!` and then creating\na read-only method with the attribute's name. However, this is done for us\nby Raku automatically. The easiest way to remember the `$.` twigil is\nby comparing it to how methods are called.\n\nRaku's object model (\"SixModel\") is very flexible, and allows you to\ndynamically add methods, change semantics, etc... Unfortunately, these will\nnot all be covered here, and you should refer to:\nhttps://docs.raku.org/language/objects.html.\n=end comment\n\nclass Human {\n    has Str $.name;           # `$.name` is immutable but with an accessor method.\n    has Str $.bcountry;       # Use `$!bcountry` to modify it inside the class.\n\thas Str $.ccountry is rw; # This attribute can be modified from outside.\n\thas Int $!age = 0;        # A private attribute with default value.\n\n\tmethod birthday {\n\t\t$!age += 1; # Add a year to human's age\n\t}\n\n\tmethod get-age {\n\t\treturn $!age;\n\t}\n\n\t# This method is private to the class. Note the `!` before the\n\t# method's name.\n\tmethod !do-decoration {\n    \treturn \"$!name born in $!bcountry and now lives in $!ccountry.\"\n  \t}\n\n  \t# This method is public, just like `birthday` and `get-age`.\n  \tmethod get-info {\n        # Invoking a method on `self` inside the class.\n        # Use `self!priv-method` for private method.\n  \t\tsay self!do-decoration;\n\n  \t\t# Use `self.public-method` for public method.\n  \t\tsay \"Age: \", self.get-age;\n  \t}\n};\n\n# Create a new instance of Human class.\n# NOTE: Only attributes declared with the `.` twigil can be set via the\n# default constructor (more later on). This constructor only accepts named\n# arguments.\nmy $person1 = Human.new(\n\tname     => \"Jord\",\n\tbcountry => \"Togo\",\n\tccountry => \"Togo\"\n);\n\n# Make human 10 years old.\n$person1.birthday for 1..10;\n\nsay $person1.name;     # OUTPUT: «Jord␤»\nsay $person1.bcountry; # OUTPUT: «Togo␤»\nsay $person1.ccountry; # OUTPUT: «Togo␤»\nsay $person1.get-age;  # OUTPUT: «10␤»\n\n# This fails, because the `has $.bcountry`is immutable. Jord can't change\n# his birthplace.\n# $person1.bcountry = \"Mali\";\n\n# This works because the `$.ccountry` is mutable (`is rw`). Now Jord's\n# current country is France.\n$person1.ccountry = \"France\";\n\n# Calling methods on the instance objects.\n$person1.birthday;      #=> 1\n$person1.get-info;      #=> Jord born in Togo and now lives in France. Age: 10\n# $person1.do-decoration; # This fails since the method `do-decoration` is private.\n\n#\n# 10.1 Object Inheritance\n#\n\n=begin comment\nRaku also has inheritance (along with multiple inheritance). While\nmethods are inherited, submethods are not. Submethods are useful for\nobject construction and destruction tasks, such as `BUILD`, or methods that\nmust be overridden by subtypes. We will learn about `BUILD` later on.\n=end  comment\n\nclass Parent {\n  \thas $.age;\n \thas $.name;\n\n  \t# This submethod won't be inherited by the Child class.\n  \tsubmethod favorite-color {\n    \tsay \"My favorite color is Blue\";\n  \t}\n\n  \t# This method is inherited\n  \tmethod talk { say \"Hi, my name is $!name\" }\n}\n\n# Inheritance uses the `is` keyword\nclass Child is Parent {\n  \tmethod talk { say \"Goo goo ga ga\" }\n  \t# This shadows Parent's `talk` method.\n  \t# This child hasn't learned to speak yet!\n}\n\nmy Parent $Richard .= new(age => 40, name => 'Richard');\n$Richard.favorite-color;  # OUTPUT: «My favorite color is Blue␤»\n$Richard.talk;            # OUTPUT: «Hi, my name is Richard␤»\n# $Richard is able to access the submethod and he knows how to say his name.\n\nmy Child $Madison .= new(age => 1, name => 'Madison');\n$Madison.talk;            # OUTPUT: «Goo goo ga ga␤», due to the overridden method.\n# $Madison.favorite-color # does not work since it is not inherited.\n\n=begin comment\nWhen you use `my T $var`, `$var` starts off with `T` itself in it, so you can\ncall `new` on it. (`.=` is just the dot-call and the assignment operator).\nThus, `$a .= b` is the same as `$a = $a.b`. Also note that `BUILD` (the method\ncalled inside `new`) will set parent's properties too, so you can pass `val =>\n5`.\n=end comment\n\n#\n# 10.2 Roles, or Mixins\n#\n\n# Roles are supported too (which are called Mixins in other languages)\nrole PrintableVal {\n  \thas $!counter = 0;\n  \tmethod print {\n    \tsay $.val;\n  \t}\n}\n\n# you \"apply\" a role (or mixin) with the `does` keyword:\nclass Item does PrintableVal {\n  \thas $.val;\n\n    =begin comment\n    When `does`-ed, a `role` literally \"mixes in\" the class:\n    the methods and attributes are put together, which means a class\n    can access the private attributes/methods of its roles (but\n    not the inverse!):\n    =end comment\n  \tmethod access {\n  \t\tsay $!counter++;\n  \t}\n\n    =begin comment\n    However, this: method print {} is ONLY valid when `print` isn't a `multi`\n    with the same dispatch. This means a parent class can shadow a child class's\n    `multi print() {}`, but it's an error if a role does)\n\n    NOTE: You can use a role as a class (with `is ROLE`). In this case,\n    methods will be shadowed, since the compiler will consider `ROLE`\n    to be a class.\n    =end comment\n}\n\n####################################################\n# 11. Exceptions\n####################################################\n\n=begin comment\nExceptions are built on top of classes, in the package `X` (like `X::IO`).\nIn Raku, exceptions are automatically 'thrown':\n\nopen 'foo';   # OUTPUT: «Failed to open file foo: no such file or directory␤»\n\nIt will also print out what line the error was thrown at\nand other error info.\n=end comment\n\n# You can throw an exception using `die`. Here it's been commented out to\n# avoid stopping the program's execution:\n# die 'Error!'; # OUTPUT: «Error!␤»\n\n# Or more explicitly (commented out too):\n# X::AdHoc.new(payload => 'Error!').throw; # OUTPUT: «Error!␤»\n\n=begin comment\nIn Raku, `orelse` is similar to the `or` operator, except it only matches\nundefined variables instead of anything evaluating as `False`.\nUndefined values include: `Nil`, `Mu` and `Failure` as well as `Int`, `Str`\nand other types that have not been initialized to any value yet.\nYou can check if something is defined or not using the defined method:\n=end comment\nmy $uninitialized;\nsay $uninitialized.defined; # OUTPUT: «False␤»\n\n=begin comment\nWhen using `orelse` it will disarm the exception and alias $_ to that\nfailure. This will prevent it to being automatically handled and printing\nlots of scary error messages to the screen. We can use the `exception`\nmethod on the `$_` variable to access the exception\n=end comment\nopen 'foo' orelse say \"Something happened {.exception}\";\n\n# This also works:\nopen 'foo' orelse say \"Something happened $_\";\n# OUTPUT: «Something happened Failed to open file foo: no such file or directory␤»\n\n=begin comment\nBoth of those above work but in case we get an object from the left side\nthat is not a failure we will probably get a warning. We see below how we\ncan use try` and `CATCH` to be more specific with the exceptions we catch.\n=end comment\n\n#\n# 11.1 Using `try` and `CATCH`\n#\n\n=begin comment\nBy using `try` and `CATCH` you can contain and handle exceptions without\ndisrupting the rest of the program. The `try` block will set the last\nexception to the special variable `$!` (known as the error variable).\nNOTE: This has no relation to $!variables seen inside class definitions.\n=end comment\n\ntry open 'foo';\nsay \"Well, I tried! $!\" if defined $!;\n# OUTPUT: «Well, I tried! Failed to open file foo: no such file or directory␤»\n\n=begin comment\nNow, what if we want more control over handling the exception?\nUnlike many other languages, in Raku, you put the `CATCH` block *within*\nthe block to `try`. Similar to how the `$_` variable was set when we\n'disarmed' the exception with `orelse`, we also use `$_` in the CATCH block.\nNOTE: The `$!` variable is only set *after* the `try` block has caught an\nexception. By default, a `try` block has a `CATCH` block of its own that\ncatches any exception (`CATCH { default {} }`).\n=end comment\n\ntry {\n    my $a = (0 %% 0);\n    CATCH {\n        default { say \"Something happened: $_\" }\n    }\n}\n# OUTPUT: «Something happened: Attempt to divide by zero using infix:<%%>␤»\n\n# You can redefine it using `when`s (and `default`) to handle the exceptions\n# you want to catch explicitly:\n\ntry {\n  open 'foo';\n    CATCH {\n        # In the `CATCH` block, the exception is set to the $_ variable.\n        when X::AdHoc {\n            say \"Error: $_\"\n        }\n        when X::Numeric::DivideByZero {\n            say \"Error: $_\";\n        }\n\n        =begin comment\n        Any other exceptions will be re-raised, since we don't have a `default`.\n        Basically, if a `when` matches (or there's a `default`), the\n\t    exception is marked as \"handled\" so as to prevent its re-throw\n        from the `CATCH` block. You still can re-throw the exception\n        (see below) by hand.\n        =end comment\n        default {\n            say \"Any other error: $_\"\n        }\n  }\n}\n# OUTPUT: «Failed to open file /dir/foo: no such file or directory␤»\n\n=begin comment\nThere are also some subtleties to exceptions. Some Raku subs return a\n`Failure`, which is a wrapper around an `Exception` object which is\n\"unthrown\". They're not thrown until you try to use the variables containing\nthem unless you call `.Bool`/`.defined` on them - then they're handled.\n(the `.handled` method is `rw`, so you can mark it as `False` back yourself)\nYou can throw a `Failure` using `fail`. Note that if the pragma `use fatal`\nis on, `fail` will throw an exception (like `die`).\n=end comment\n\nmy $value = 0/0; # We're not trying to access the value, so no problem.\ntry {\n    say 'Value: ', $value; # Trying to use the value\n    CATCH {\n        default {\n            say \"It threw because we tried to get the fail's value!\"\n        }\n  }\n}\n\n=begin comment\nThere is also another kind of exception: Control exceptions. Those are \"good\"\nexceptions, which happen when you change your program's flow, using operators\nlike `return`, `next` or `last`. You can \"catch\" those with `CONTROL` (not 100%\nworking in Rakudo yet).\n=end comment\n\n####################################################\n# 12. Packages\n####################################################\n\n=begin comment\nPackages are a way to reuse code. Packages are like \"namespaces\", and any\nelement of the six model (`module`, `role`, `class`, `grammar`, `subset` and\n`enum`) are actually packages. (Packages are the lowest common denominator)\nPackages are important - especially as Perl is well-known for CPAN,\nthe Comprehensive Perl Archive Network.\n=end comment\n\n# You can use a module (bring its declarations into scope) with `use`:\nuse JSON::Tiny; # if you installed Rakudo* or Panda, you'll have this module\nsay from-json('[1]').perl; # OUTPUT: «[1]␤»\n\n=begin comment\nYou should not declare packages using the `package` keyword (unlike Perl).\nInstead, use `class Package::Name::Here;` to declare a class, or if you only\nwant to export variables/subs, you can use `module` instead.\n=end comment\n\n# If `Hello` doesn't exist yet, it'll just be a \"stub\", that can be redeclared\n# as something else later.\nmodule Hello::World { # bracketed form\n    # declarations here\n}\n\n# The file-scoped form which extends until the end of the file. For\n# instance, `unit module Parse::Text;` will extend until of the file.\n\n# A grammar is a package, which you could `use`. You will learn more about\n# grammars in the regex section.\ngrammar Parse::Text::Grammar {\n}\n\n# As said before, any part of the six model is also a package.\n# Since `JSON::Tiny` uses its own `JSON::Tiny::Actions` class, you can use it:\nmy $actions = JSON::Tiny::Actions.new;\n\n# We'll see how to export variables and subs in the next part.\n\n####################################################\n# 13. Declarators\n####################################################\n\n=begin comment\nIn Raku, you get different behaviors based on how you declare a variable.\nYou've already seen `my` and `has`, we'll now explore the others.\n\n`our` - these declarations happen at `INIT` time -- (see \"Phasers\" below).\nIt's like `my`, but it also creates a package variable. All packagish\nthings such as `class`, `role`, etc. are `our` by default.\n=end comment\n\nmodule Var::Increment {\n    # NOTE: `our`-declared variables cannot be typed.\n    our $our-var = 1;\n    my $my-var = 22;\n\n    our sub Inc {\n        our sub available { # If you try to make inner `sub`s `our`...\n                            # ... Better know what you're doing (Don't !).\n            say \"Don't do that. Seriously. You'll get burned.\";\n        }\n\n        my sub unavailable { # `sub`s are `my`-declared by default\n            say \"Can't access me from outside, I'm 'my'!\";\n        }\n        say ++$our-var; # Increment the package variable and output its value\n  }\n\n}\n\nsay $Var::Increment::our-var; # OUTPUT: «1␤», this works!\nsay $Var::Increment::my-var;  # OUTPUT: «(Any)␤», this will not work!\n\nsay Var::Increment::Inc;  # OUTPUT: «2␤»\nsay Var::Increment::Inc;  # OUTPUT: «3␤», notice how the value of $our-var was retained.\n\n# Var::Increment::unavailable;  # OUTPUT: «Could not find symbol '&unavailable'␤»\n\n# `constant` - these declarations happen at `BEGIN` time. You can use\n# the `constant` keyword to declare a compile-time variable/symbol:\nconstant Pi = 3.14;\nconstant $var = 1;\n\n# And if you're wondering, yes, it can also contain infinite lists.\nconstant why-not = 5, 15 ... *;\nsay why-not[^5]; # OUTPUT: «5 15 25 35 45␤»\n\n# `state` - these declarations happen at run time, but only once. State\n# variables are only initialized one time. In other languages such as C\n# they exist as `static` variables.\nsub fixed-rand {\n    state $val = rand;\n    say $val;\n}\nfixed-rand for ^10; # will print the same number 10 times\n\n# Note, however, that they exist separately in different enclosing contexts.\n# If you declare a function with a `state` within a loop, it'll re-create the\n# variable for each iteration of the loop. See:\nfor ^5 -> $a {\n    sub foo {\n        # This will be a different value for every value of `$a`\n        state $val = rand;\n    }\n    for ^5 -> $b {\n        # This will print the same value 5 times, but only 5. Next iteration\n        # will re-run `rand`.\n        say foo;\n    }\n}\n\n####################################################\n# 14. Phasers\n####################################################\n\n=begin comment\nPhasers in Raku are blocks that happen at determined points of time in\nyour program. They are called phasers because they mark a change in the\nphase of a program.  For example, when the program is compiled, a for loop\nruns, you leave a block, or an exception gets thrown (The `CATCH` block is\nactually a phaser!). Some of them can be used for their return values,\nsome of them can't (those that can have a \"[*]\" in the beginning of their\nexplanation text). Let's have a look!\n=end comment\n\n#\n# 14.1 Compile-time phasers\n#\nBEGIN { say \"[*] Runs at compile time, as soon as possible, only once\" }\nCHECK { say \"[*] Runs at compile time, as late as possible, only once\" }\n\n#\n# 14.2 Run-time phasers\n#\nINIT { say \"[*] Runs at run time, as soon as possible, only once\" }\nEND  { say \"Runs at run time, as late as possible, only once\" }\n\n#\n# 14.3 Block phasers\n#\nENTER { say \"[*] Runs every time you enter a block, repeats on loop blocks\" }\nLEAVE {\n    say \"Runs every time you leave a block, even when an exception\n    happened. Repeats on loop blocks.\"\n}\n\nPRE {\n    say \"Asserts a precondition at every block entry,\n        before ENTER (especially useful for loops)\";\n    say \"If this block doesn't return a truthy value,\n        an exception of type X::Phaser::PrePost is thrown.\";\n}\n\n# Example (commented out):\nfor 0..2 {\n    # PRE { $_ > 1 } # OUTPUT: «Precondition '{ $_ > 1 }' failed\n}\n\nPOST {\n    say \"Asserts a postcondition at every block exit,\n        after LEAVE (especially useful for loops)\";\n    say \"If this block doesn't return a truthy value,\n        an exception of type X::Phaser::PrePost is thrown, like PRE.\";\n}\n\n# Example (commented out):\nfor 0..2 {\n    # POST { $_ < 1 } # OUTPUT: «Postcondition '{ $_ < 1 }' failed\n}\n\n#\n# 14.4 Block/exceptions phasers\n#\n{\n    KEEP { say \"Runs when you exit a block successfully\n                (without throwing an exception)\" }\n    UNDO { say \"Runs when you exit a block unsuccessfully\n                (by throwing an exception)\" }\n}\n\n#\n# 14.5 Loop phasers\n#\nfor ^5 {\n  FIRST { say \"[*] The first time the loop is run, before ENTER\" }\n  NEXT  { say \"At loop continuation time, before LEAVE\" }\n  LAST  { say \"At loop termination time, after LEAVE\" }\n}\n\n#\n# 14.6 Role/class phasers\n#\nCOMPOSE {\n    say \"When a role is composed into a class. /!\\ NOT YET IMPLEMENTED\"\n}\n\n# They allow for cute tricks or clever code...:\nsay \"This code took \" ~ (time - CHECK time) ~ \"s to compile\";\n\n# ... or clever organization:\nclass DB {\n    method start-transaction { say \"Starting transaction!\" }\n    method commit            { say \"Committing transaction...\" }\n    method rollback          { say \"Something went wrong. Rolling back!\" }\n}\n\nsub do-db-stuff {\n    my DB $db .= new;\n  \t$db.start-transaction; # start a new transaction\n  \tKEEP $db.commit;       # commit the transaction if all went well\n  \tUNDO $db.rollback;     # or rollback if all hell broke loose\n}\n\ndo-db-stuff();\n\n####################################################\n# 15. Statement prefixes\n####################################################\n\n=begin comment\nThose act a bit like phasers: they affect the behavior of the following\ncode. Though, they run in-line with the executable code, so they're in\nlowercase. (`try` and `start` are theoretically in that list, but explained\nelsewhere) NOTE: all of these (except start) don't need explicit curly\nbraces `{` and `}`.\n\n=end comment\n\n#\n# 15.1 `do` - It runs a block or a statement as a term.\n#\n\n# Normally you cannot use a statement as a value (or \"term\"). `do` helps\n# us do it. With `do`, an `if`, for example, becomes a term returning a value.\n=for comment :reason<this fails since `if` is a statement>\nmy $value = if True { 1 }\n\n# this works!\nmy $get-five = do if True { 5 }\n\n#\n# 15.1 `once` - makes sure a piece of code only runs once.\n#\nfor ^5 {\n\tonce say 1\n};\n# OUTPUT: «1␤», only prints ... once\n\n# Similar to `state`, they're cloned per-scope.\nfor ^5 {\n\tsub { once say 1 }()\n};\n# OUTPUT: «1 1 1 1 1␤», prints once per lexical scope.\n\n#\n# 15.2 `gather` - co-routine thread.\n#\n\n# The `gather` constructs allows us to `take` several values from an array/list,\n# much like `do`.\nsay gather for ^5 {\n    take $_ * 3 - 1;\n    take $_ * 3 + 1;\n}\n# OUTPUT: «-1 1 2 4 5 7 8 10 11 13␤»\n\nsay join ',', gather if False {\n    take 1;\n    take 2;\n    take 3;\n}\n# Doesn't print anything.\n\n#\n# 15.3 `eager` - evaluates a statement eagerly (forces eager context).\n\n# Don't try this at home. This will probably hang for a while (and might crash)\n# so commented out.\n# eager 1..*;\n\n# But consider, this version which doesn't print anything\nconstant thricev0 = gather for ^3 { say take $_ };\n# to:\nconstant thricev1 = eager gather for ^3 { say take $_ }; # OUTPUT: «0 1 2␤»\n\n####################################################\n# 16. Iterables\n####################################################\n\n# Iterables are objects that can be iterated over for things such as\n# the `for` construct.\n\n#\n# 16.1 `flat` - flattens iterables.\n#\nsay (1, 10, (20, 10) );      # OUTPUT: «(1 10 (20 10))␤»,  notice how nested\n                             # lists are preserved\nsay (1, 10, (20, 10) ).flat; # OUTPUT: «(1 10 20 10)␤», now the iterable is flat\n\n#\n# 16.2 `lazy` - defers actual evaluation until value is fetched by forcing lazy context.\n#\nmy @lazy-array = (1..100).lazy;\nsay @lazy-array.is-lazy; # OUTPUT: «True␤», check for laziness with the `is-lazy` method.\n\nsay @lazy-array;         # OUTPUT: «[...]␤», List has not been iterated on!\n\n# This works and will only do as much work as is needed.\nfor @lazy-array { .print };\n\n# (**TODO** explain that gather/take and map are all lazy)\n\n#\n# 16.3 `sink` - an `eager` that discards the results by forcing sink context.\n#\nconstant nilthingie = sink for ^3 { .say } #=> 0 1 2\nsay nilthingie.perl;                       # OUTPUT: «Nil␤»\n\n#\n# 16.4 `quietly` - suppresses warnings in blocks.\n#\nquietly { warn 'This is a warning!' }; # No output\n\n####################################################\n# 17. More operators thingies!\n####################################################\n\n# Everybody loves operators! Let's get more of them.\n\n# The precedence list can be found here:\n# https://docs.raku.org/language/operators#Operator_Precedence\n# But first, we need a little explanation about associativity:\n\n#\n# 17.1 Binary operators\n#\n\nmy ($p, $q, $r) = (1, 2, 3);\n\n=begin comment\nGiven some binary operator § (not a Raku-supported operator), then:\n\n$p § $q § $r; # with a left-associative  §, this is ($p § $q) § $r\n$p § $q § $r; # with a right-associative §, this is $p § ($q § $r)\n$p § $q § $r; # with a non-associative   §, this is illegal\n$p § $q § $r; # with a chain-associative §, this is ($p § $q) and ($q § $r)§\n$p § $q § $r; # with a list-associative  §, this is `infix:<>`\n=end comment\n\n#\n# 17.2 Unary operators\n#\n\n=begin comment\nGiven some unary operator § (not a Raku-supported operator), then:\n§$p§ # with left-associative  §, this is (§$p)§\n§$p§ # with right-associative §, this is §($p§)\n§$p§ # with non-associative   §, this is illegal\n=end comment\n\n#\n# 17.3 Create your own operators!\n#\n\n=begin comment\nOkay, you've been reading all of that, so you might want to try something\nmore exciting?! I'll tell you a little secret (or not-so-secret):\nIn Raku, all operators are actually just funny-looking subroutines.\n\nYou can declare an operator just like you declare a sub. In the following\nexample, `prefix` refers to the operator categories (prefix, infix, postfix,\ncircumfix, and post-circumfix).\n=end comment\nsub prefix:<win>( $winner ) {\n\tsay \"$winner Won!\";\n}\nwin \"The King\"; # OUTPUT: «The King Won!␤»\n\n# you can still call the sub with its \"full name\":\nsay prefix:<!>(True);      # OUTPUT: «False␤»\nprefix:<win>(\"The Queen\"); # OUTPUT: «The Queen Won!␤»\n\nsub postfix:<!>( Int $n ) {\n    [*] 2..$n; # using the reduce meta-operator... See below ;-)!\n}\nsay 5!; # OUTPUT: «120␤»\n\n# Postfix operators ('after') have to come *directly* after the term.\n# No whitespace. You can use parentheses to disambiguate, i.e. `(5!)!`\n\nsub infix:<times>( Int $n, Block $r ) { # infix ('between')\n    for ^$n {\n        # You need the explicit parentheses to call the function in `$r`,\n        # else you'd be referring at the code object itself, like with `&r`.\n        $r();\n    }\n}\n3 times -> { say \"hello\" }; # OUTPUT: «hello␤hello␤hello␤»\n\n# It's recommended to put spaces around your infix operator calls.\n\n# For circumfix and post-circumfix ones\nmulti circumfix:<[ ]>( Int $n ) {\n    $n ** $n\n}\nsay [5]; # OUTPUT: «3125␤»\n\n# Circumfix means 'around'. Again, no whitespace.\n\nmulti postcircumfix:<{ }>( Str $s, Int $idx ) {\n    $s.substr($idx, 1);\n}\nsay \"abc\"{1}; # OUTPUT: «b␤», after the term `\"abc\"`, and around the index (1)\n\n# Post-circumfix is 'after a term, around something'\n\n=begin comment\nThis really means a lot -- because everything in Raku uses this.\nFor example, to delete a key from a hash, you use the `:delete` adverb\n(a simple named argument underneath). For instance, the following statements\nare equivalent.\n=end comment\nmy %person-stans =\n    'Giorno Giovanna'  => 'Gold Experience',\n    'Bruno Bucciarati' => 'Sticky Fingers';\nmy $key = 'Bruno Bucciarati';\n%person-stans{$key}:delete;\npostcircumfix:<{ }>( %person-stans, 'Giorno Giovanna', :delete );\n# (you can call operators like this)\n\n=begin comment\nIt's *all* using the same building blocks! Syntactic categories\n(prefix infix ...), named arguments (adverbs), ..., etc. used to build\nthe language - are available to you. Obviously, you're advised against\nmaking an operator out of *everything* -- with great power comes great\nresponsibility.\n=end comment\n\n#\n# 17.4 Meta operators!\n#\n\n=begin comment\nOh boy, get ready!. Get ready, because we're delving deep into the rabbit's\nhole, and you probably won't want to go back to other languages after\nreading this. (I'm guessing you don't want to go back at this point but\nlet's continue, for the journey is long and enjoyable!).\n\nMeta-operators, as their name suggests, are *composed* operators. Basically,\nthey're operators that act on another operators.\n\nThe reduce meta-operator is a prefix meta-operator that takes a binary\nfunction and one or many lists. If it doesn't get passed any argument,\nit either returns a \"default value\" for this operator (a meaningless value)\nor `Any` if there's none (examples below). Otherwise, it pops an element\nfrom the list(s) one at a time, and applies the binary function to the last\nresult (or the first element of a list) and the popped element.\n=end comment\n\n# To sum a list, you could use the reduce meta-operator with `+`, i.e.:\nsay [+] 1, 2, 3; # OUTPUT: «6␤», equivalent to (1+2)+3.\n\n# To multiply a list\nsay [*] 1..5; # OUTPUT: «120␤», equivalent to ((((1*2)*3)*4)*5).\n\n# You can reduce with any operator, not just with mathematical ones.\n# For example, you could reduce with `//` to get first defined element\n# of a list:\nsay [//] Nil, Any, False, 1, 5;  # OUTPUT: «False␤»\n                                 # (Falsey, but still defined)\n# Or with relational operators, i.e., `>` to check elements of a list\n# are ordered accordingly:\nsay [>] 234, 156, 6, 3, -20; # OUTPUT: «True␤»\n\n# Default value examples:\nsay [*] (); # OUTPUT: «1␤», empty product\nsay [+] (); # OUTPUT: «0␤», empty sum\nsay [//];   # OUTPUT: «(Any)␤»\n            # There's no \"default value\" for `//`.\n\n# You can also use it with a function you made up,\n# You can also surround  using double brackets:\nsub add($a, $b) { $a + $b }\nsay [[&add]] 1, 2, 3; # OUTPUT: «6␤»\n\n=begin comment\nThe zip meta-operator is an infix meta-operator that also can be used as a\n\"normal\" operator. It takes an optional binary function (by default, it\njust creates a pair), and will pop one value off of each array and call\nits binary function on these until it runs out of elements. It returns an\narray with all of these new elements.\n=end comment\nsay (1, 2) Z (3, 4); # OUTPUT: «((1, 3), (2, 4))␤»\nsay 1..3 Z+ 4..6;    # OUTPUT: «(5, 7, 9)␤»\n\n# Since `Z` is list-associative (see the list above), you can use it on more\n# than one list.\n(True, False) Z|| (False, False) Z|| (False, False); # (True, False)\n\n# And, as it turns out, you can also use the reduce meta-operator with it:\n[Z||] (True, False), (False, False), (False, False); # (True, False)\n\n# And to end the operator list:\n\n=begin comment\nThe sequence operator (`...`) is one of Raku's most powerful features:\nIt's composed by the list (which might include a closure) you want Raku to\ndeduce from on the left and a value (or either a predicate or a Whatever Star\nfor a lazy infinite list) on the right that states when to stop.\n=end comment\n\n# Basic arithmetic sequence\nmy @listv0 = 1, 2, 3...10;\n\n# This dies because Raku can't figure out the end\n# my @list = 1, 3, 6...10;\n\n# As with ranges, you can exclude the last element (the iteration ends when\n# the predicate matches).\nmy @listv1 = 1, 2, 3...^10;\n\n# You can use a predicate (with the Whatever Star).\nmy @listv2 = 1, 3, 9...* > 30;\n\n# Equivalent to the example above but using a block here.\nmy @listv3 = 1, 3, 9 ... { $_ > 30 };\n\n# Lazy infinite list of fibonacci sequence, computed using a closure!\nmy @fibv0 = 1, 1, *+* ... *;\n\n# Equivalent to the above example but using a pointy block.\nmy @fibv1 = 1, 1, -> $a, $b { $a + $b } ... *;\n\n# Equivalent to the above example but using a block with placeholder parameters.\nmy @fibv2 = 1, 1, { $^a + $^b } ... *;\n\n=begin comment\nIn the examples with explicit parameters (i.e., $a and $b), $a and $b\nwill always take the previous values, meaning that for the Fibonacci sequence,\nthey'll start with $a = 1 and $b = 1 (values we set by hand), then $a = 1\nand $b = 2 (result from previous $a + $b), and so on.\n=end comment\n\n=begin comment\n# In the example we use a range as an index to access the sequence. However,\n# it's worth noting that for ranges, once reified, elements aren't re-calculated.\n# That's why, for instance, `@primes[^100]` will take a long time the first\n# time you print it but then it will be instateneous.\n=end comment\nsay @fibv0[^10]; # OUTPUT: «1 1 2 3 5 8 13 21 34 55␤»\n\n####################################################\n# 18. Regular Expressions\n####################################################\n\n=begin comment\nI'm sure a lot of you have been waiting for this one. Well, now that you know\na good deal of Raku already, we can get started. First off, you'll have to\nforget about \"PCRE regexps\" (perl-compatible regexps).\n\nIMPORTANT: Don't skip them because you know PCRE. They're different. Some\nthings are the same (like `?`, `+`, and `*`), but sometimes the semantics\nchange (`|`). Make sure you read carefully, because you might trip over a\nnew behavior.\n\nRaku has many features related to RegExps. After all, Rakudo parses itself.\nWe're first going to look at the syntax itself, then talk about grammars\n(PEG-like), differences between `token`, `regex` and `rule` declarators,\nand some more. Side note: you still have access to PCRE regexps using the\n`:P5` modifier which we won't be discussing this in this tutorial, though.\n\nIn essence, Raku natively implements PEG (\"Parsing Expression Grammars\").\nThe pecking order for ambiguous parses is determined by a multi-level\ntie-breaking test:\n - Longest token matching: `foo\\s+` beats `foo` (by 2 or more positions)\n - Longest literal prefix: `food\\w*` beats `foo\\w*` (by 1)\n - Declaration from most-derived to less derived grammars\n   (grammars are actually classes)\n - Earliest declaration wins\n=end comment\nsay so 'a' ~~ /a/;   # OUTPUT: «True␤»\nsay so 'a' ~~ / a /; # OUTPUT: «True␤», more readable with some spaces!\n\n=begin comment\nIn all our examples, we're going to use the smart-matching operator against\na regexp. We're converting the result using `so` to a Boolean value because,\nin fact, it's returning a `Match` object. They know how to respond to list\nindexing, hash indexing, and return the matched string. The results of the\nmatch are available in the `$/` variable (implicitly lexically-scoped). You\ncan also use the capture variables which start at 0: `$0`, `$1', `$2`...\n\nYou can also note that `~~` does not perform start/end checking, meaning\nthe regexp can be matched with just one character of the string. We'll\nexplain later how you can do it.\n\nIn Raku, you can have any alphanumeric as a literal, everything else has\nto be escaped by using a backslash or quotes.\n=end comment\nsay so 'a|b' ~~ / a '|' b /; # OUTPUT: «True␤», it wouldn't mean the same\n                             # thing if `|` wasn't escaped.\nsay so 'a|b' ~~ / a \\| b /;  # OUTPUT: «True␤», another way to escape it.\n\n# The whitespace in a regex is actually not significant, unless you use the\n# `:s` (`:sigspace`, significant space) adverb.\nsay so 'a b c' ~~ / a  b  c /; #=> `False`, space is not significant here!\nsay so 'a b c' ~~ /:s a b c /; #=> `True`, we added the modifier `:s` here.\n\n# If we use only one space between strings in a regex, Raku will warn us\n# about space being not signicant in the regex:\nsay so 'a b c' ~~ / a b c /;   # OUTPUT: «False␤»\nsay so 'a b c' ~~ / a  b  c /; # OUTPUT: «False»\n\n=begin comment\nNOTE: Please use quotes or `:s` (`:sigspace`) modifier (or, to suppress this\nwarning, omit the space, or otherwise change the spacing). To fix this and make\nthe spaces less ambiguous, either use at least two spaces between strings\nor use the `:s` adverb.\n=end comment\n\n# As we saw before, we can embed the `:s` inside the slash delimiters, but we\n# can also put it outside of them if we specify `m` for 'match':\nsay so 'a b c' ~~ m:s/a  b  c/; # OUTPUT: «True␤»\n\n# By using `m` to specify 'match', we can also use other delimiters:\nsay so 'abc' ~~ m{a  b  c};     # OUTPUT: «True␤»\nsay so 'abc' ~~ m[a  b  c];     # OUTPUT: «True␤»\n\n# `m/.../` is equivalent to `/.../`:\nsay 'raku' ~~ m/raku/; # OUTPUT: «True␤»\nsay 'raku' ~~ /raku/;  # OUTPUT: «True␤»\n\n# Use the `:i` adverb to specify case insensitivity:\nsay so 'ABC' ~~ m:i{a  b  c};   # OUTPUT: «True␤»\n\n# However, whitespace is important as for how modifiers are applied\n# (which you'll see just below) ...\n\n#\n# 18.1 Quantifiers - `?`, `+`, `*` and `**`.\n#\n\n# `?` - zero or one match\nsay so 'ac' ~~ / a  b  c /;   # OUTPUT: «False␤»\nsay so 'ac' ~~ / a  b?  c /;  # OUTPUT: «True␤», the \"b\" matched 0 times.\nsay so 'abc' ~~ / a  b?  c /; # OUTPUT: «True␤», the \"b\" matched 1 time.\n\n# ... As you read before, whitespace is important because it determines which\n# part of the regex is the target of the modifier:\nsay so 'def' ~~ / a  b  c? /; # OUTPUT: «False␤», only the \"c\" is optional\nsay so 'def' ~~ / a  b?  c /; # OUTPUT: «False␤», whitespace is not significant\nsay so 'def' ~~ / 'abc'? /;   # OUTPUT: «True␤»,  the whole \"abc\" group is optional\n\n# Here (and below) the quantifier applies only to the \"b\"\n\n# `+` - one or more matches\nsay so 'ac' ~~ / a  b+  c /;     # OUTPUT: «False␤», `+` wants at least one 'b'\nsay so 'abc' ~~ / a  b+  c /;    # OUTPUT: «True␤», one is enough\nsay so 'abbbbc' ~~ / a  b+  c /; # OUTPUT: «True␤», matched 4 \"b\"s\n\n# `*` - zero or more matches\nsay so 'ac' ~~ / a  b*  c /;     # OUTPUT: «True␤», they're all optional\nsay so 'abc' ~~ / a  b*  c /;    # OUTPUT: «True␤»\nsay so 'abbbbc' ~~ / a  b*  c /; # OUTPUT: «True␤»\nsay so 'aec' ~~ / a  b*  c /;    # OUTPUT: «False␤», \"b\"(s) are optional, not replaceable.\n\n# `**` - (Unbound) Quantifier\n# If you squint hard enough, you might understand why exponentation is used\n# for quantity.\nsay so 'abc' ~~ / a  b**1  c /;         # OUTPUT: «True␤», exactly one time\nsay so 'abc' ~~ / a  b**1..3  c /;      # OUTPUT: «True␤», one to three times\nsay so 'abbbc' ~~ / a  b**1..3  c /;    # OUTPUT: «True␤»\nsay so 'abbbbbbc' ~~ / a  b**1..3  c /; # OUTPUT: «Fals␤», too much\nsay so 'abbbbbbc' ~~ / a  b**3..*  c /; # OUTPUT: «True␤», infinite ranges are ok\n\n#\n# 18.2 `<[]>` - Character classes\n#\n\n# Character classes are the equivalent of PCRE's `[]` classes, but they use a\n# more raku-ish syntax:\nsay 'fooa' ~~ / f <[ o a ]>+ /;  # OUTPUT: «fooa␤»\n\n# You can use ranges (`..`):\nsay 'aeiou' ~~ / a <[ e..w ]> /; # OUTPUT: «ae␤»\n\n# Just like in normal regexes, if you want to use a special character, escape\n# it (the last one is escaping a space which would be equivalent to using\n# ' '):\nsay 'he-he !' ~~ / 'he-' <[ a..z \\! \\  ]> + /; # OUTPUT: «he-he !␤»\n\n# You'll get a warning if you put duplicate names (which has the nice effect\n# of catching the raw quoting):\n'he he' ~~ / <[ h e ' ' ]> /;\n# Warns \"Repeated character (') unexpectedly found in character class\"\n\n# You can also negate character classes... (`<-[]>` equivalent to `[^]` in PCRE)\nsay so 'foo' ~~ / <-[ f o ]> + /; # OUTPUT: «False␤»\n\n# ... and compose them:\n# any letter except \"f\" and \"o\"\nsay so 'foo' ~~ / <[ a..z ] - [ f o ]> + /;   # OUTPUT: «False␤»\n\n# no letter except \"f\" and \"o\"\nsay so 'foo' ~~ / <-[ a..z ] + [ f o ]> + /;  # OUTPUT: «True␤»\n\n# the + doesn't replace the left part\nsay so 'foo!' ~~ / <-[ a..z ] + [ f o ]> + /; # OUTPUT: «True␤»\n\n#\n# 18.3 Grouping and capturing\n#\n\n# Group: you can group parts of your regexp with `[]`. Unlike PCRE's `(?:)`,\n# these groups are *not* captured.\nsay so 'abc' ~~ / a [ b ] c /;  # OUTPUT: «True␤», the grouping does nothing\nsay so 'foo012012bar' ~~ / foo [ '01' <[0..9]> ] + bar /; # OUTPUT: «True␤»\n\n# The previous line returns `True`. The regex matches \"012\" one or more time\n# (achieved by the the `+` applied to the group).\n\n# But this does not go far enough, because we can't actually get back what\n# we matched.\n\n# Capture: The results of a regexp can be *captured* by using parentheses.\nsay so 'fooABCABCbar' ~~ / foo ( 'A' <[A..Z]> 'C' ) + bar /; # OUTPUT: «True␤»\n# (using `so` here, see `$/` below)\n\n# So, starting with the grouping explanations. As we said before, our `Match`\n# object is stored inside the `$/` variable:\nsay $/;    # Will either print the matched object or `Nil` if nothing matched.\n\n# As we also said before, it has array indexing:\nsay $/[0]; # OUTPUT: «｢ABC｣ ｢ABC｣␤»,\n\n# The corner brackets (｢..｣) represent (and are) `Match` objects. In the\n# previous example, we have an array of them.\n\nsay $0;    # The same as above.\n\n=begin comment\nOur capture is `$0` because it's the first and only one capture in the\nregexp. You might be wondering why it's an array, and the answer is simple:\nSome captures (indexed using `$0`, `$/[0]` or a named one) will be an array\nif and only if they can have more than one element. Thus any capture with\n`*`, `+` and `**` (whatever the operands), but not with `?`.\nLet's use examples to see that:\n\nNOTE: We quoted A B C to demonstrate that the whitespace between them isn't\nsignificant. If we want the whitespace to *be* significant there, we can use the\n`:sigspace` modifier.\n=end comment\nsay so 'fooABCbar' ~~ / foo ( \"A\" \"B\" \"C\" )? bar /; # OUTPUT: «True␤»\nsay $/[0];   # OUTPUT: «｢ABC｣␤»\nsay $0.WHAT; # OUTPUT: «(Match)␤»\n             # There can't be more than one, so it's only a single match object.\n\nsay so 'foobar' ~~ / foo ( \"A\" \"B\" \"C\" )? bar /;    # OUTPUT: «True␤»\nsay $0.WHAT; # OUTPUT: «(Any)␤», this capture did not match, so it's empty.\n\nsay so 'foobar' ~~ / foo ( \"A\" \"B\" \"C\" ) ** 0..1 bar /; #=> OUTPUT: «True␤»\nsay $0.WHAT; # OUTPUT: «(Array)␤», A specific quantifier will always capture\n             # an Array, be a range or a specific value (even 1).\n\n# The captures are indexed per nesting. This means a group in a group will be\n# nested under its parent group: `$/[0][0]`, for this code:\n'hello-~-world' ~~ / ( 'hello' ( <[ \\- \\~ ]> + ) ) 'world' /;\nsay $/[0].Str;    # OUTPUT: «hello~␤»\nsay $/[0][0].Str; # OUTPUT: «~␤»\n\n=begin comment\nThis stems from a very simple fact: `$/` does not contain strings, integers\nor arrays, it only contains `Match` objects. These contain the `.list`, `.hash`\nand `.Str` methods but you can also just use `match<key>` for hash access\nand `match[idx]` for array access.\n\nIn the following example, we can see `$_` is a list of `Match` objects.\nEach of them contain a wealth of information: where the match started/ended,\nthe \"ast\" (see actions later), etc. You'll see named capture below with\ngrammars.\n=end comment\nsay $/[0].list.perl; # OUTPUT: «(Match.new(...),).list␤»\n\n# Alternation - the `or` of regexes\n# WARNING: They are DIFFERENT from PCRE regexps.\nsay so 'abc' ~~ / a [ b | y ] c /; # OUTPUT: «True␤», Either \"b\" or \"y\".\nsay so 'ayc' ~~ / a [ b | y ] c /; # OUTPUT: «True␤», Obviously enough...\n\n# The difference between this `|` and the one you're used to is\n# LTM (\"Longest Token Matching\") strategy. This means that the engine will\n# always try to match as much as possible in the string.\nsay 'foo' ~~ / fo | foo /; # OUTPUT: «foo», instead of `fo`, because it's longer.\n\n=begin comment\nTo decide which part is the \"longest\", it first splits the regex in two parts:\n\n    * The \"declarative prefix\" (the part that can be statically analyzed)\n    which includes alternations (`|`), conjunctions (`&`), sub-rule calls (not\n    yet introduced), literals, characters classes and quantifiers.\n\n    * The \"procedural part\" includes everything else: back-references,\n    code assertions, and other things that can't traditionally be represented\n    by normal regexps.\n\nThen, all the alternatives are tried at once, and the longest wins.\n=end comment\n\n# Examples:\n# DECLARATIVE | PROCEDURAL\n/ 'foo' \\d+     [ <subrule1> || <subrule2> ] /;\n\n# DECLARATIVE (nested groups are not a problem)\n/ \\s* [ \\w & b ] [ c | d ] /;\n\n# However, closures and recursion (of named regexes) are procedural.\n# There are also more complicated rules, like specificity (literals win\n# over character classes).\n\n# NOTE: The alternation in which all the branches are tried in order\n# until the first one matches still exists, but is now spelled `||`.\nsay 'foo' ~~ / fo || foo /; # OUTPUT: «fo␤», in this case.\n\n####################################################\n# 19. Extra: the MAIN subroutine\n####################################################\n\n=begin comment\nThe `MAIN` subroutine is called when you run a Raku file directly. It's\nvery powerful, because Raku actually parses the arguments and pass them\nas such to the sub. It also handles named argument (`--foo`) and will even\ngo as far as to autogenerate a `--help` flag.\n=end comment\n\nsub MAIN($name) {\n    say \"Hello, $name!\";\n}\n=begin comment\nSupposing the code above is in file named cli.raku, then running in the command\nline (e.g., $ raku cli.raku) produces:\nUsage:\n cli.raku <name>\n=end comment\n\n=begin comment\nAnd since MAIN is a regular Raku sub, you can have multi-dispatch:\n(using a `Bool` for the named argument so that we can do `--replace`\ninstead of `--replace=1`. The presence of `--replace` indicates truthness\nwhile its absence falseness). For example:\n\n    # convert to IO object to check the file exists\n    subset File of Str where *.IO.d;\n\n    multi MAIN('add', $key, $value, Bool :$replace) { ... }\n    multi MAIN('remove', $key) { ... }\n    multi MAIN('import', File, Str :$as) { ... } # omitting parameter name\n\nThus $ raku cli.raku produces:\nUsage:\n  cli.raku [--replace] add <key> <value>\n  cli.raku remove <key>\n  cli.raku [--as=<Str>] import <File>\n\nAs you can see, this is *very* powerful. It even went as far as to show inline\nthe constants (the type is only displayed if the argument is `$`/is named).\n=end comment\n\n####################################################\n# 20. APPENDIX A:\n####################################################\n\n=begin comment\nIt's assumed by now you know the Raku basics. This section is just here to\nlist some common operations, but which are not in the \"main part\" of the\ntutorial to avoid bloating it up.\n=end comment\n\n#\n# 20.1 Operators\n#\n\n# Sort comparison - they return one value of the `Order` enum: `Less`, `Same`\n# and `More` (which numerify to -1, 0 or +1 respectively).\nsay 1 <=> 4;     # OUTPUT: «More␤»,   sort comparison for numerics\nsay 'a' leg 'b'; # OUTPUT: «Lessre␤», sort comparison for string\nsay 1 eqv 1;     # OUTPUT: «Truere␤», sort comparison using eqv semantics\nsay 1 eqv 1.0;   # OUTPUT: «False␤»\n\n# Generic ordering\nsay 3 before 4;    # OUTPUT: «True␤»\nsay 'b' after 'a'; # OUTPUT: «True␤»\n\n# Short-circuit default operator - similar to `or` and `||`, but instead\n# returns the first *defined* value:\nsay Any // Nil // 0 // 5;        # OUTPUT: «0␤»\n\n# Short-circuit exclusive or (XOR) - returns `True` if one (and only one) of\n# its arguments is true\nsay True ^^ False;               # OUTPUT: «True␤»\n\n=begin comment\nFlip flops. These operators (`ff` and `fff`, equivalent to P5's `..`\nand `...`) are operators that take two predicates to test: They are `False`\nuntil their left side returns `True`, then are `True` until their right\nside returns `True`. Similar to ranges, you can exclude the iteration when\nit become `True`/`False` by using `^` on either side. Let's start with an\nexample :\n=end comment\n\nfor <well met young hero we shall meet later> {\n    # by default, `ff`/`fff` smart-match (`~~`) against `$_`:\n    if 'met' ^ff 'meet' { # Won't enter the if for \"met\"\n        .say              # (explained in details below).\n    }\n\n    if rand == 0 ff rand == 1 { # compare variables other than `$_`\n        say \"This ... probably will never run ...\";\n    }\n}\n\n=begin comment\nThis will print \"young hero we shall meet\" (excluding \"met\"): the flip-flop\nwill start returning `True` when it first encounters \"met\" (but will still\nreturn `False` for \"met\" itself, due to the leading `^` on `ff`), until it\nsees \"meet\", which is when it'll start returning `False`.\n=end comment\n\n=begin comment\nThe difference between `ff` (awk-style) and `fff` (sed-style) is that `ff`\nwill test its right side right when its left side changes to `True`, and can\nget back to `False` right away (*except* it'll be `True` for the iteration\nthat matched) while `fff` will wait for the next iteration to try its right\nside, once its left side changed:\n=end comment\n\n# The output is due to the right-hand-side being tested directly (and returning\n# `True`). \"B\"s are printed since it matched that time (it just went back to\n# `False` right away).\n.say if 'B' ff 'B' for <A B C B A>; # OUTPUT: «B B␤»,\n\n# In this case the right-hand-side wasn't tested until `$_` became \"C\"\n# (and thus did not match instantly).\n.say if 'B' fff 'B' for <A B C B A>; #=> «B C B␤»,\n\n# A flip-flop can change state as many times as needed:\nfor <test start print it stop not printing start print again stop not anymore> {\n    # exclude both \"start\" and \"stop\",\n    .say if $_ eq 'start' ^ff^ $_ eq 'stop'; # OUTPUT: «print it print again␤»\n}\n\n# You might also use a Whatever Star, which is equivalent to `True` for the\n# left side or `False` for the right, as shown in this example.\n# NOTE: the parenthesis are superfluous here (sometimes called \"superstitious\n# parentheses\"). Once the flip-flop reaches a number greater than 50, it'll\n# never go back to `False`.\nfor (1, 3, 60, 3, 40, 60) {\n    .say if $_ > 50 ff *;  # OUTPUT: «60␤3␤40␤60␤»\n}\n\n# You can also use this property to create an `if` that'll not go through the\n# first time. In this case, the flip-flop is `True` and never goes back to\n# `False`, but the `^` makes it *not run* on the first iteration\nfor <a b c> { .say if * ^ff *; }  # OUTPUT: «b␤c␤»\n\n# The `===` operator, which uses `.WHICH` on the objects to be compared, is\n# the value identity operator whereas the `=:=` operator, which uses `VAR()` on\n# the objects to compare them, is the container identity operator.\n```\n\nIf you want to go further and learn more about Raku, you can:\n\n- Read the [Raku Docs](https://docs.raku.org/). This is a great\nresource on Raku. If you are looking for something, use the search bar.\nThis will give you a dropdown menu of all the pages referencing your search\nterm (Much better than using Google to find Raku documents!).\n\n- Read the [Raku Advent Calendar](https://rakuadventcalendar.wordpress.com/). This\nis a great source of Raku snippets and explanations. If the docs don't\ndescribe something well enough, you may find more detailed information here.\nThis information may be a bit older but there are many great examples and\nexplanations. Posts stopped at the end of 2015 when the language was declared\nstable and `Raku v6.c` was released.\n\n- Come along on `#raku` at [`irc.freenode.net`](https://webchat.freenode.net/?channels=#raku). The folks here are\nalways helpful.\n\n- Check the [source of Raku's functions and\nclasses](https://github.com/rakudo/rakudo/tree/master/src/core.c). Rakudo is\nmainly written in Raku (with a lot of NQP, \"Not Quite Perl\", a Raku subset\neasier to implement and optimize).\n\n- Read [the language design documents](https://design.raku.org/). They explain\nRaku from an implementor point-of-view, but it's still very interesting."
