
package pages

const Moonscript = "MoonScript is a dynamic scripting language that compiles into Lua. It gives\nyou the power of one of the fastest scripting languages combined with a\nrich set of features.\n\nSee [the MoonScript website](https://moonscript.org/) to see official guides on installation for all platforms.\n\n```moon\n-- Two dashes start a comment. Comments can go until the end of the line.\n-- MoonScript transpiled to Lua does not keep comments.\n\n-- As a note, MoonScript does not use 'do', 'then', or 'end' like Lua would and\n-- instead uses an indented syntax, much like Python.\n\n--------------------------------------------------\n-- 1. Assignment\n--------------------------------------------------\n\nhello = \"world\"\na, b, c = 1, 2, 3\nhello = 123 -- Overwrites `hello` from above.\n\nx = 0\nx += 10 -- x = x + 10\n\ns = \"hello \"\ns ..= \"world\" -- s = s .. \"world\"\n\nb = false\nb and= true or false -- b = b and (true or false)\n\n--------------------------------------------------\n-- 2. Literals and Operators\n--------------------------------------------------\n\n-- Literals work almost exactly as they would in Lua. Strings can be broken in\n-- the middle of a line without requiring a \\.\n\nsome_string = \"exa\nmple\" -- local some_string = \"exa\\nmple\"\n\n-- Strings can also have interpolated values, or values that are evaluated and\n-- then placed inside of a string.\n\nsome_string = \"This is an #{some_string}\" -- Becomes 'This is an exa\\nmple'\n\n--------------------------------------------------\n-- 2.1. Function Literals\n--------------------------------------------------\n\n-- Functions are written using arrows:\n\nmy_function = -> -- compiles to `function() end`\nmy_function() -- calls an empty function\n\n-- Functions can be called without using parenthesis. Parentheses may still be\n-- used to have priority over other functions.\n\nfunc_a = -> print \"Hello World!\"\nfunc_b = ->\n\tvalue = 100\n\tprint \"The value: #{value}\"\n\n-- If a function needs no parameters, it can be called with either `()` or `!`.\n\nfunc_a!\nfunc_b()\n\n-- Functions can use arguments by preceding the arrow with a list of argument\n-- names bound by parentheses.\n\nsum = (x, y)-> x + y -- The last expression is returned from the function.\nprint sum(5, 10)\n\n-- Lua has an idiom of sending the first argument to a function as the object,\n-- like a 'self' object. Using a fat arrow (=>) instead of a skinny arrow (->)\n-- automatically creates a `self` variable. `@x` is a shorthand for `self.x`.\n\nfunc = (num)=> @value + num\n\n-- Default arguments can also be used with function literals:\n\na_function = (name = \"something\", height=100)->\n\tprint \"Hello, I am #{name}.\\nMy height is #{height}.\"\n\n-- Because default arguments are calculated in the body of the function when\n-- transpiled to Lua, you can reference previous arguments.\n\nsome_args = (x = 100, y = x + 1000)-> print(x + y)\n\n--------------------------------------------------\n-- Considerations\n--------------------------------------------------\n\n-- The minus sign plays two roles, a unary negation operator and a binary\n-- subtraction operator. It is recommended to always use spaces between binary\n-- operators to avoid the possible collision.\n\na = x - 10 --  a = x - 10\nb = x-10 -- b = x - 10\nc = x -y -- c = x(-y)\nd = x- z -- d = x - z\n\n-- When there is no space between a variable and string literal, the function\n-- call takes priority over following expressions:\n\nx = func\"hello\" + 100 -- func(\"hello\") + 100\ny = func \"hello\" + 100 -- func(\"hello\" + 100)\n\n-- Arguments to a function can span across multiple lines as long as the\n-- arguments are indented. The indentation can be nested as well.\n\nmy_func 5, -- called as my_func(5, 8, another_func(6, 7, 9, 1, 2), 5, 4)\n\t8, another_func 6, 7, -- called as\n\t\t9, 1, 2,\t\t  -- another_func(6, 7, 9, 1, 2)\n\t5, 4\n\n-- If a function is used at the start of a block, the indentation can be\n-- different than the level of indentation used in a block:\n\nif func 1, 2, 3, -- called as func(1, 2, 3, \"hello\", \"world\")\n\t\t\"hello\",\n\t\t\"world\"\n\tprint \"hello\"\n\n--------------------------------------------------\n-- 3. Tables\n--------------------------------------------------\n\n-- Tables are defined by curly braces, like Lua:\n\nsome_values = {1, 2, 3, 4}\n\n-- Tables can use newlines instead of commas.\n\nsome_other_values = {\n\t5, 6\n\t7, 8\n}\n\n-- Assignment is done with `:` instead of `=`:\n\nprofile = {\n\tname: \"Bill\"\n\tage: 200\n\t\"favorite food\": \"rice\"\n}\n\n-- Curly braces can be left off for `key: value` tables.\n\ny = type: \"dog\", legs: 4, tails: 1\n\nprofile =\n\theight: \"4 feet\",\n\tshoe_size: 13,\n\tfavorite_foods: -- nested table\n\t\tfoo: \"ice cream\", \n\t\tbar: \"donuts\"\n\nmy_function dance: \"Tango\", partner: \"none\" -- :( forever alone\n\n-- Tables constructed from variables can use the same name as the variables\n-- by using `:` as a prefix operator.\n\nhair = \"golden\"\nheight = 200\nperson = {:hair, :height}\n\n-- Like in Lua, keys can be non-string or non-numeric values by using `[]`.\n\nt =\n\t[1 + 2]: \"hello\"\n\t\"hello world\": true -- Can use string literals without `[]`.\n\n--------------------------------------------------\n-- 3.1. Table Comprehensions\n--------------------------------------------------\n\n-- List Comprehensions\n\n-- Creates a copy of a list but with all items doubled. Using a star before a\n-- variable name or table can be used to iterate through the table's values.\n\nitems = {1, 2, 3, 4}\ndoubled = [item * 2 for item in *items]\n-- Uses `when` to determine if a value should be included.\n\nslice = [item for item in *items when item > 1 and item < 3]\n\n-- `for` clauses inside of list comprehensions can be chained.\n\nx_coords = {4, 5, 6, 7}\ny_coords = {9, 2, 3}\n\npoints = [{x,y} for x in *x_coords for y in *y_coords]\n\n-- Numeric for loops can also be used in comprehensions:\n\nevens = [i for i=1, 100 when i % 2 == 0]\n\n-- Table Comprehensions are very similar but use `{` and `}` and take two\n-- values for each iteration.\n\nthing = color: \"red\", name: \"thing\", width: 123\nthing_copy = {k, v for k, v in pairs thing}\n\n-- Tables can be \"flattened\" from key-value pairs in an array by using `unpack`\n-- to return both values, using the first as the key and the second as the\n-- value.\n\ntuples = {{\"hello\", \"world\"}, {\"foo\", \"bar\"}}\ntable = {unpack tuple for tuple in *tuples}\n\n-- Slicing can be done to iterate over only a certain section of an array. It\n-- uses the `*` notation for iterating but appends `[start, end, step]`.\n\n-- The next example also shows that this syntax can be used in a `for` loop as\n-- well as any comprehensions.\n\nfor item in *points[1, 10, 2]\n\tprint unpack item\n\n-- Any undesired values can be left off. The second comma is not required if\n-- the step is not included.\n\nwords = {\"these\", \"are\", \"some\", \"words\"}\nfor word in *words[,3] \n\tprint word\n\n--------------------------------------------------\n-- 4. Control Structures\n--------------------------------------------------\n\nhave_coins = false\nif have_coins\n\tprint \"Got coins\"\nelse\n\tprint \"No coins\"\n\n-- Use `then` for single-line `if`\nif have_coins then \"Got coins\" else \"No coins\"\n\n-- `unless` is the opposite of `if`\nunless os.date(\"%A\") == \"Monday\"\n\tprint \"It is not Monday!\"\n\n-- `if` and `unless` can be used as expressions\nis_tall = (name)-> if name == \"Rob\" then true else false\nmessage = \"I am #{if is_tall \"Rob\" then \"very tall\" else \"not so tall\"}\"\nprint message -- \"I am very tall\"\n\n-- `if`, `elseif`, and `unless` can evaluate assignment as well as expressions.\nif x = possibly_nil! -- sets `x` to `possibly_nil()` and evaluates `x`\n\tprint x\n\n-- Conditionals can be used after a statement as well as before. This is\n-- called a \"line decorator\".\n\nis_monday = os.date(\"%A\") == \"Monday\"\nprint(\"It IS Monday!\") if isMonday\nprint(\"It is not Monday..\") unless isMonday\n--print(\"It IS Monday!\" if isMonday) -- Not a statement, does not work\n\n--------------------------------------------------\n-- 4.1 Loops\n--------------------------------------------------\n\nfor i = 1, 10\n\tprint i\n\nfor i = 10, 1, -1 do print i -- Use `do` for single-line loops.\n\ni = 0\nwhile i < 10\n\tcontinue if i % 2 == 0 -- Continue statement; skip the rest of the loop.\n\tprint i\n\n-- Loops can be used as a line decorator, just like conditionals\nprint \"item: #{item}\" for item in *items\n\n-- Using loops as an expression generates an array table. The last statement\n-- in the block is coerced into an expression and added to the table.\nmy_numbers = for i = 1, 6 do i -- {1, 2, 3, 4, 5, 6}\n\n-- use `continue` to filter out values\nodds = for i in *my_numbers\n\tcontinue if i % 2 == 0 -- acts opposite to `when` in comprehensions!\n\ti -- Only added to return table if odd\n\n-- A `for` loop returns `nil` when it is the last statement of a function\n-- Use an explicit `return` to generate a table.\nprint_squared = (t) -> for x in *t do x*x -- returns `nil`\nsquared = (t) -> return for x in *t do x*x -- returns new table of squares\n\n-- The following does the same as `(t) -> [i for i in *t when i % 2 == 0]`\n-- But list comprehension generates better code and is more readable!\n\nfilter_odds = (t) -> \n\treturn for x in *t\n\t\tif x % 2 == 0 then x else continue\nevens = filter_odds(my_numbers) -- {2, 4, 6}\n\n--------------------------------------------------\n-- 4.2 Switch Statements\n--------------------------------------------------\n\n-- Switch statements are a shorthand way of writing multiple `if` statements\n-- checking against the same value. The value is only evaluated once.\n\nname = \"Dan\"\n\nswitch name\n\twhen \"Dave\"\n\t\tprint \"You are Dave.\"\n\twhen \"Dan\"\n\t\tprint \"You are not Dave, but Dan.\"\n\telse\n\t\tprint \"You are neither Dave nor Dan.\"\n\n-- Switches can also be used as expressions, as well as compare multiple\n-- values. The values can be on the same line as the `when` clause if they\n-- are only one expression.\n\nb = 4\nnext_even = switch b\n\twhen 1 then 2\n\twhen 2, 3 then 4\n\twhen 4, 5 then 6\n\telse error \"I can't count that high! D:\"\n\n--------------------------------------------------\n-- 5. Object Oriented Programming\n--------------------------------------------------\n\n-- Classes are created using the `class` keyword followed by an identifier,\n-- typically written using CamelCase. Values specific to a class can use @ as\n-- the identifier instead of `self.value`.\n\nclass Inventory\n\tnew: => @items = {}\n\tadd_item: (name)=> -- note the use of fat arrow for classes!\n\t\t@items[name] = 0 unless @items[name]\n\t\t@items[name] += 1\n\n-- The `new` function inside of a class is special because it is called when\n-- an instance of the class is created.\n\n-- Creating an instance of the class is as simple as calling the class as a\n-- function. Calling functions inside of the class uses \\ to separate the\n-- instance from the function it is calling.\n\ninv = Inventory!\ninv\\add_item \"t-shirt\"\ninv\\add_item \"pants\"\n\n-- Values defined in the class - not the new() function - will be shared across\n-- all instances of the class.\n\nclass Person\n\tclothes: {}\n\tgive_item: (name)=>\n\t\ttable.insert @clothes name\n\na = Person!\nb = Person!\n\na\\give_item \"pants\"\nb\\give_item \"shirt\"\n\n-- prints out both \"pants\" and \"shirt\"\n\nprint item for item in *a.clothes\n\n-- Class instances have a value `.__class` that are equal to the class object\n-- that created the instance.\n\nassert(b.__class == Person)\n\n-- Variables declared in class body the using the `=` operator are locals,\n-- so these \"private\" variables are only accessible within the current scope.\n\nclass SomeClass\n\tx = 0\n\treveal: ->\n\t\tx += 1\n\t\tprint x\n\na = SomeClass!\nb = SomeClass!\nprint a.x -- nil\na.reveal! -- 1\nb.reveal! -- 2\n\n--------------------------------------------------\n-- 5.1 Inheritance\n--------------------------------------------------\n\n-- The `extends` keyword can be used to inherit properties and methods from\n-- another class.\n\nclass Backpack extends Inventory\n\tsize: 10\n\tadd_item: (name)=>\n\t\terror \"backpack is full\" if #@items > @size\n\t\tsuper name -- calls Inventory.add_item with `name`.\n\n-- Because a `new` method was not added, the `new` method from `Inventory` will\n-- be used instead. If we did want to use a constructor while still using the\n-- constructor from `Inventory`, we could use the magical `super` function\n-- during `new()`.\n\n-- When a class extends another, it calls the method `__inherited` on the \n-- parent class (if it exists). It is always called with the parent and the\n-- child object.\n\nclass ParentClass\n\t@__inherited: (child)=>\n\t\tprint \"#{@__name} was inherited by #{child.__name}\"\n\ta_method: (a, b) => print a .. ' ' .. b\n\n-- Will print 'ParentClass was inherited by MyClass'\n\nclass MyClass extends ParentClass\n\ta_method: =>\n\t\tsuper \"hello world\", \"from MyClass!\" \n\t\tassert super == ParentClass\n\n--------------------------------------------------\n-- 6. Scope\n--------------------------------------------------\n\n-- All values are local by default. The `export` keyword can be used to\n-- declare the variable as a global value.\n\nexport var_1, var_2\nvar_1, var_3 = \"hello\", \"world\" -- var_3 is local, var_1 is not.\n\nexport this_is_global_assignment = \"Hi!\"\n\n-- Classes can also be prefixed with `export` to make them global classes.\n-- Alternatively, all CamelCase variables can be exported automatically using\n-- `export ^`, and all values can be exported using `export *`.\n\n-- `do` lets you manually create a scope, for when you need local variables.\n\ndo\n\tx = 5\nprint x -- nil\n\n-- Here we use `do` as an expression to create a closure.\n\ncounter = do \n\ti = 0\n\t->\n\t\ti += 1\n\t\treturn i\n\nprint counter!  -- 1\nprint counter!  -- 2\n\n-- The `local` keyword can be used to define variables\n-- before they are assigned.\n\nlocal var_4\nif something\n\tvar_4 = 1\nprint var_4 -- works because `var_4` was set in this scope, not the `if` scope.\n\n-- The `local` keyword can also be used to shadow an existing variable.\n\nx = 10\nif false\n\tlocal x\n\tx = 12\nprint x -- 10\n\n-- Use `local *` to forward-declare all variables. \n-- Alternatively, use `local ^` to forward-declare all CamelCase values.\n\nlocal *\n\nfirst = ->\n\tsecond!\n\nsecond = ->\n\tprint data\n\ndata = {}\n\n--------------------------------------------------\n-- 6.1 Import\n--------------------------------------------------\n\n-- Values from a table can be brought to the current scope using the `import`\n-- and `from` keyword. Names in the `import` list can be preceded by `\\` if\n-- they are a module function.\n\nimport insert from table -- local insert = table.insert\nimport \\add from state: 100, add: (value)=> @state + value\nprint add 22\n\n-- Like tables, commas can be excluded from `import` lists to allow for longer\n-- lists of imported items.\n\nimport\n\tasdf, gh, jkl\n\tantidisestablishmentarianism\n\tfrom {}\n\n--------------------------------------------------\n-- 6.2 With\n--------------------------------------------------\n\n-- The `with` statement can be used to quickly call and assign values in an\n-- instance of a class or object.\n\nfile = with File \"lmsi15m.moon\" -- `file` is the value of `set_encoding()`.\n\t\\set_encoding \"utf8\"\n\ncreate_person = (name, relatives)->\n\twith Person!\n\t\t.name = name\n\t\t\\add_relative relative for relative in *relatives\nme = create_person \"Ryan\", {\"sister\", \"sister\", \"brother\", \"dad\", \"mother\"}\n\nwith str = \"Hello\" -- assignment as expression! :D\n\tprint \"original: #{str}\"\n\tprint \"upper: #{\\upper!}\"\n\n--------------------------------------------------\n-- 6.3 Destructuring\n--------------------------------------------------\n\n-- Destructuring can take arrays, tables, and nested tables and convert them\n-- into local variables.\n\nobj2 =\n\tnumbers: {1, 2, 3, 4}\n\tproperties:\n\t\tcolor: \"green\"\n\t\theight: 13.5\n\n{numbers: {first, second}, properties: {:color}} = obj2\n\nprint first, second, color -- 1 2 green\n\n-- `first` and `second` return [1] and [2] because they are as an array, but\n-- `:color` is like `color: color` so it sets itself to the `color` value.\n\n-- Destructuring can be used in place of `import`.\n\n{:max, :min, random: rand} = math -- rename math.random to rand\n\n-- Destructuring can be done anywhere assignment can be done.\n\nfor {left, right} in *{{\"hello\", \"world\"}, {\"egg\", \"head\"}}\n\tprint left, right\n```\n\n## Additional Resources\n\n- [Language Guide](https://moonscript.org/reference/)\n- [Online Compiler](https://moonscript.org/compiler/)"
