
package pages

const Perl = "Perl is a highly capable, feature-rich programming language with over 25 years of development.\n\nPerl runs on over 100 platforms from portables to mainframes and is suitable for both rapid prototyping and large scale development projects.\n\n```perl\n# Single line comments start with a number sign.\n\n#### Strict and warnings\n\nuse strict;\nuse warnings;\n\n# All perl scripts and modules should include these lines. Strict causes\n# compilation to fail in cases like misspelled variable names, and\n# warnings will print warning messages in case of common pitfalls like\n# concatenating to an undefined value.\n\n#### Perl variable types\n\n#  Variables begin with a sigil, which is a symbol showing the type.\n#  A valid variable name starts with a letter or underscore,\n#  followed by any number of letters, numbers, or underscores.\n\n### Perl has three main variable types: $scalar, @array, and %hash.\n\n## Scalars\n#  A scalar represents a single value:\nmy $animal = \"camel\";\nmy $answer = 42;\nmy $display = \"You have $answer ${animal}s.\\n\";\n\n# Scalar values can be strings, integers or floating point numbers, and\n# Perl will automatically convert between them as required.\n\n# Strings in single quotes are literal strings. Strings in double quotes\n# will interpolate variables and escape codes like \"\\n\" for newline.\n\n## Arrays\n#  An array represents a list of values:\nmy @animals = (\"camel\", \"llama\", \"owl\");\nmy @numbers = (23, 42, 69);\nmy @mixed   = (\"camel\", 42, 1.23);\n\n# Array elements are accessed using square brackets, with a $ to\n# indicate one value will be returned.\nmy $second = $animals[1];\n\n# The size of an array is retrieved by accessing the array in a scalar\n# context, such as assigning it to a scalar variable or using the\n# \"scalar\" operator.\n\nmy $num_animals = @animals;\nprint \"Number of numbers: \", scalar(@numbers), \"\\n\";\n\n# Arrays can also be interpolated into double-quoted strings, and the\n# elements are separated by a space character by default.\n\nprint \"We have these numbers: @numbers\\n\";\n\n# Be careful when using double quotes for strings containing symbols\n# such as email addresses, as it will be interpreted as a variable.\n\nmy @example = ('secret', 'array');\nmy $oops_email = \"foo@example.com\"; # 'foosecret array.com'\nmy $ok_email = 'foo@example.com';\n\n## Hashes\n#   A hash represents a set of key/value pairs:\n\nmy %fruit_color = (\"apple\", \"red\", \"banana\", \"yellow\");\n\n#  You can use whitespace and the \"=>\" operator to lay them out more\n#  nicely:\n\nmy %fruit_color = (\n  apple  => \"red\",\n  banana => \"yellow\",\n);\n\n# Hash elements are accessed using curly braces, again with the $ sigil.\nmy $color = $fruit_color{apple};\n\n# All of the keys or values that exist in a hash can be accessed using\n# the \"keys\" and \"values\" functions.\nmy @fruits = keys %fruit_color;\nmy @colors = values %fruit_color;\n\n# Scalars, arrays and hashes are documented more fully in perldata.\n# (perldoc perldata).\n\n#### References\n\n# More complex data types can be constructed using references, which\n# allow you to build arrays and hashes within arrays and hashes.\n\nmy $array_ref = \\@array;\nmy $hash_ref = \\%hash;\nmy @array_of_arrays = (\\@array1, \\@array2, \\@array3);\n\n# You can also create anonymous arrays or hashes, returning a reference:\n\nmy $fruits = [\"apple\", \"banana\"];\nmy $colors = {apple => \"red\", banana => \"yellow\"};\n\n# References can be dereferenced by prefixing the appropriate sigil.\n\nmy @fruits_array = @$fruits;\nmy %colors_hash = %$colors;\n\n# As a shortcut, the arrow operator can be used to dereference and\n# access a single value.\n\nmy $first = $array_ref->[0];\nmy $value = $hash_ref->{banana};\n\n# See perlreftut and perlref for more in-depth documentation on\n# references.\n\n#### Conditional and looping constructs\n\n# Perl has most of the usual conditional and looping constructs.\n\nif ($var) {\n  ...\n} elsif ($var eq 'bar') {\n  ...\n} else {\n  ...\n}\n\nunless (condition) {\n  ...\n}\n# This is provided as a more readable version of \"if (!condition)\"\n\n# the Perlish post-condition way\nprint \"Yow!\" if $zippy;\nprint \"We have no bananas\" unless $bananas;\n\n#  while\nwhile (condition) {\n  ...\n}\n\nmy $max = 5;\n# for loops and iteration\nfor my $i (0 .. $max) {\n  print \"index is $i\";\n}\n\nfor my $element (@elements) {\n  print $element;\n}\n\nmap {print} @elements;\n\n# implicitly\n\nfor (@elements) {\n  print;\n}\n\n# iterating through a hash (for and foreach are equivalent)\n\nforeach my $key (keys %hash) {\n  print $key, ': ', $hash{$key}, \"\\n\";\n}\n\n# the Perlish post-condition way again\nprint for @elements;\n\n# iterating through the keys and values of a referenced hash\nprint $hash_ref->{$_} for keys %$hash_ref;\n\n#### Regular expressions\n\n# Perl's regular expression support is both broad and deep, and is the\n# subject of lengthy documentation in perlrequick, perlretut, and\n# elsewhere. However, in short:\n\n# Simple matching\nif (/foo/)       { ... }  # true if $_ contains \"foo\"\nif ($x =~ /foo/) { ... }  # true if $x contains \"foo\"\n\n# Simple substitution\n\n$x =~ s/foo/bar/;         # replaces foo with bar in $x\n$x =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar in $x\n\n\n#### Files and I/O\n\n# You can open a file for input or output using the \"open()\" function.\n\n# For reading:\nopen(my $in,  \"<\",  \"input.txt\")  or die \"Can't open input.txt: $!\";\n# For writing (clears file if it exists):\nopen(my $out, \">\",  \"output.txt\") or die \"Can't open output.txt: $!\";\n# For writing (appends to end of file):\nopen(my $log, \">>\", \"my.log\")     or die \"Can't open my.log: $!\";\n\n# You can read from an open filehandle using the \"<>\" operator.  In\n# scalar context it reads a single line from the filehandle, and in list\n# context it reads the whole file in, assigning each line to an element\n# of the list:\n\nmy $line  = <$in>;\nmy @lines = <$in>;\n\n# You can write to an open filehandle using the standard \"print\"\n# function.\n\nprint $out @lines;\nprint $log $msg, \"\\n\";\n\n#### Writing subroutines\n\n# Writing subroutines is easy:\n\nsub logger {\n  my $logmessage = shift;\n\n  open my $logfile, \">>\", \"my.log\" or die \"Could not open my.log: $!\";\n\n  print $logfile $logmessage;\n}\n\n# Now we can use the subroutine just as any other built-in function:\n\nlogger(\"We have a logger subroutine!\");\n\n#### Modules\n\n# A module is a set of Perl code, usually subroutines, which can be used\n# in other Perl code. It is usually stored in a file with the extension\n# .pm so that Perl can find it.\n\npackage MyModule;\nuse strict;\nuse warnings;\n\nsub trim {\n  my $string = shift;\n  $string =~ s/^\\s+//;\n  $string =~ s/\\s+$//;\n  return $string;\n}\n\n1;\n\n# From elsewhere:\n\nuse MyModule;\nMyModule::trim($string);\n\n# The Exporter module can help with making subroutines exportable, so\n# they can be used like this:\n\nuse MyModule 'trim';\ntrim($string);\n\n# Many Perl modules can be downloaded from CPAN (http://www.cpan.org/)\n# and provide a range of features to help you avoid reinventing the\n# wheel.  A number of popular modules like Exporter are included with\n# the Perl distribution itself. See perlmod for more details on modules\n# in Perl.\n\n#### Objects\n\n# Objects in Perl are just references that know which class (package)\n# they belong to, so that methods (subroutines) called on it can be\n# found there. The bless function is used in constructors (usually new)\n# to set this up. However, you never need to call it yourself if you use\n# a module like Moose or Moo (see below).\n\npackage MyCounter;\nuse strict;\nuse warnings;\n\nsub new {\n  my $class = shift;\n  my $self = {count => 0};\n  return bless $self, $class;\n}\n\nsub count {\n  my $self = shift;\n  return $self->{count};\n}\n\nsub increment {\n  my $self = shift;\n  $self->{count}++;\n}\n\n1;\n\n# Methods can be called on a class or object instance with the arrow\n# operator.\n\nuse MyCounter;\nmy $counter = MyCounter->new;\nprint $counter->count, \"\\n\"; # 0\n$counter->increment;\nprint $counter->count, \"\\n\"; # 1\n\n# The modules Moose and Moo from CPAN can help you set up your object\n# classes. They provide a constructor and simple syntax for declaring\n# attributes. This class can be used equivalently to the one above.\n\npackage MyCounter;\nuse Moo; # imports strict and warnings\n\nhas 'count' => (is => 'rwp', default => 0, init_arg => undef);\n\nsub increment {\n  my $self = shift;\n  $self->_set_count($self->count + 1);\n}\n\n1;\n\n# Object-oriented programming is covered more thoroughly in perlootut,\n# and its low-level implementation in Perl is covered in perlobj.\n```\n\n#### FAQ\n\nperlfaq contains questions and answers related to many common tasks, and often provides suggestions for good CPAN modules to use.\n\n#### Further Reading\n\n - [perl-tutorial](http://perl-tutorial.org/)\n - [Learn at www.perl.com](http://www.perl.org/learn.html)\n - [perldoc](http://perldoc.perl.org/)\n - and perl built-in : `perldoc perlintro`"
