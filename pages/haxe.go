
package pages

const Haxe = "[Haxe](https://haxe.org/) is a general-purpose language that provides platform support for C++, C#,\nSwf/ActionScript, JavaScript, Java, PHP, Python, Lua, HashLink, and Neko bytecode\n(the latter two being also written by the Haxe author). Note that this guide is for\nHaxe version 3.  Some of the guide may be applicable to older versions, but it is\nrecommended to use other references.\n\n```csharp\n/*\n   Welcome to Learn Haxe 3 in 15 minutes.  http://www.haxe.org\n   This is an executable tutorial.  You can compile and run it using the haxe\n   compiler, while in the same directory as LearnHaxe.hx:\n   \n       $ haxe -main LearnHaxe3 --interp\n\n   Look for the slash-star marks surrounding these paragraphs.  We are inside\n   a \"Multiline comment\".  We can leave some notes here that will get ignored\n   by the compiler.\n\n   Multiline comments are also used to generate javadoc-style documentation for\n   haxedoc.  They will be used for haxedoc if they immediately precede a class,\n   class function, or class variable.\n */\n\n// Double slashes like this will give a single-line comment.\n\n/*\n   This is your first actual haxe code coming up, it's declaring an empty\n   package.  A package isn't necessary, but it's useful if you want to create\n   a namespace for your code (e.g. org.yourapp.ClassName).\n\n   Omitting package declaration is the same as declaring an empty package.\n */\npackage; // empty package, no namespace.\n\n/*\n   Packages are directories that contain modules. Each module is a .hx file\n   that contains types defined in a package. Package names (e.g. org.yourapp)\n   must be lower case while module names are capitalized. A module contain one\n   or more types whose names are also capitalized.\n\n   E.g, the class \"org.yourapp.Foo\" should have the folder structure\n   org/module/Foo.hx, as accessible from the compiler's working directory or\n   class path.\n\n   If you import code from other files, it must be declared before the rest of\n   the code.  Haxe provides a lot of common default classes to get you started:\n */\nimport haxe.ds.ArraySort;\n\n// you can import many classes/modules at once with \"*\"\nimport haxe.ds.*;\n\n// you can import static fields\nimport Lambda.array;\n\n// you can also use \"*\" to import all static fields\nimport Math.*;\n\n// You can also import classes in a special way, enabling them to extend the\n// functionality of other classes like a \"mixin\".  More on 'using' later.\nusing StringTools;\n\n// Typedefs are like variables... for types.  They must be declared before any\n// code.  More on this later.\ntypedef FooString = String;\n\n// Typedefs can also reference \"structural\" types, more on that later as well.\ntypedef FooObject = { foo: String };\n\n// Here's the class definition.  It's the main class for the file, since it has\n// the same name (LearnHaxe3).\nclass LearnHaxe3 {\n    /*\n       If you want certain code to run automatically, you need to put it in\n       a static main function, and specify the class in the compiler arguments.\n       In this case, we've specified the \"LearnHaxe3\" class in the compiler\n       arguments above.\n     */\n    static function main() {\n        /*\n           Trace is the default method of printing haxe expressions to the\n           screen.  Different targets will have different methods of\n           accomplishing this.  E.g., java, c++, c#, etc. will print to std\n           out.  Javascript will print to console.log, and flash will print to\n           an embedded TextField.  All traces come with a default newline.\n           Finally, It's possible to prevent traces from showing by using the\n           \"--no-traces\" argument on the compiler.\n         */\n        trace(\"Hello World, with trace()!\");\n\n        // Trace can handle any type of value or object.  It will try to print\n        // a representation of the expression as best it can.  You can also\n        // concatenate strings with the \"+\" operator:\n        trace(\"Integer: \" + 10 + \" Float: \" + 3.14 + \" Boolean: \" + true);\n\n        // In Haxe, it's required to separate expressions in the same block with\n        // semicolons.  But, you can put two expressions on one line:\n        trace('two expressions..'); trace('one line');\n\n\n        //////////////////////////////////////////////////////////////////\n        // Types & Variables\n        //////////////////////////////////////////////////////////////////\n        trace(\"***Types & Variables***\");\n\n        // You can save values and references to data structures using the\n        // \"var\" keyword:\n        var an_integer:Int = 1;\n        trace(an_integer + \" is the value for an_integer\");\n\n        /*\n           Haxe is statically typed, so \"an_integer\" is declared to have an\n           \"Int\" type, and the rest of the expression assigns the value \"1\" to\n           it.  It's not necessary to declare the type in many cases.  Here,\n           the haxe compiler is inferring that the type of another_integer\n           should be \"Int\".\n         */\n        var another_integer = 2;\n        trace(another_integer + \" is the value for another_integer\");\n\n        // The $type() method prints the type that the compiler assigns:\n        $type(another_integer);\n\n        // You can also represent integers with hexadecimal:\n        var hex_integer = 0xffffff;\n\n        /*\n           Haxe uses platform precision for Int and Float sizes.  It also\n           uses the platform behavior for overflow.\n           (Other numeric types and behavior are possible using special\n           libraries.)\n           \n           In addition to simple values like Integers, Floats, and Booleans,\n           Haxe provides standard library implementations for common data\n           structures like strings, arrays, lists, and maps:\n         */\n\n        // Strings can have double or single quotes.\n        var a_string = \"some\" + 'string';\n        trace(a_string + \" is the value for a_string\");\n\n        // Strings can be \"interpolated\" by inserting variables into specific\n        // positions.  The string must be single quoted, and the variable must\n        // be preceded with \"$\".  Expressions can be enclosed in ${...}.\n        var x = 1;\n        var an_interpolated_string = 'the value of x is $x';\n        var another_interpolated_string = 'the value of x + 1 is ${x + 1}';\n\n        // Strings are immutable, instance methods will return a copy of\n        // parts or all of the string. (See also the StringBuf class).\n        var a_sub_string = a_string.substr(0,4);\n        trace(a_sub_string + \" is the value for a_sub_string\");\n\n        // Regexes are also supported, but there's not enough space here to go\n        // into much detail.\n        var re = ~/foobar/;\n        trace(re.match('foo') + \" is the value for (~/foobar/.match('foo')))\");\n\n        // Arrays are zero-indexed, dynamic, and mutable.  Missing values are\n        // defined as null.\n        var a = new Array<String>(); // an array that contains Strings\n        a[0] = 'foo';\n        trace(a.length + \" is the value for a.length\");\n        a[9] = 'bar';\n        trace(a.length + \" is the value for a.length (after modification)\");\n        trace(a[3] + \" is the value for a[3]\"); //null\n\n        // Arrays are *generic*, so you can indicate which values they contain\n        // with a type parameter:\n        var a2 = new Array<Int>(); // an array of Ints\n        var a3 = new Array<Array<String>>(); // an Array of Arrays (of Strings).\n\n        // Maps are simple key/value data structures.  The key and the value\n        // can be of any type.\n        // Here, the keys are strings, and the values are Ints:\n        var m = new Map<String, Int>();\n        m.set('foo', 4);\n        // You can also use array notation:\n        m['bar'] = 5;\n        trace(m.exists('bar') + \" is the value for m.exists('bar')\");\n        trace(m.get('bar') + \" is the value for m.get('bar')\");\n        trace(m['bar'] + \" is the value for m['bar']\");\n\n        var m2 = ['foo' => 4, 'baz' => 6]; // Alternative map syntax\n        trace(m2 + \" is the value for m2\");\n\n        // Remember, you can use type inference.  The Haxe compiler will\n        // decide the type of the variable the first time you pass an\n        // argument that sets a type parameter.\n        var m3 = new Map();\n        m3.set(6, 'baz'); // m3 is now a Map<Int,String>\n        trace(m3 + \" is the value for m3\");\n\n        // Haxe has some more common datastructures in the haxe.ds module, such\n        // as List, Stack, and BalancedTree.\n\n\n        //////////////////////////////////////////////////////////////////\n        // Operators\n        //////////////////////////////////////////////////////////////////\n        trace(\"***OPERATORS***\");\n\n        // basic arithmetic\n        trace((4 + 3) + \" is the value for (4 + 3)\");\n        trace((5 - 1) + \" is the value for (5 - 1)\");\n        trace((2 * 4) + \" is the value for (2 * 4)\");\n        // Division always produces Floats.\n        trace((8 / 3) + \" is the value for (8 / 3) (a Float)\");\n        trace((12 % 4) + \" is the value for (12 % 4)\");\n\n        // basic comparison\n        trace((3 == 2) + \" is the value for 3 == 2\");\n        trace((3 != 2) + \" is the value for 3 != 2\");\n        trace((3 >  2) + \" is the value for 3 > 2\");\n        trace((3 <  2) + \" is the value for 3 < 2\");\n        trace((3 >= 2) + \" is the value for 3 >= 2\");\n        trace((3 <= 2) + \" is the value for 3 <= 2\");\n\n        // standard bitwise operators\n        /*\n            ~       Unary bitwise complement\n            <<      Signed left shift\n            >>      Signed right shift\n            >>>     Unsigned right shift\n            &       Bitwise AND\n            ^       Bitwise exclusive OR\n            |       Bitwise inclusive OR\n        */\n        \n        var i = 0;\n        trace(\"Pre-/Post- Increments and Decrements\");\n        trace(i++); // i = 1. Post-Increment\n        trace(++i); // i = 2. Pre-Increment\n        trace(i--); // i = 1. Post-Decrement\n        trace(--i); // i = 0. Pre-Decrement\n\n\n        //////////////////////////////////////////////////////////////////\n        // Control Structures\n        //////////////////////////////////////////////////////////////////\n        trace(\"***CONTROL STRUCTURES***\");\n\n        // if statements\n        var j = 10;\n        if (j == 10) {\n            trace(\"this is printed\");\n        } else if (j > 10) {\n            trace(\"not greater than 10, so not printed\");\n        } else {\n            trace(\"also not printed.\");\n        }\n\n        // there is also a \"ternary\" if:\n        (j == 10) ? trace(\"equals 10\") : trace(\"not equals 10\");\n\n        // Finally, there is another form of control structure that operates\n        // at compile time:  conditional compilation.\n#if neko\n        trace('hello from neko');\n#elseif js\n        trace('hello from js');\n#else\n        trace('hello from another platform!');\n#end\n\n        // The compiled code will change depending on the platform target.\n        // Since we're compiling for neko (-x or -neko), we only get the neko\n        // greeting.\n\n\n        trace(\"Looping and Iteration\");\n\n        // while loop\n        var k = 0;\n        while (k < 100) {\n            // trace(counter); // will print out numbers 0-99\n            k++;\n        }\n\n        // do-while loop\n        var l = 0;\n        do {\n            trace(\"do statement always runs at least once\");\n        } while (l > 0);\n\n        // for loop\n        // There is no c-style for loop in Haxe, because they are prone\n        // to error, and not necessary.  Instead, Haxe has a much simpler\n        // and safer version that uses Iterators (more on those later).\n        var m = [1, 2, 3];\n        for (val in m) {\n            trace(val + \" is the value for val in the m array\");\n        }\n\n        // Note that you can iterate on an index using a range\n        // (more on ranges later as well)\n        var n = ['foo', 'bar', 'baz'];\n        for (val in 0...n.length) {\n            trace(val + \" is the value for val (an index for n)\");\n        }\n\n\n        trace(\"Array Comprehensions\");\n\n        // Array comprehensions give you the ability to iterate over arrays\n        // while also creating filters and modifications.\n        var filtered_n = [for (val in n) if (val != \"foo\") val];\n        trace(filtered_n + \" is the value for filtered_n\");\n\n        var modified_n = [for (val in n) val += '!'];\n        trace(modified_n + \" is the value for modified_n\");\n\n        var filtered_and_modified_n\n            = [for (val in n) if (val != \"foo\") val += \"!\"];\n        trace(filtered_and_modified_n\n                + \" is the value for filtered_and_modified_n\");\n\n\n        //////////////////////////////////////////////////////////////////\n        // Switch Statements (Value Type)\n        //////////////////////////////////////////////////////////////////\n        trace(\"***SWITCH STATEMENTS (VALUE TYPES)***\");\n\n        /*\n           Switch statements in Haxe are very powerful.  In addition to working\n           on basic values like strings and ints, they can also work on the\n           generalized algebraic data types in enums (more on enums later).\n           Here are some basic value examples for now:\n         */\n        var my_dog_name = \"fido\";\n        var favorite_thing  = \"\";\n        switch (my_dog_name) {\n            case \"fido\" : favorite_thing = \"bone\";\n            case \"rex\"  : favorite_thing = \"shoe\";\n            case \"spot\" : favorite_thing = \"tennis ball\";\n            default     : favorite_thing = \"some unknown treat\";\n            // same as default:\n            // case _   : favorite_thing = \"some unknown treat\";\n        }\n        // The \"_\" case above is a \"wildcard\" value that will match anything.\n\n        trace(\"My dog's name is \" + my_dog_name\n                + \", and his favorite thing is a: \"\n                + favorite_thing);\n\n\n        //////////////////////////////////////////////////////////////////\n        // Expression Statements\n        //////////////////////////////////////////////////////////////////\n        trace(\"***EXPRESSION STATEMENTS***\");\n\n        // Haxe control statements are very powerful because every statement\n        // is also an expression, consider:\n\n        // if statements\n        var k = if (true) 10 else 20;\n\n        trace(\"k equals \", k); // outputs 10\n\n        var other_favorite_thing = switch (my_dog_name) {\n            case \"fido\" : \"teddy\";\n            case \"rex\"  : \"stick\";\n            case \"spot\" : \"football\";\n            default     : \"some unknown treat\";\n        }\n\n        trace(\"My dog's name is \" + my_dog_name\n                + \", and his other favorite thing is a: \"\n                + other_favorite_thing);\n\n\n        //////////////////////////////////////////////////////////////////\n        // Converting Value Types\n        //////////////////////////////////////////////////////////////////\n        trace(\"***CONVERTING VALUE TYPES***\");\n\n        // You can convert strings to ints fairly easily.\n\n        // string to integer\n        Std.parseInt(\"0\");     // returns 0\n        Std.parseFloat(\"0.4\"); // returns 0.4\n\n        // integer to string\n        Std.string(0); // returns \"0\"\n        // concatenation with strings will auto-convert to string.\n        0 + \"\";    // returns \"0\"\n        true + \"\"; // returns \"true\"\n        // See documentation for parsing in Std for more details.\n\n\n        //////////////////////////////////////////////////////////////////\n        // Dealing with Types\n        //////////////////////////////////////////////////////////////////\n\n        /*\n           As mentioned before, Haxe is a statically typed language.  All in\n           all, static typing is a wonderful thing.  It enables\n           precise autocompletions, and can be used to thoroughly check the\n           correctness of a program.  Plus, the Haxe compiler is super fast.\n\n           *HOWEVER*, there are times when you just wish the compiler would\n           let something slide, and not throw a type error in a given case.\n\n           To do this, Haxe has two separate keywords.  The first is the\n           \"Dynamic\" type:\n         */\n        var dyn: Dynamic = \"any type of variable, such as this string\";\n\n        /*\n           All that you know for certain with a Dynamic variable is that the\n           compiler will no longer worry about what type it is. It is like a\n           wildcard variable:  You can pass it instead of any variable type,\n           and you can assign any variable type you want.\n\n           The other more extreme option is the \"untyped\" keyword:\n         */\n        untyped {\n            var x:Int = 'foo'; // This can't be right!\n            var y:String = 4;  // Madness!\n        }\n\n        /*\n           The untyped keyword operates on entire *blocks* of code, skipping\n           any type checks that might be otherwise required. This keyword should\n           be used very sparingly, such as in limited conditionally-compiled\n           situations where type checking is a hindrance.\n\n           In general, skipping type checks is *not* recommended.  Use the\n           enum, inheritance, or structural type models in order to help ensure\n           the correctness of your program.  Only when you're certain that none\n           of the type models work should you resort to \"Dynamic\" or \"untyped\".\n         */\n\n\n        //////////////////////////////////////////////////////////////////\n        // Basic Object Oriented Programming\n        //////////////////////////////////////////////////////////////////\n        trace(\"***BASIC OBJECT ORIENTED PROGRAMMING***\");\n\n        // Create an instance of FooClass.  The classes for this are at the\n        // end of the file.\n        var foo_instance = new FooClass(3);\n\n        // read the public variable normally\n        trace(foo_instance.public_any\n                + \" is the value for foo_instance.public_any\");\n\n        // we can read this variable\n        trace(foo_instance.public_read\n                + \" is the value for foo_instance.public_read\");\n        // but not write it; this will throw an error if uncommented:\n        // foo_instance.public_read = 4;\n        // trace(foo_instance.public_write); // as will this.\n\n        // Calls the toString method:\n        trace(foo_instance + \" is the value for foo_instance\");\n        // same thing:\n        trace(foo_instance.toString()\n                + \" is the value for foo_instance.toString()\");\n\n        // The foo_instance has the \"FooClass\" type, while acceptBarInstance\n        // has the BarClass type.  However, since FooClass extends BarClass, it\n        // is accepted.\n        BarClass.acceptBarInstance(foo_instance);\n\n        // The classes below have some more advanced examples, the \"example()\"\n        // method will just run them here.\n        SimpleEnumTest.example();\n        ComplexEnumTest.example();\n        TypedefsAndStructuralTypes.example();\n        UsingExample.example();\n    }\n}\n\n// This is the \"child class\" of the main LearnHaxe3 Class.\nclass FooClass extends BarClass implements BarInterface {\n    public var public_any:Int; // public variables are accessible anywhere\n    public var public_read (default, null): Int; // enable only public read\n    public var public_write (null, default): Int; // or only public write\n    // Use this style to enable getters/setters:\n    public var property (get, set): Int;\n\n    // private variables are not available outside the class.\n    // see @:allow for ways around this.\n    var _private:Int; // variables are private if they are not marked public\n\n    // a public constructor\n    public function new(arg:Int) {\n        // call the constructor of the parent object, since we extended BarClass:\n        super();\n\n        this.public_any = 0;\n        this._private = arg;\n    }\n\n    // getter for _private\n    function get_property() : Int {\n        return _private;\n    }\n\n    // setter for _private\n    function set_property(val:Int) : Int {\n        _private = val;\n        return val;\n    }\n\n    // Special function that is called whenever an instance is cast to a string.\n    public function toString() {\n        return _private + \" with toString() method!\";\n    }\n\n    // this class needs to have this function defined, since it implements\n    // the BarInterface interface.\n    public function baseFunction(x: Int) : String {\n        // convert the int to string automatically\n        return x + \" was passed into baseFunction!\";\n    }\n}\n\n// A simple class to extend.\nclass BarClass {\n    var base_variable:Int;\n    public function new() {\n        base_variable = 4;\n    }\n    public static function acceptBarInstance(b:BarClass) {}\n}\n\n// A simple interface to implement\ninterface BarInterface {\n    public function baseFunction(x:Int):String;\n}\n\n\n//////////////////////////////////////////////////////////////////\n// Enums and Switch Statements\n//////////////////////////////////////////////////////////////////\n\n// Enums in Haxe are very powerful.  In their simplest form, enums\n// are a type with a limited number of states:\nenum SimpleEnum {\n    Foo;\n    Bar;\n    Baz;\n}\n\n//   Here's a class that uses it:\nclass SimpleEnumTest {\n    public static function example() {\n        // You can specify the \"full\" name,\n        var e_explicit:SimpleEnum = SimpleEnum.Foo;\n        var e = Foo; // but inference will work as well.\n        switch (e) {\n            case Foo: trace(\"e was Foo\");\n            case Bar: trace(\"e was Bar\");\n            case Baz: trace(\"e was Baz\"); // comment this line to throw an error.\n        }\n\n        /*\n           This doesn't seem so different from simple value switches on strings.\n           However, if we don't include *all* of the states, the compiler will\n           complain.  You can try it by commenting out a line above.\n\n           You can also specify a default for enum switches as well:\n         */\n        switch (e) {\n            case Foo: trace(\"e was Foo again\");\n            default : trace(\"default works here too\");\n        }\n    }\n}\n\n// Enums go much further than simple states, we can also enumerate\n// *constructors*, but we'll need a more complex enum example.\nenum ComplexEnum {\n    IntEnum(i:Int);\n    MultiEnum(i:Int, j:String, k:Float);\n    SimpleEnumEnum(s:SimpleEnum);\n    ComplexEnumEnum(c:ComplexEnum);\n}\n// Note: The enum above can include *other* enums as well, including itself!\n// Note: This is what's called *Algebraic data type* in some other languages.\n\nclass ComplexEnumTest {\n    public static function example() {\n        var e1:ComplexEnum = IntEnum(4); // specifying the enum parameter\n        // Now we can switch on the enum, as well as extract any parameters\n        // it might have had.\n        switch (e1) {\n            case IntEnum(x) : trace('$x was the parameter passed to e1');\n            default: trace(\"Shouldn't be printed\");\n        }\n\n        // another parameter here that is itself an enum... an enum enum?\n        var e2 = SimpleEnumEnum(Foo);\n        switch (e2){\n            case SimpleEnumEnum(s): trace('$s was the parameter passed to e2');\n            default: trace(\"Shouldn't be printed\");\n        }\n\n        // enums all the way down\n        var e3 = ComplexEnumEnum(ComplexEnumEnum(MultiEnum(4, 'hi', 4.3)));\n        switch (e3) {\n            // You can look for certain nested enums by specifying them\n            //  explicitly:\n            case ComplexEnumEnum(ComplexEnumEnum(MultiEnum(i,j,k))) : {\n                trace('$i, $j, and $k were passed into this nested monster');\n            }\n            default: trace(\"Shouldn't be printed\");\n        }\n        // Check out \"generalized algebraic data types\" (GADT) for more details\n        // on why these are so great.\n    }\n}\n\nclass TypedefsAndStructuralTypes {\n    public static function example() {\n        // Here we're going to use typedef types, instead of base types.\n        // At the top we've declared the type \"FooString\" to mean a \"String\" type.\n        var t1:FooString = \"some string\";\n\n        // We can use typedefs for \"structural types\" as well.  These types are\n        // defined by their field structure, not by class inheritance.  Here's\n        // an anonymous object with a String field named \"foo\":\n        var anon_obj = { foo: 'hi' };\n\n        /*\n           The anon_obj variable doesn't have a type declared, and is an\n           anonymous object according to the compiler.  However, remember back at\n           the top where we declared the FooObj typedef?  Since anon_obj matches\n           that structure, we can use it anywhere that a \"FooObject\" type is\n           expected.\n         */\n        var f = function(fo:FooObject) {\n            trace('$fo was passed in to this function');\n        }\n        f(anon_obj); // call the FooObject signature function with anon_obj.\n\n        /*\n           Note that typedefs can have optional fields as well, marked with \"?\"\n\n           typedef OptionalFooObj = {\n                ?optionalString: String,\n                requiredInt: Int\n           }\n\n           Typedefs work well with conditional compilation.  For instance,\n           we could have included this at the top of the file:\n\n#if( js )\n        typedef Surface = js.html.CanvasRenderingContext2D;\n#elseif( nme )\n        typedef Surface = nme.display.Graphics;\n#elseif( !flash9 )\n        typedef Surface = flash8.MovieClip;\n#elseif( java )\n        typedef Surface = java.awt.geom.GeneralPath;\n#end\n\n           That would give us a single \"Surface\" type to work with across\n           all of those platforms.\n         */\n    }\n}\n\nclass UsingExample {\n    public static function example() {\n        /*\n           The \"using\" import keyword is a special type of class import that\n           alters the behavior of any static methods in the class.\n\n           In this file, we've applied \"using\" to \"StringTools\", which contains\n           a number of static methods for dealing with String types.\n         */\n        trace(StringTools.endsWith(\"foobar\", \"bar\") + \" should be true!\");\n\n        /*\n           With a \"using\" import, the first argument type is extended with the\n           method.  What does that mean?  Well, since \"endsWith\" has a first\n           argument type of \"String\", that means all String types now have the\n           \"endsWith\" method:\n         */\n        trace(\"foobar\".endsWith(\"bar\") + \" should be true!\");\n\n        /*\n           This technique enables a good deal of expression for certain types,\n           while limiting the scope of modifications to a single file.\n\n           Note that the String instance is *not* modified in the run time.\n           The newly attached method is not really part of the attached\n           instance, and the compiler still generates code equivalent to a\n           static method.\n         */\n    }\n}\n\n```\n\nWe're still only scratching the surface here of what Haxe can do.  For a formal\noverview of all Haxe features, see the [manual](https://haxe.org/manual) and\nthe [API docs](https://api.haxe.org/). For a comprehensive directory of available\nthird-party Haxe libraries, see [Haxelib](https://lib.haxe.org/).\n\nFor more advanced topics, consider checking out:\n\n* [Abstract types](https://haxe.org/manual/types-abstract.html)\n* [Macros](https://haxe.org/manual/macro.html)\n* [Compiler Features](https://haxe.org/manual/cr-features.html)\n\n\nFinally, please join us on [the Haxe forum](https://community.haxe.org/),\non IRC [#haxe on\nfreenode](http://webchat.freenode.net/), or on the\n[Haxe Gitter chat](https://gitter.im/HaxeFoundation/haxe)."
