
package pages

const Raku_Pod = "Pod is an easy-to-use and purely descriptive mark-up language,\nwith no presentational components. Besides its use for documenting\nRaku programs and modules, Pod can be utilized to write language\ndocumentation, blogs, and other types of document composition as well.\n\nPod documents can be easily converted to HTML and many other formats\n(e.g., Markdown, Latex, plain text, etc.) by using the corresponding\nvariant of the `Pod::To` modules (e.g. `Pod::To::HTML` for HTML conversion).\n\n- [General Info](#general-info)\n- [Pod Basics](#pod-basics)\n\t- [Basic Text Formatting](#basic-text-formatting)\n\t- [Headings](#headings)\n\t- [Ordinary Paragraphs](#ordinary-paragraphs)\n\t- [Lists](#lists)\n\t- [Code Blocks](#code-blocks)\n\t- [Comments](#comments)\n\t- [Links](#links)\n\t- [Tables](#tables)\n- [Block Structures](#block-structures)\n\t- [Abbreviated Blocks](#abbreviated-blocks)\n\t- [Delimited Blocks](#delimited-blocks)\n\t- [Paragraph Blocks](#paragraph-blocks)\n- [Configuration Data](#configuration-data)\n\t- [Standard Configuration Options](#standard-configuration-options)\n\t- [Block Pre-configuration](#block-pre-configuration)\n- [Semantic Blocks](#semantic-blocks)\n- [Miscellaneous](#miscellaneous)\n\t- [Notes](#notes)\n\t- [Keyboard Input](#keyboard-input)\n\t- [Terminal Output](#terminal-output)\n\t- [Unicode](#unicode)\n- [Rendering Pod](#rendering-pod)\n- [Accessing Pod](#accessing-pod)\n\n## General Info\n\nEvery Pod document has to begin with `=begin pod` and end with `=end pod`.\nEverything between these two delimiters will be processed and used to\ngenerate documentation.\n\n```\n=begin pod\n\nA very simple Raku Pod document. All the other directives go here!\n\n=end pod\n```\n\nPod documents usually coexist with Raku code. If by themselves,\nPod files often have the `.pod6` suffix. Moving forward, it's assumed that\nthe constructs being discussed are surrounded by the `=begin pod ... =end pod`\ndirectives.\n\n## Pod Basics\n\n### Basic Text Formatting\n\nText can be easily styled as bold, italic, underlined or verbatim (for code\nformatting) using the following formatting codes: `B<>`, `I<>`, `U<>`\nand `C<>`.\n\n```\nB<This text is in Bold.>\n\nI<This text is in Italics.>\n\nU<This text is Underlined.>\n\nThe function C<sub sum { $^x + $^y}> is treated as verbatim.\n```\n\nThere are more formatting codes (e.g., `L<>`, `T<>`, etc.) but they'll be\ndiscussed later throughout the document. You'll recognize them because they're\njust a single capital letter followed immediately by a set of single or double\nangle brackets. The Unicode variant («») of the angle brackets can also be\nused.\n\n### Headings\n\nHeadings are created by using the `=headN` directive where `N` is the\nheading level.\n\n```\n=head1 This is level 1\n=head2 This is level 2\n=head3 This is level 3\n=head4 This is level 4\n=head5 This is level 5\n=head6 This is level 6\n```\n\n### Ordinary Paragraphs\n\nOrdinary paragraphs consist of one or more adjacent lines of text, each of\nwhich starts with a non-whitespace character. Any paragraph is terminated\nby the first blank line or block directive.\n\n```\n=head1 First level heading block\n\n=head2 Paragraph 1\n\nThis is an ordinary paragraph. Its text will be squeezed and\nshort lines filled. It is terminated by the first blank line.\n\n=head2 Paragraph 2\n\nThis is another ordinary paragraph albeit shorter.\n```\n\nAlternatively, the `=para` directive can be used to explicitly mark adjacent\nlines of text as a paragraph.\n\n```\n=head1 First level heading block\n\n=head2 Paragraph 1\n\n=para\nThis is an ordinary paragraph. Its text will be squeezed and\nshort lines filled. It is terminated by the first blank line.\n\n=head2 Paragraph 2\n\n=para\nThis is another ordinary paragraph albeit shorter.\n```\n\n### Lists\n\nUnordered lists can be created using the `=item` directive.\n\n```\n=item Item\n=item Item\n=item Another item\n```\n\nSublists are achieved with items at each level specified using the `=item1`,\n`=item2`, `=item3`, `...`, `=itemN` etc. directives. The `=item` directive\ndefaults to `=item1`.\n\n```\n=item1 Item one\n=item1 Item two\n=item1 Item three\n    =item2 Sub-item\n    =item2 Sub-item\n=item1 Item four\n```\n\nDefinition lists that define terms or commands use the `=defn` directive.\nThis is equivalent to the `<dl>` element in HTML.\n\n```\n=defn Beast of Bodmin\nA large feline inhabiting Bodmin Moor.\n\n=defn Morgawr\nA sea serpent.\n\n=defn Owlman\nA giant owl-like creature.\n```\n\n### Code Blocks\n\nA code block is created (which uses the HTML `<code>` element) by starting each\nline with one or more whitespace characters.\n\n```\n    #`( this is comment )\n    my $sum = -> $x, $y { $x + $y }\n    say $sum(12, 5);\n```\n\nAs shown in the [Basic Text Formatting](#basic-text-formatting) section,\ninline code can be created using the `C<>` code.\n\n```\nIn Raku, there are several functions/methods to output text. Some of them\nare C<print>, C<put> and C<say>.\n```\n\n### Comments\n\nAlthough Pod blocks are ignored by the Rakudo Raku compiler, everything\nindentified as a Pod block will be read and interpreted by Pod renderers. In\norder to prevent Pod blocks from being rendered by any renderer, use the\n`=comment` directive.\n\n```\n=comment Add more here about the algorithm.\n\n=comment Pod comments are great for documenting the documentation.\n```\n\nTo create inline comments, use the `Z<>` code.\n\n```\nPod is awesome Z<Of course it is!>. And Raku too!\n```\n\nGiven that the Raku interpreter never executes embedded Pod blocks,\ncomment blocks can also be used as an alternative form of nestable block\ncomments.\n\n### Links\n\nCreating links in Pod is quite easy and is done by enclosing them in\na `L<>` code. The general format is `L<Label|Url>` with `Label`\nbeing optional.\n\n```\nRaku homepage is L<https://raku.org>.\nL<Click me!|http://link.org/>.\n```\n\nRelative paths work too.\n\n```\nL<Go to music|/music/>.\n```\n\nLinking to a section in the same document works as well.\n\n```\nL<Link to Headings|#Headings>\n```\n\n### Tables\n\nThe Pod specifications are not completely handled properly yet and this\nincludes the handling of table. For simplicity's sake, only one way of\nconstructing tables is shown here. To learn about good practices and see\nexamples of both good and bad tables, please visit\n<https://docs.raku.org/language/tables>.\n\n```\n=begin table\nOption      | Description     \n============|================  \ndata        | path to data files.\nengine      | engine to be used for processing templates.\next         | extension to be used for dest files.\n=end table\n```\n\n## Block Structures\n\nAs mentioned earlier, Pod documents are specified using directives, which are\nused to delimit blocks of textual content and declare optional\n[configuration information](#configuration-data). Every directive starts with\nan equals sign (`=`) in the first column. The content of a document is\nspecified within one or more blocks. Every Pod block may be declared in any of\nthree equivalent forms: delimited style, paragraph style, or abbreviated style.\n\nUp to this point, we have only used the abbreviated style for the block\ntypes (e.g., `=head1`, `=para`, `=comment`, `=item`, etc).\n\n### Abbreviated Blocks\n\nAbbreviated blocks are introduced by an `=` sign in the first column, which\nis followed immediately by the `typename` of the block and then the content.\nThe rest of the line is treated as block data, rather than as configuration.\nThe content terminates at the next Pod directive or the first blank line\n(which is not part of the block data). The general syntax is\n\n```\n=BLOCK_TYPE  BLOCK_DATA\n```\nFor example:\n\n```\n=head1 Top level heading\n```\n\n### Delimited Blocks\n\nDelimited blocks are bounded by `=begin` and `=end` markers, both of which are\nfollowed by a valid Pod identifier, which is the `typename` of the block.\nThe general syntax is\n\n```\n=begin BLOCK_TYPE\nBLOCK_DATA\n=end BLOCK_TYPE\n```\n\nFor example:\n\n```\n=begin head1\nTop level heading\n=end head1\n```\n\nThis type of blocks is useful for creating headings, list items, code blocks,\netc. with multiple paragraphs. For example,\n\n* a multiline item of a list\n\n```\n=begin item\nThis is a paragraph in list item.\n\nThis is another paragraph in the same list item.\n=end item\n```\n\n* a code block\n\n```\n=begin code\n#`(\nA non-efficient recursive implementation of a power function using multi subs.\n)\n\nmulti pow( Real $base, 0 ) { 1 }\n\nmulti pow( Real $base, Int $exp where * ≥ 0) {\n\t$base * pow($base, $exp - 1)\n}\n\nmulti pow( Real $base ) {\n     pow($base, 2)\n}\n\nsay pow(3, 0);   #=> 1\nsay pow(4.2, 2); #=> 17.64\nsay pow(6);      #=> 36\n=end code\n```\n\n### Paragraph Blocks\n\nParagraph blocks are introduced by a `=for` marker and terminated by\nthe next Pod directive or the first blank line (which is not considered to\nbe part of the block's contents). The `=for` marker is followed by the\n`typename` of the block. The general syntax is\n\n```\n=for BLOCK_TYPE\nBLOCK DATA\n```\n\nFor example:\n\n```\n=for head1\nTop level heading\n```\n\n## Configuration Data\n\nExcept for abbreviated blocks, both delimited blocks and paragraph\nblocks can be supplied with configuration information about their\ncontents right after the `typename` of the block. Thus the following\nare more general syntaxes for these blocks:\n\n* Delimited blocks\n\n```\n=begin BLOCK_TYPE OPTIONAL_CONFIG_INFO\n=                 ADDITIONAL_CONFIG_INFO\nBLOCK_DATA\n=end BLOCK_TYPE\n```\n\n* Paragraph blocks\n\n```\n=for BLOCK_TYPE OPTIONAL_CONFIG_INFO\n=               ADDITIONAL_CONFIG_INFO\nBLOCK DATA\n```\n\nThe configuration information is provided in a format akin to the\n[\"colon pair\"](https://docs.raku.org/language/glossary#index-entry-Colon_Pair)\nsyntax in Raku. The following table is a simplified version of the\ndifferent ways in which configuration info can be supplied. Please go to\n<https://docs.raku.org/language/pod#Configuration_information> for a more\nthorough treatment of the subject.\n\n| Value     | Specify with...             | Example                        |\n| :-------- | :------                     | :------                        |\n| List      | :key($elem1, $elem2, ...)   | :tags('Pod', 'Raku')          |\n| Hash      | :key{$key1 => $value1, ...} | :feeds{url => 'raku.org'}     |\n| Boolean   | :key/:key(True)             | :skip-test(True)               |\n| Boolean   | :!key/:key(False)           | :!skip-test                    |\n| String    | :key('string')              | :nonexec-reason('SyntaxError') |\n| Int       | :key(2)                     | :post-number(6)                |\n\n\n### Standard Configuration Options\n\nPod provides a small number of standard configuration options that can\nbe applied uniformly to built-in block types. Some of them are:\n\n* `:numbered`\n\nThis option specifies that the block is to be numbered. The most common\nuse of this option is to create numbered headings and ordered lists, but it\ncan be applied to any block.\n\nFor example:\n\n```\n=for head1 :numbered\nThe Problem\n=for head1 :numbered\nThe Solution\n=for head2 :numbered\nAnalysis\n=for head3 :numbered\nOverview\n```\n\n* `:allow`\n\nThe value of the `:allow` option must be a list of the (single-letter) names\nof one or more formatting codes. Those codes will then remain active inside\nthe code block. The option is most often used on `=code` blocks to allow\nmark-up within those otherwise verbatim blocks, though it can be used in any\nblock that contains verbatim text.\n\nGiven the following snippet:\n\n```\n=begin code :allow('B', 'I')\nB<sub> greet( $name ) {\n    B<say> \"Hello, $nameI<!>\";\n}\n=end code\n```\n\nwe get the following output:\n\n<pre><strong>sub</strong> greet( $name ) {\n    <strong>say</strong> &quot;Hello, $name<em>!</em>&quot;;\n}\n</pre>\n\nThis is highly dependent on the format output. For example, while this works\nwhen Pod is converted to HTML, it might not be preserved when converted\nto Markdown.\n\n### Block Pre-configuration\n\nThe `=config` directive allows you to prespecify standard configuration\ninformation that is applied to every block of a particular type.\nThe general syntax for configuration directives is:\n\n```\n=config BLOCK_TYPE  CONFIG OPTIONS\n=                  ADDITIONAL_CONFIG_INFO\n```\n\nFor example, to specify that every heading level 1 be numbered, bold\nand underlined, you preconfigure the `=head1` as follows:\n\n```\n=config head1 :formatted('B', 'U') :numbered\n```\n\n## Semantic Blocks\n\nAll uppercase block typenames are reserved for specifying standard\ndocumentation, publishing, source components, or meta-information.\nSome of them are:\n\n```\n=NAME\n=AUTHOR\n=VERSION\n=CREATED\n=SYNOPSIS\n=DESCRIPTION\n=USAGE\n```\n\nMost of these blocks would typically be used in their full\ndelimited forms. For example,\n\n```\n=NAME B<Doc::Magic>\n\n=begin DESCRIPTION\nThis module helps you generate documentation automagically.\nNot source code needed! Most of it is outsourced from a black hole.\n=end DESCRIPTION\n\n=begin SYNOPSIS\n=begin code\n\tuse Doc::Magic;\n\n \tmy Doc::Magic $doc .= new();\n\n    my $result = $doc.create-documentation($fh);\n=end code\n=end SYNOPSIS\n\n=AUTHOR Authorius Docus\n=VERSION 42\n```\n\n## Miscellaneous\n\n### Notes\n\nNotes are rendered as footnotes and created by enclosing a note in a\n`N<>` code.\n\n```\nIn addition, the language is also multi-paradigmatic N<According to Wikipedia,\nthis means that it supports procedural, object-oriented, and functional\nprogramming.>\n```\n\n### Keyboard Input\n\nTo flag text as keyboard input enclose it in a `K<>` code.\n\n```\nEnter your name K<John Doe>\n```\n\n### Terminal Output\n\nTo flag text as terminal output enclose it in `T<>` code.\n\n```\nHello, T<John Doe>\n```\n\n### Unicode\n\nTo include Unicode code points or HTML5 character references in\na Pod document, enclose them in a `E<>` code.\n\nFor example:\n\n```\nRaku makes considerable use of the E<171> and E<187> characters.\nRaku makes considerable use of the E<laquo> and E<raquo> characters.\n```\n\nis rendered as:\n\nRaku makes considerable use of the « and » characters.\nRaku makes considerable use of the « and » characters.\n\n## Rendering Pod\n\nTo generate any output (i.e., Markdown, HTML, Text, etc.), you need to\nhave the Rakudo Raku compiler installed. In addition, you must install\na module (e.g., `Pod::To::Markdown`, `Pod::To::HTML`, `Pod::To::Text`, etc.)\nthat generates your desired output from Pod.\n\nFor instructions about installing Rakudo for running raku programs,\n[look here](https://raku.org/downloads/).\n\nRun the following command to generate a certain output:\n\n```\nraku --doc=TARGET input.pod6 > output.html\n```\n\nwith `TARGET` being `Markdown`, `HTML`, `Text`, etc. Thus to generate\nMarkdown from Pod, run this:\n\n```\nraku --doc=Markdown input.pod6 > output.html\n```\n\n## Accessing Pod\n\nIn order to access Pod documentation from within a Raku program,\nit is required to use the special `=` twigil (e.g., `$=pod`, `$=SYNOPSIS`,etc).\n\nThe `$=` construct provides the introspection over the Pod structure,\nproducing a `Pod::Block` tree root from which it is possible to access\nthe whole structure of the Pod document.\n\nIf we place the following piece of Raku code and the Pod documentation\nin the section [Semantic blocks](#semantic-blocks) in the same file:\n\n```\nmy %used-directives;\nfor $=pod -> $pod-item {\n    for $pod-item.contents -> $pod-block {\n        next unless $pod-block ~~ Pod::Block::Named;\n        %used-directives{$pod-block.name} = True;\n    }\n}\n\nsay %used-directives.keys.join(\"\\n\");\n```\n\nwe get the following output:\n\n```\nSYNOPSIS\nNAME\nVERSION\nAUTHOR\nDESCRIPTION\n```\n\n## Additional Information\n\n* <https://docs.raku.org/language/pod> for the Pod documentation.\n* <https://docs.raku.org/language/tables> for advices about Pod tables.\n* <https://design.raku.org/S26.html> for the Pod specification."
