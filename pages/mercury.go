
package pages

const Mercury = "Mercury is a strict, pure functional/logic programming language, with\ninfluences from Prolog, ML, and Haskell.\n\n```prolog\n% Percent sign starts a one-line comment.\n\n    % foo(Bar, Baz)\n    %\n    % Documentation comments are indented before what they describe.\n:- pred foo(bar::in, baz::out) is det.\n\n% All toplevel syntax elements end with a '.' -- a full stop.\n\n% Mercury terminology comes from predicate logic. Very roughly:\n\n% | Mercury               | C                            |\n% |                       |                              |\n% | Goal                  | statement                    |\n% | expression            | expression                   |\n% | predicate rule        | void function                |\n% | function rule         | function                     |\n% | head (of a rule)      | function name and parameters |\n% | body (of a rule)      | function body                |\n% | fact                  | (rule without a body)        |\n% | pred/func declaration | function signature           |\n% | A, B  (conjunction)   | A && B                       |\n% | A ; B (disjunction)   | if (A) {} else if (B) {}     |\n\n% some facts:\nman(socrates).  % \"it is a fact that Socrates is a man\"\nman(plato).\nman(aristotle).\n\n% a rule:\nmortal(X) :- man(X).  % \"It is a rule that X is a mortal if X is a man.\"\n%            ^^^^^^-- the body of the rule\n%         ^^-- an arrow <--, pointing to the head from the body\n%^^^^^^^^-- the head of the rule\n% this is also a single clause that defines the rule.\n\n% that X is capitalized is how you know it's a variable.\n% that socrates is uncapitalized is how you know it's a term.\n\n% it's an error for 'socrates' to be undefined. It must have a type:\n\n% declarations begin with ':-'\n:- type people\n    --->    socrates\n    ;       plato\n    ;       aristotle\n    ;       hermes.\n    %<--first tab stop (using 4-space tabs)\n            %<--third tab stop (first after --->)\n\n:- pred man(people).  % rules and facts also require types\n\n% a rule's modes tell you how it can be used.\n:- mode man(in) is semidet.  % man(plato) succeeds. man(hermes) fails.\n:- mode man(out) is multi.   % man(X) binds X to one of socrates ; plato ; aristotle\n\n% a semidet predicate is like a test. It doesn't return a value, but\n% it can succeed or fail, triggering backtracking or the other side of\n% a disjunction or conditional.\n\n% 'is semidet' provides the determinism of a mode. Other determinisms:\n% | Can fail? | 0 solutions | 1       | more than 1 |\n% |           |             |         |             |\n% | no        | erroneous   | det     | multi       |\n% | yes       | failure     | semidet | nondet      |\n\n:- pred mortal(people::in) is semidet.  % type/mode in one declaration\n\n% this rule's body consists of two conjunctions: A, B, C\n% this rule is true if A, B, and C are all true.\n% if age(P) returns 16, it fails.\n% if alive(P) fails, it fails.\n:- type voter(people::in) is semidet.\nvoter(P) :-\n    alive(P),\n    registered(P, locale(P)),\n    age(P) >= 18.  % age/1 is a function; int.>= is a function used as an operator\n\n% \"a P is a voter if it is alive, is registered in P's locale, and if\n% P's age is 18 or older.\"\n\n% the >= used here is provided by the 'int' module, which isn't\n% imported by default. Mercury has a very small 'Prelude' (the\n% 'builtin' module). You even need to import the 'list' module if\n% you're going to use list literals.\n```\n\nComplete runnable example. File in 'types.m'; compile with 'mmc --make types'.\n\n```prolog\n:- module types.\n:- interface.\n:- import_module io.  % required for io.io types in...\n% main/2 is usually 'det'. threading and exceptions require 'cc_multi'\n:- pred main(io::di, io::uo) is cc_multi.  % program entry point\n:- implementation.\n:- import_module int, float, string, list, bool, map, exception.\n\n% enum.\n:- type days\n    --->    sunday\n    ;       monday\n    ;       tuesday\n    ;       wednesday\n    ;       thursday\n    ;       friday\n    ;       saturday.\n\n% discriminated union, like datatype in ML.\n:- type payment_method\n    --->    cash(int)\n    ;       credit_card(\n                name :: string,         % named fields\n                cc_number :: string,\n                cvv :: int,\n                expiration :: string\n            )\n    ;       crypto(coin_type, wallet, amount).\n\n:- type coin_type\n    --->    etherium\n    ;       monero.  % \"other coins are available\"\n\n% type aliases.\n:- type wallet == string.\n:- type amount == int.\n\n% !IO is the pair of io.io arguments\n% pass it to anything doing I/O, in order to perform I/O.\n% many otherwise-impure functions can 'attach to the I/O state' by taking !IO\nmain(!IO) :-\n    Ints = [\n        3,\n        1 + 1,\n        8 - 1,\n        10 * 2,\n        35 / 5,\n        5 / 2,      % truncating division\n        int.div(5, 2),  % floored division\n        div(5, 2),  % (module is unambiguous due to types)\n        5 `div` 2,  % (any binary function can be an operator with ``)\n        7 `mod` 3,  % modulo of floored division\n        7 `rem` 3,  % remainder of truncating division\n        2 `pow` 4,  % 2 to the 4th power\n        (1 + 3) * 2,    % parens have their usual meaning\n\n        2 >> 3,     % bitwise right shift\n        128 << 3,   % bitwise left shift\n        \\ 0,        % bitwise complement\n        5 /\\ 1,     % bitwise and\n        5 \\/ 1,     % bitwise or\n        5 `xor` 3,  % bitwise xor\n\n        max_int,\n        min_int,\n\n        5 `min` 3,  % ( if 5 > 3 then 3 else 5 )\n        5 `max` 3\n    ],\n    Bools = [\n        yes,\n        no\n        % bools are much less important in Mercury because control flow goes by\n        % semidet goals instead of boolean expressions.\n    ],\n    Strings = [\n        \"this is a string\",\n        \"strings can have \"\" embedded doublequotes via doubling\",\n        \"strings support \\u4F60\\u597D the usual escapes\\n\",\n        % no implicit concatenation of strings: \"concat:\" \"together\"\n        \"but you can \" ++ \" use the string.++ operator\",\n\n        % second param is a list(string.poly_type)\n        % s/1 is a function that takes a string and returns a poly_type\n        % i/1 takes an int. f/1 takes a float. c/1 takes a char.\n        string.format(\"Hello, %d'th %s\\n\", [i(45), s(\"World\")])\n    ],\n\n    % start with purely functional types like 'map' and 'list'!\n    % arrays and hash tables are available too, but using them\n    % requires knowing a lot more about Mercury\n    get_map1(Map1),\n    get_map2(Map2),\n\n    % list.foldl has *many* variations\n    % this one calls io.print_line(X, !IO) for each X of the list\n    foldl(io.print_line, Ints, !IO),\n    foldl(io.print_line, Bools, !IO),\n    foldl(io.print_line, Strings, !IO),\n    io.print_line(Map1, !IO),\n    % ( if Cond then ThenGoal else ElseGoal )\n    % I/O not allowed in Cond: I/O isn't allowed to fail!\n    ( if Map2^elem(42) = Elem then\n        io.print_line(Elem, !IO)\n    else % always required\n        true  % do nothing, successfully (vs. 'fail')\n    ),\n\n    % exception handling:\n    ( try [io(!IO)] ( % io/1 param required or no I/O allowed here\n        io.print_line(received(cash(1234)), !IO),\n        io.print_line(received(crypto(monero, \"invalid\", 123)), !IO)\n    ) then\n        io.write_string(\"all payments accepted\\n\", !IO) % never reached\n    catch \"monero not yet supported\" -> % extremely specific catch!\n        io.write_string(\"monero payment failed\\n\", !IO)\n    ).\n\n:- pred get_map1(map(string, int)::out) is det.\nget_map1(!:Map) :-  % !:Map in the head is the final (free, unbound) Map\n    !:Map = init,   % !:Map in the body is the next Map\n    det_insert(\"hello\", 1, !Map),  % pair of Map vars\n    det_insert(\"world\", 2, !Map),\n\n    % debug print of current (bound) Map\n    % other [Params] can make it optional per runtime or compiletime flags\n    trace [io(!IO)] (io.print_line(!.Map, !IO)),\n\n    det_insert_from_corresponding_lists(K, V, !Map),\n    % this code is reordered so that K and V and defined prior to their use\n    K = [\"more\", \"words\", \"here\"],\n    V = [3, 4, 5].\n\n:- pred get_map2(map(int, bool)::out) is det.\nget_map2(Map) :-\n    det_insert(42, yes, map.init, Map).\n\n:- func received(payment_method) = string.\nreceived(cash(N)) = string.format(\"received %d dollars\", [i(N)]).\nreceived(credit_card(_, _, _, _)) = \"received credit card\".  % _ is throwaway\nreceived(crypto(Type, _Wallet, Amount)) = S :-  % _Wallet is named throwaway\n    ( % case/switch structure\n        Type = etherium,\n        S = string.format(\"receiving %d ETH\", [i(Amount)])\n    ;\n        Type = monero,\n        throw(\"monero not yet supported\")  % exception with string as payload\n    ).\n```\n\n## That was quick! Want more?\n\n### More Tutorials\n\n* [Mercury Tutorial](https://mercurylang.org/documentation/papers/book.pdf) (pdf link) - a more traditional tutorial with a more relaxed pace\n* [Mercury Crash Course](https://mercury-in.space/crash.html) - a dense example-driven tutorial with Q&A format\n* [Github Wiki Tutorial](https://github.com/Mercury-Language/mercury/wiki/Tutorial)\n* [Getting Started with Mercury](https://bluishcoder.co.nz/2019/06/23/getting-started-with-mercury.html) - installation and your first steps\n  \n### Documentation\n\n* Language manual, user's guide, and library reference are all at\n  [mercurylang.org](https://mercurylang.org/documentation/documentation.html)"
