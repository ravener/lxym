
package pages

const Fsharp = "F# is a general purpose functional/OO programming language.  It's free and open source, and runs on Linux, Mac, Windows and more.\n\nIt has a powerful type system that traps many errors at compile time, but it uses type inference so that it reads more like a dynamic language.\n\nThe syntax of F# is different from C-style languages:\n\n* Curly braces are not used to delimit blocks of code. Instead, indentation is used (like Python).\n* Whitespace is used to separate parameters rather than commas.\n\nIf you want to try out the code below, you can go to [https://try.fsharp.org](https://try.fsharp.org) and paste it into an interactive REPL.\n\n```csharp\n\n// single line comments use a double slash\n(* multi line comments use (* . . . *) pair\n\n-end of multi line comment- *)\n\n// ================================================\n// Basic Syntax\n// ================================================\n\n// ------ \"Variables\" (but not really) ------\n// The \"let\" keyword defines an (immutable) value\nlet myInt = 5\nlet myFloat = 3.14\nlet myString = \"hello\"           // note that no types needed\n\n// ------ Lists ------\nlet twoToFive = [2; 3; 4; 5]     // Square brackets create a list with\n                                 // semicolon delimiters.\nlet oneToFive = 1 :: twoToFive   // :: creates list with new 1st element\n// The result is [1; 2; 3; 4; 5]\nlet zeroToFive = [0; 1] @ twoToFive   // @ concats two lists\n\n// IMPORTANT: commas are never used as delimiters, only semicolons!\n\n// ------ Functions ------\n// The \"let\" keyword also defines a named function.\nlet square x = x * x          // Note that no parens are used.\nsquare 3                      // Now run the function. Again, no parens.\n\nlet add x y = x + y           // don't use add (x,y)! It means something\n                              // completely different.\nadd 2 3                       // Now run the function.\n\n// to define a multiline function, just use indents. No semicolons needed.\nlet evens list =\n   let isEven x = x % 2 = 0   // Define \"isEven\" as a sub function. Note\n                              // that equality operator is single char \"=\".\n   List.filter isEven list    // List.filter is a library function\n                              // with two parameters: a boolean function\n                              // and a list to work on\n\nevens oneToFive               // Now run the function\n\n// You can use parens to clarify precedence. In this example,\n// do \"map\" first, with two args, then do \"sum\" on the result.\n// Without the parens, \"List.map\" would be passed as an arg to List.sum\nlet sumOfSquaresTo100 =\n   List.sum ( List.map square [1..100] )\n\n// You can pipe the output of one operation to the next using \"|>\"\n// Piping data around is very common in F#, similar to UNIX pipes.\n\n// Here is the same sumOfSquares function written using pipes\nlet sumOfSquaresTo100piped =\n   [1..100] |> List.map square |> List.sum  // \"square\" was defined earlier\n\n// you can define lambdas (anonymous functions) using the \"fun\" keyword\nlet sumOfSquaresTo100withFun =\n   [1..100] |> List.map (fun x -> x * x) |> List.sum\n\n// In F# there is no \"return\" keyword. A function always\n// returns the value of the last expression used.\n\n// ------ Pattern Matching ------\n// Match..with.. is a supercharged case/switch statement.\nlet simplePatternMatch =\n   let x = \"a\"\n   match x with\n    | \"a\" -> printfn \"x is a\"\n    | \"b\" -> printfn \"x is b\"\n    | _ -> printfn \"x is something else\"   // underscore matches anything\n\n// F# doesn't allow nulls by default -- you must use an Option type\n// and then pattern match.\n// Some(..) and None are roughly analogous to Nullable wrappers\nlet validValue = Some(99)\nlet invalidValue = None\n\n// In this example, match..with matches the \"Some\" and the \"None\",\n// and also unpacks the value in the \"Some\" at the same time.\nlet optionPatternMatch input =\n   match input with\n    | Some i -> printfn \"input is an int=%d\" i\n    | None -> printfn \"input is missing\"\n\noptionPatternMatch validValue\noptionPatternMatch invalidValue\n\n// ------ Printing ------\n// The printf/printfn functions are similar to the\n// Console.Write/WriteLine functions in C#.\nprintfn \"Printing an int %i, a float %f, a bool %b\" 1 2.0 true\nprintfn \"A string %s, and something generic %A\" \"hello\" [1; 2; 3; 4]\n\n// There are also sprintf/sprintfn functions for formatting data\n// into a string, similar to String.Format in C#.\n\n// ================================================\n// More on functions\n// ================================================\n\n// F# is a true functional language -- functions are first\n// class entities and can be combined easily to make powerful\n// constructs\n\n// Modules are used to group functions together\n// Indentation is needed for each nested module.\nmodule FunctionExamples =\n\n    // define a simple adding function\n    let add x y = x + y\n\n    // basic usage of a function\n    let a = add 1 2\n    printfn \"1 + 2 = %i\" a\n\n    // partial application to \"bake in\" parameters\n    let add42 = add 42\n    let b = add42 1\n    printfn \"42 + 1 = %i\" b\n\n    // composition to combine functions\n    let add1 = add 1\n    let add2 = add 2\n    let add3 = add1 >> add2\n    let c = add3 7\n    printfn \"3 + 7 = %i\" c\n\n    // higher order functions\n    [1..10] |> List.map add3 |> printfn \"new list is %A\"\n\n    // lists of functions, and more\n    let add6 = [add1; add2; add3] |> List.reduce (>>)\n    let d = add6 7\n    printfn \"1 + 2 + 3 + 7 = %i\" d\n\n// ================================================\n// Lists and collection\n// ================================================\n\n// There are three types of ordered collection:\n// * Lists are most basic immutable collection.\n// * Arrays are mutable and more efficient when needed.\n// * Sequences are lazy and infinite (e.g. an enumerator).\n//\n// Other collections include immutable maps and sets\n// plus all the standard .NET collections\n\nmodule ListExamples =\n\n    // lists use square brackets\n    let list1 = [\"a\"; \"b\"]\n    let list2 = \"c\" :: list1    // :: is prepending\n    let list3 = list1 @ list2   // @ is concat\n\n    // list comprehensions (aka generators)\n    let squares = [for i in 1..10 do yield i * i]\n\n    // A prime number generator\n    // - this is using a short notation for the pattern matching syntax\n    // - (p::xs) is 'first :: tail' of the list, could also be written as p :: xs\n    //   this means this matches 'p' (the first item in the list), and xs is the rest of the list\n    //   this is called the 'cons pattern'\n    // - uses 'rec' keyword, which is necessary when using recursion\n    let rec sieve = function\n        | (p::xs) -> p :: sieve [ for x in xs do if x % p > 0 then yield x ]\n        | []      -> []\n    let primes = sieve [2..50]\n    printfn \"%A\" primes\n\n    // pattern matching for lists\n    let listMatcher aList =\n        match aList with\n        | [] -> printfn \"the list is empty\"\n        | [first] -> printfn \"the list has one element %A \" first\n        | [first; second] -> printfn \"list is %A and %A\" first second\n        | first :: _ -> printfn \"the list has more than two elements, first element %A\" first\n\n    listMatcher [1; 2; 3; 4]\n    listMatcher [1; 2]\n    listMatcher [1]\n    listMatcher []\n\n    // recursion using lists\n    let rec sum aList =\n        match aList with\n        | [] -> 0\n        | x::xs -> x + sum xs\n    sum [1..10]\n\n    // -----------------------------------------\n    // Standard library functions\n    // -----------------------------------------\n\n    // map\n    let add3 x = x + 3\n    [1..10] |> List.map add3\n\n    // filter\n    let even x = x % 2 = 0\n    [1..10] |> List.filter even\n\n    // many more -- see documentation\n\nmodule ArrayExamples =\n\n    // arrays use square brackets with bar\n    let array1 = [| \"a\"; \"b\" |]\n    let first = array1.[0]        // indexed access using dot\n\n    // pattern matching for arrays is same as for lists\n    let arrayMatcher aList =\n        match aList with\n        | [| |] -> printfn \"the array is empty\"\n        | [| first |] -> printfn \"the array has one element %A \" first\n        | [| first; second |] -> printfn \"array is %A and %A\" first second\n        | _ -> printfn \"the array has more than two elements\"\n\n    arrayMatcher [| 1; 2; 3; 4 |]\n\n    // Standard library functions just as for List\n\n    [| 1..10 |]\n    |> Array.map (fun i -> i + 3)\n    |> Array.filter (fun i -> i % 2 = 0)\n    |> Array.iter (printfn \"value is %i. \")\n\n\nmodule SequenceExamples =\n\n    // sequences use curly braces\n    let seq1 = seq { yield \"a\"; yield \"b\" }\n\n    // sequences can use yield and\n    // can contain subsequences\n    let strange = seq {\n        // \"yield\" adds one element\n        yield 1; yield 2;\n\n        // \"yield!\" adds a whole subsequence\n        yield! [5..10]\n        yield! seq {\n            for i in 1..10 do\n              if i % 2 = 0 then yield i }}\n    // test\n    strange |> Seq.toList\n\n\n    // Sequences can be created using \"unfold\"\n    // Here's the fibonacci series\n    let fib = Seq.unfold (fun (fst,snd) ->\n        Some(fst + snd, (snd, fst + snd))) (0,1)\n\n    // test\n    let fib10 = fib |> Seq.take 10 |> Seq.toList\n    printf \"first 10 fibs are %A\" fib10\n\n\n// ================================================\n// Data Types\n// ================================================\n\nmodule DataTypeExamples =\n\n    // All data is immutable by default\n\n    // Tuples are quick 'n easy anonymous types\n    // -- Use a comma to create a tuple\n    let twoTuple = 1, 2\n    let threeTuple = \"a\", 2, true\n\n    // Pattern match to unpack\n    let x, y = twoTuple  // sets x = 1, y = 2\n\n    // ------------------------------------\n    // Record types have named fields\n    // ------------------------------------\n\n    // Use \"type\" with curly braces to define a record type\n    type Person = {First:string; Last:string}\n\n    // Use \"let\" with curly braces to create a record\n    let person1 = {First=\"John\"; Last=\"Doe\"}\n\n    // Pattern match to unpack\n    let {First = first} = person1    // sets first=\"John\"\n\n    // ------------------------------------\n    // Union types (aka variants) have a set of choices\n    // Only one case can be valid at a time.\n    // ------------------------------------\n\n    // Use \"type\" with bar/pipe to define a union type\n    type Temp =\n        | DegreesC of float\n        | DegreesF of float\n\n    // Use one of the cases to create one\n    let temp1 = DegreesF 98.6\n    let temp2 = DegreesC 37.0\n\n    // Pattern match on all cases to unpack\n    let printTemp = function\n       | DegreesC t -> printfn \"%f degC\" t\n       | DegreesF t -> printfn \"%f degF\" t\n\n    printTemp temp1\n    printTemp temp2\n\n    // ------------------------------------\n    // Recursive types\n    // ------------------------------------\n\n    // Types can be combined recursively in complex ways\n    // without having to create subclasses\n    type Employee =\n      | Worker of Person\n      | Manager of Employee list\n\n    let jdoe = {First=\"John\"; Last=\"Doe\"}\n    let worker = Worker jdoe\n\n    // ------------------------------------\n    // Modeling with types\n    // ------------------------------------\n\n    // Union types are great for modeling state without using flags\n    type EmailAddress =\n        | ValidEmailAddress of string\n        | InvalidEmailAddress of string\n\n    let trySendEmail email =\n        match email with // use pattern matching\n        | ValidEmailAddress address -> ()   // send\n        | InvalidEmailAddress address -> () // don't send\n\n    // The combination of union types and record types together\n    // provide a great foundation for domain driven design.\n    // You can create hundreds of little types that accurately\n    // reflect the domain.\n\n    type CartItem = { ProductCode: string; Qty: int }\n    type Payment = Payment of float\n    type ActiveCartData = { UnpaidItems: CartItem list }\n    type PaidCartData = { PaidItems: CartItem list; Payment: Payment}\n\n    type ShoppingCart =\n        | EmptyCart  // no data\n        | ActiveCart of ActiveCartData\n        | PaidCart of PaidCartData\n\n    // ------------------------------------\n    // Built in behavior for types\n    // ------------------------------------\n\n    // Core types have useful \"out-of-the-box\" behavior, no coding needed.\n    // * Immutability\n    // * Pretty printing when debugging\n    // * Equality and comparison\n    // * Serialization\n\n    // Pretty printing using %A\n    printfn \"twoTuple=%A,\\nPerson=%A,\\nTemp=%A,\\nEmployee=%A\"\n             twoTuple person1 temp1 worker\n\n    // Equality and comparison built in.\n    // Here's an example with cards.\n    type Suit = Club | Diamond | Spade | Heart\n    type Rank = Two | Three | Four | Five | Six | Seven | Eight\n                | Nine | Ten | Jack | Queen | King | Ace\n\n    let hand = [ Club, Ace; Heart, Three; Heart, Ace;\n                 Spade, Jack; Diamond, Two; Diamond, Ace ]\n\n    // sorting\n    List.sort hand |> printfn \"sorted hand is (low to high) %A\"\n    List.max hand |> printfn \"high card is %A\"\n    List.min hand |> printfn \"low card is %A\"\n\n\n// ================================================\n// Active patterns\n// ================================================\n\nmodule ActivePatternExamples =\n\n    // F# has a special type of pattern matching called \"active patterns\"\n    // where the pattern can be parsed or detected dynamically.\n\n    // \"banana clips\" are the syntax for active patterns\n\n    // You can use \"elif\" instead of \"else if\" in conditional expressions.\n    // They are equivalent in F#\n\n    // for example, define an \"active\" pattern to match character types...\n    let (|Digit|Letter|Whitespace|Other|) ch =\n       if System.Char.IsDigit(ch) then Digit\n       elif System.Char.IsLetter(ch) then Letter\n       elif System.Char.IsWhiteSpace(ch) then Whitespace\n       else Other\n\n    // ... and then use it to make parsing logic much clearer\n    let printChar ch =\n      match ch with\n      | Digit -> printfn \"%c is a Digit\" ch\n      | Letter -> printfn \"%c is a Letter\" ch\n      | Whitespace -> printfn \"%c is a Whitespace\" ch\n      | _ -> printfn \"%c is something else\" ch\n\n    // print a list\n    ['a'; 'b'; '1'; ' '; '-'; 'c'] |> List.iter printChar\n\n    // -----------------------------------\n    // FizzBuzz using active patterns\n    // -----------------------------------\n\n    // You can create partial matching patterns as well\n    // Just use underscore in the definition, and return Some if matched.\n    let (|MultOf3|_|) i = if i % 3 = 0 then Some MultOf3 else None\n    let (|MultOf5|_|) i = if i % 5 = 0 then Some MultOf5 else None\n\n    // the main function\n    let fizzBuzz i =\n      match i with\n      | MultOf3 & MultOf5 -> printf \"FizzBuzz, \"\n      | MultOf3 -> printf \"Fizz, \"\n      | MultOf5 -> printf \"Buzz, \"\n      | _ -> printf \"%i, \" i\n\n    // test\n    [1..20] |> List.iter fizzBuzz\n\n// ================================================\n// Conciseness\n// ================================================\n\nmodule AlgorithmExamples =\n\n    // F# has a high signal/noise ratio, so code reads\n    // almost like the actual algorithm\n\n    // ------ Example: define sumOfSquares function ------\n    let sumOfSquares n =\n       [1..n]              // 1) take all the numbers from 1 to n\n       |> List.map square  // 2) square each one\n       |> List.sum         // 3) sum the results\n\n    // test\n    sumOfSquares 100 |> printfn \"Sum of squares = %A\"\n\n    // ------ Example: define a sort function ------\n    let rec sort list =\n       match list with\n       // If the list is empty\n       | [] ->\n            []                            // return an empty list\n       // If the list is not empty\n       | firstElem::otherElements ->      // take the first element\n            let smallerElements =         // extract the smaller elements\n                otherElements             // from the remaining ones\n                |> List.filter (fun e -> e < firstElem)\n                |> sort                   // and sort them\n            let largerElements =          // extract the larger ones\n                otherElements             // from the remaining ones\n                |> List.filter (fun e -> e >= firstElem)\n                |> sort                   // and sort them\n            // Combine the 3 parts into a new list and return it\n            List.concat [smallerElements; [firstElem]; largerElements]\n\n    // test\n    sort [1; 5; 23; 18; 9; 1; 3] |> printfn \"Sorted = %A\"\n\n// ================================================\n// Asynchronous Code\n// ================================================\n\nmodule AsyncExample =\n\n    // F# has built-in features to help with async code\n    // without encountering the \"pyramid of doom\"\n    //\n    // The following example downloads a set of web pages in parallel.\n\n    open System.Net\n    open System\n    open System.IO\n    open Microsoft.FSharp.Control.CommonExtensions\n\n    // Fetch the contents of a URL asynchronously\n    let fetchUrlAsync url =\n        async {   // \"async\" keyword and curly braces\n                  // creates an \"async\" object\n            let req = WebRequest.Create(Uri(url))\n            use! resp = req.AsyncGetResponse()\n                // use! is async assignment\n            use stream = resp.GetResponseStream()\n                // \"use\" triggers automatic close()\n                // on resource at end of scope\n            use reader = new IO.StreamReader(stream)\n            let html = reader.ReadToEnd()\n            printfn \"finished downloading %s\" url\n            }\n\n    // a list of sites to fetch\n    let sites = [\"http://www.bing.com\";\n                 \"http://www.google.com\";\n                 \"http://www.microsoft.com\";\n                 \"http://www.amazon.com\";\n                 \"http://www.yahoo.com\"]\n\n    // do it\n    sites\n    |> List.map fetchUrlAsync  // make a list of async tasks\n    |> Async.Parallel          // set up the tasks to run in parallel\n    |> Async.RunSynchronously  // start them off\n\n// ================================================\n// .NET compatibility\n// ================================================\n\nmodule NetCompatibilityExamples =\n\n    // F# can do almost everything C# can do, and it integrates\n    // seamlessly with .NET or Mono libraries.\n\n    // ------- work with existing library functions  -------\n\n    let (i1success, i1) = System.Int32.TryParse(\"123\");\n    if i1success then printfn \"parsed as %i\" i1 else printfn \"parse failed\"\n\n    // ------- Implement interfaces on the fly! -------\n\n    // create a new object that implements IDisposable\n    let makeResource name =\n       { new System.IDisposable\n         with member this.Dispose() = printfn \"%s disposed\" name }\n\n    let useAndDisposeResources =\n        use r1 = makeResource \"first resource\"\n        printfn \"using first resource\"\n        for i in [1..3] do\n            let resourceName = sprintf \"\\tinner resource %d\" i\n            use temp = makeResource resourceName\n            printfn \"\\tdo something with %s\" resourceName\n        use r2 = makeResource \"second resource\"\n        printfn \"using second resource\"\n        printfn \"done.\"\n\n    // ------- Object oriented code -------\n\n    // F# is also a fully fledged OO language.\n    // It supports classes, inheritance, virtual methods, etc.\n\n    // interface with generic type\n    type IEnumerator<'a> =\n        abstract member Current : 'a\n        abstract MoveNext : unit -> bool\n\n    // abstract base class with virtual methods\n    [<AbstractClass>]\n    type Shape() =\n        // readonly properties\n        abstract member Width : int with get\n        abstract member Height : int with get\n        // non-virtual method\n        member this.BoundingArea = this.Height * this.Width\n        // virtual method with base implementation\n        abstract member Print : unit -> unit\n        default this.Print () = printfn \"I'm a shape\"\n\n    // concrete class that inherits from base class and overrides\n    type Rectangle(x:int, y:int) =\n        inherit Shape()\n        override this.Width = x\n        override this.Height = y\n        override this.Print ()  = printfn \"I'm a Rectangle\"\n\n    // test\n    let r = Rectangle(2, 3)\n    printfn \"The width is %i\" r.Width\n    printfn \"The area is %i\" r.BoundingArea\n    r.Print()\n\n    // ------- extension methods  -------\n\n    // Just as in C#, F# can extend existing classes with extension methods.\n    type System.String with\n       member this.StartsWithA = this.StartsWith \"A\"\n\n    // test\n    let s = \"Alice\"\n    printfn \"'%s' starts with an 'A' = %A\" s s.StartsWithA\n\n    // ------- events  -------\n\n    type MyButton() =\n        let clickEvent = new Event<_>()\n\n        [<CLIEvent>]\n        member this.OnClick = clickEvent.Publish\n\n        member this.TestEvent(arg) =\n            clickEvent.Trigger(this, arg)\n\n    // test\n    let myButton = new MyButton()\n    myButton.OnClick.Add(fun (sender, arg) ->\n            printfn \"Click event with arg=%O\" arg)\n\n    myButton.TestEvent(\"Hello World!\")\n\n```\n\n## More Information\n\nFor more demonstrations of F#, go to my [why use F#](http://fsharpforfunandprofit.com/why-use-fsharp/) series.\n\nRead more about F# at [fsharp.org](http://fsharp.org/) and [dotnet's F# page](https://dotnet.microsoft.com/languages/fsharp)."
