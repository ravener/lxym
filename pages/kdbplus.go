
package pages

const KdbPlus = "The q language and its database component kdb+ were developed by Arthur Whitney\nand released by Kx systems in 2003. q is a descendant of APL and as such is\nvery terse and a little strange looking for anyone from a \"C heritage\" language\nbackground. Its expressiveness and vector oriented nature make it well suited\nto performing complex calculations on large amounts of data (while also\nencouraging some amount of [code\ngolf](https://en.wikipedia.org/wiki/Code_golf)). The fundamental structure in\nthe language is not the object but instead the list, and tables are built as\ncollections of lists. This means - unlike most traditional RDBMS systems -\ntables are column oriented.  The language has both an in-memory and on-disk\ndatabase built in, giving a large amount of flexibility. kdb+ is most widely\nused in the world of finance to store, analyze, process and retrieve large\ntime-series data sets.\n\nThe terms *q* and *kdb+* are usually used interchangeably, as the two are not\nseparable so this distinction is not really useful.\n\nAll Feedback welcome!  You can reach me at matt.doherty@aquaq.co.uk, or Jonny\nat jonny.press@aquaq.co.uk\n\nTo learn more about kdb+ you can join the [Personal kdb+](https://groups.google.com/forum/#!forum/personal-kdbplus) or [TorQ kdb+](https://groups.google.com/forum/#!forum/kdbtorq) group.\n\n```\n/ Single line comments start with a forward-slash\n/ These can also be used in-line, so long as at least one whitespace character\n/ separates it from text to the left\n/\n  A forward-slash on a line by itself starts a multiline comment\n  and a backward-slash on a line by itself terminates it\n\\\n\n/ Run this file in an empty directory\n\n\n////////////////////////////////////\n// Basic Operators and Datatypes  //\n////////////////////////////////////\n\n/ We have integers, which are 8 byte by default\n3 / => 3\n\n/ And floats, also 8 byte as standard.  Trailing f distinguishes from int\n3.0 / => 3f\n\n/ 4 byte numerical types can also be specified with trailing chars\n3i / => 3i\n3.0e / => 3e\n\n/ Math is mostly what you would expect\n1+1 / => 2\n8-1 / => 7\n10*2 / => 20\n/ Except division, which uses percent (%) instead of forward-slash (/)\n35%5 / => 7f  (the result of division is always a float)\n\n/ For integer division we have the keyword div\n4 div 3 / => 1\n\n/ Modulo also uses a keyword, since percent (%) is taken\n4 mod 3 / => 1\n\n/ And exponentiation...\n2 xexp 4 / => 16\n\n/ ...and truncating...\nfloor 3.14159 / => 3\n\n/ ...getting the absolute value...\nabs -3.14159 / => 3.14159\n/ ...and many other things\n/ see http://code.kx.com/q/ref/card/ for more\n\n/ q has no operator precedence, everything is evaluated right to left\n/ so results like this might take some getting used to\n2*1+1 / => 4 / (no operator precedence tables to remember!)\n\n/ Precedence can be modified with parentheses (restoring the 'normal' result)\n(2*1)+1 / => 3\n\n/ Assignment uses colon (:) instead of equals (=)\n/ No need to declare variables before assignment\na:3\na / => 3\n\n/ Variables can also be assigned in-line\n/ this does not affect the value passed on\nc:3+b:2+a:1 / (data \"flows\" from right to left)\na / => 1\nb / => 3\nc / => 6\n\n/ In-place operations are also as you might expect\na+:2\na / => 3\n\n/ There are no \"true\" or \"false\" keywords in q\n/ boolean values are indicated by the bit value followed by b\n1b / => true value\n0b / => false value\n\n/ Equality comparisons use equals (=) (since we don't need it for assignment)\n1=1 / => 1b\n2=1 / => 0b\n\n/ Inequality uses <>\n1<>1 / => 0b\n2<>1 / => 1b\n\n/ The other comparisons are as you might expect\n1<2 / => 1b\n1>2 / => 0b\n2<=2 / => 1b\n2>=2 / => 1b\n\n/ Comparison is not strict with regard to types...\n42=42.0 / => 1b\n\n/ ...unless we use the match operator (~)\n/ which only returns true if entities are identical\n42~42.0 / => 0b\n\n/ The not operator returns true if the underlying value is zero\nnot 0b / => 1b\nnot 1b / => 0b\nnot 42 / => 0b\nnot 0.0 / => 1b\n\n/ The max operator (|) reduces to logical \"or\" for bools\n42|2.0 / => 42f\n1b|0b / => 1b\n\n/ The min operator (&) reduces to logical \"and\" for bools\n42&2.0 / => 2f\n1b&0b / => 0b\n\n/ q provides two ways to store character data\n/ Chars in q are stored in a single byte and use double-quotes (\")\nch:\"a\"\n/ Strings are simply lists of char (more on lists later)\nstr:\"This is a string\"\n/ Escape characters work as normal\nstr:\"This is a string with \\\"quotes\\\"\"\n\n/ Char data can also be stored as symbols using backtick (`)\nsymbol:`sym\n/ Symbols are NOT LISTS, they are an enumeration\n/ the q process stores internally a vector of strings\n/ symbols are enumerated against this vector\n/ this can be more space and speed efficient as these are constant width\n\n/ The string function converts to strings\nstring `symbol / => \"symbol\"\nstring 1.2345 / => \"1.2345\"\n\n/ q has a time type...\nt:01:00:00.000\n/ date type...\nd:2015.12.25\n/ and a datetime type (among other time types)\ndt:2015.12.25D12:00:00.000000000\n\n/ These support some arithmetic for easy manipulation\ndt + t / => 2015.12.25D13:00:00.000000000\nt - 00:10:00.000 / => 00:50:00.000\n/ and can be decomposed using dot notation\nd.year / => 2015i\nd.mm / => 12i\nd.dd / => 25i\n/ see http://code.kx.com/q4m3/2_Basic_Data_Types_Atoms/#25-temporal-data for more\n\n/ q also has an infinity value so div by zero will not throw an error\n1%0 / => 0w\n-1%0 / => -0w\n\n/ And null types for representing missing values\n0N / => null int\n0n / => null float\n/ see http://code.kx.com/q4m3/2_Basic_Data_Types_Atoms/#27-nulls for more\n\n/ q has standard control structures\n/ if is as you might expect (; separates the condition and instructions)\nif[1=1;a:\"hi\"]\na / => \"hi\"\n/ if-else uses $ (and unlike if, returns a value)\n$[1=0;a:\"hi\";a:\"bye\"] / => \"bye\"\na / => \"bye\"\n/ if-else can be extended to multiple clauses by adding args separated by ;\n$[1=0;a:\"hi\";0=1;a:\"bye\";a:\"hello again\"]\na / => \"hello again\"\n\n\n////////////////////////////////////\n////      Data Structures       ////\n////////////////////////////////////\n\n/ q is not an object oriented language\n/ instead complexity is built through ordered lists\n/ and mapping them into higher order structures: dictionaries and tables\n\n/ Lists (or arrays if you prefer) are simple ordered collections\n/ they are defined using parentheses () and semi-colons (;)\n(1;2;3) / => 1 2 3\n(-10.0;3.14159e;1b;`abc;\"c\")\n/ => -10f\n/ => 3.14159e\n/ => 1b\n/ => `abc\n/ => \"c\"  (mixed type lists are displayed on multiple lines)\n((1;2;3);(4;5;6);(7;8;9))\n/ => 1 2 3\n/ => 4 5 6\n/ => 7 8 9\n\n/ Lists of uniform type can also be defined more concisely\n1 2 3 / => 1 2 3\n`list`of`syms / => `list`of`syms\n`list`of`syms ~ (`list;`of;`syms) / => 1b\n\n/ List length\ncount (1;2;3) / => 3\ncount \"I am a string\" / => 13 (string are lists of char)\n\n/ Empty lists are defined with parentheses\nl:()\ncount l / => 0\n\n/ Simple variables and single item lists are not equivalent\n/ parentheses syntax cannot create a single item list (they indicate precedence)\n(1)~1 / => 1b\n/ single item lists can be created using enlist\nsingleton:enlist 1\n/ or appending to an empty list\nsingleton:(),1\n1~(),1 / => 0b\n\n/ Speaking of appending, comma (,) is used for this, not plus (+)\n1 2 3,4 5 6 / => 1 2 3 4 5 6\n\"hello \",\"there\" / => \"hello there\"\n\n/ Indexing uses square brackets []\nl:1 2 3 4\nl[0] / => 1\nl[1] / => 2\n/ indexing out of bounds returns a null value rather than an error\nl[5] / => 0N\n/ and indexed assignment\nl[0]:5\nl / => 5 2 3 4\n\n/ Lists can also be used for indexing and indexed assignment\nl[1 3] / => 2 4\nl[1 3]: 1 3\nl / => 5 1 3 3\n\n/ Lists can be untyped/mixed type\nl:(1;2;`hi)\n/ but once they are uniformly typed, q will enforce this\nl[2]:3\nl / => 1 2 3\nl[2]:`hi / throws a type error\n/ this makes sense in the context of lists as table columns (more later)\n\n/ For a nested list we can index at depth\nl:((1;2;3);(4;5;6);(7;8;9))\nl[1;1] / => 5\n\n/ We can elide the indexes to return entire rows or columns\nl[;1] / => 2 5 8\nl[1;] / => 4 5 6\n\n/ All the functions mentioned in the previous section work on lists natively\n1+(1;2;3) / => 2 3 4 (single variable and list)\n(1;2;3) - (3;2;1) / => -2 0 2 (list and list)\n\n/ And there are many more that are designed specifically for lists\navg 1 2 3 / => 2f\nsum 1 2 3 / => 6\nsums 1 2 3 / => 1 3 6 (running sum)\nlast 1 2 3 / => 3\n1 rotate 1 2 3 / => 2 3 1\n/ etc.\n/ Using and combining these functions to manipulate lists is where much of the\n/ power and expressiveness of the language comes from\n\n/ Take (#), drop (_) and find (?) are also useful working with lists\nl:1 2 3 4 5 6 7 8 9\nl:1+til 9 / til is a useful shortcut for generating ranges\n/ take the first 5 elements\n5#l / => 1 2 3 4 5\n/ drop the first 5\n5_l / => 6 7 8 9\n/ take the last 5\n-5#l / => 5 6 7 8 9\n/ drop the last 5\n-5_l / => 1 2 3 4\n/ find the first occurrence of 4\nl?4 / => 3\nl[3] / => 4\n\n/ Dictionaries in q are a generalization of lists\n/ they map a list to another list (of equal length)\n/ the bang (!) symbol is used for defining a dictionary\nd:(`a;`b;`c)!(1;2;3)\n/ or more simply with concise list syntax\nd:`a`b`c!1 2 3\n/ the keyword key returns the first list\nkey d / => `a`b`c\n/ and value the second\nvalue d / => 1 2 3\n\n/ Indexing is identical to lists\n/ with the first list as a key instead of the position\nd[`a] / => 1\nd[`b] / => 2\n\n/ As is assignment\nd[`c]:4\nd\n/ => a| 1\n/ => b| 2\n/ => c| 4\n\n/ Arithmetic and comparison work natively, just like lists\ne:(`a;`b;`c)!(2;3;4)\nd+e\n/ => a| 3\n/ => b| 5\n/ => c| 8\nd-2\n/ => a| -1\n/ => b| 0\n/ => c| 2\nd > (1;1;1)\n/ => a| 0\n/ => b| 1\n/ => c| 1\n\n/ And the take, drop and find operators are remarkably similar too\n`a`b#d\n/ => a| 1\n/ => b| 2\n`a`b _ d\n/ => c| 4\nd?2\n/ => `b\n\n/ Tables in q are basically a subset of dictionaries\n/ a table is a dictionary where all values must be lists of the same length\n/ as such tables in q are column oriented (unlike most RDBMS)\n/ the flip keyword is used to convert a dictionary to a table\n/ i.e. flip the indices\nflip `c1`c2`c3!(1 2 3;4 5 6;7 8 9)\n/ => c1 c2 c3\n/ => --------\n/ => 1  4  7\n/ => 2  5  8\n/ => 3  6  9\n/ we can also define tables using this syntax\nt:([]c1:1 2 3;c2:4 5 6;c3:7 8 9)\nt\n/ => c1 c2 c3\n/ => --------\n/ => 1  4  7\n/ => 2  5  8\n/ => 3  6  9\n\n/ Tables can be indexed and manipulated in a similar way to dicts and lists\nt[`c1]\n/ => 1 2 3\n/ table rows are returned as dictionaries\nt[1]\n/ => c1| 2\n/ => c2| 5\n/ => c3| 8\n\n/ meta returns table type information\nmeta t\n/ => c | t f a\n/ => --| -----\n/ => c1| j\n/ => c2| j\n/ => c3| j\n/ now we see why type is enforced in lists (to protect column types)\nt[1;`c1]:3\nt[1;`c1]:3.0 / throws a type error\n\n/ Most traditional databases have primary key columns\n/ in q we have keyed tables, where one table containing key columns\n/ is mapped to another table using bang (!)\nk:([]id:1 2 3)\nk!t\n/ => id| c1 c2 c3\n/ => --| --------\n/ => 1 | 1  4  7\n/ => 2 | 3  5  8\n/ => 3 | 3  6  9\n\n/ We can also use this shortcut for defining keyed tables\nkt:([id:1 2 3]c1:1 2 3;c2:4 5 6;c3:7 8 9)\n\n/ Records can then be retrieved based on this key\nkt[1]\n/ => c1| 1\n/ => c2| 4\n/ => c3| 7\nkt[`id!1]\n/ => c1| 1\n/ => c2| 4\n/ => c3| 7\n\n\n////////////////////////////////////\n////////     Functions      ////////\n////////////////////////////////////\n\n/ In q the function is similar to a mathematical map, mapping inputs to outputs\n/ curly braces {} are used for function definition\n/ and square brackets [] for calling functions (just like list indexing)\n/ a very minimal function\nf:{x+x}\nf[2] / => 4\n\n/ Functions can be anonymous and called at point of definition\n{x+x}[2] / => 4\n\n/ By default the last expression is returned\n/ colon (:) can be used to specify return\n{x+x}[2] / => 4\n{:x+x}[2] / => 4\n/ semi-colon (;) separates expressions\n{r:x+x;:r}[2] / => 4\n\n/ Function arguments can be specified explicitly (separated by ;)\n{[arg1;arg2] arg1+arg2}[1;2] / => 3\n/ or if omitted will default to x, y and z\n{x+y+z}[1;2;3] / => 6\n\n/ Built in functions are no different, and can be called the same way (with [])\n+[1;2] / => 3\n<[1;2] / => 1b\n\n/ Functions are first class in q, so can be returned, stored in lists etc.\n{:{x+y}}[] / => {x+y}\n(1;\"hi\";{x+y})\n/ => 1\n/ => \"hi\"\n/ => {x+y}\n\n/ There is no overloading and no keyword arguments for custom q functions\n/ however using a dictionary as a single argument can overcome this\n/ allows for optional arguments or differing functionality\nd:`arg1`arg2`arg3!(1.0;2;\"my function argument\")\n{x[`arg1]+x[`arg2]}[d] / => 3f\n\n/ Functions in q see the global scope\na:1\n{:a}[] / => 1\n\n/ However local scope obscures this\na:1\n{a:2;:a}[] / => 2\na / => 1\n\n/ Functions cannot see nested scopes (only local and global)\n{local:1;{:local}[]}[] / throws error as local is not defined in inner function\n\n/ A function can have one or more of its arguments fixed (projection)\nf:+[4]\nf[4] / => 8\nf[5] / => 9\nf[6] / => 10\n\n\n////////////////////////////////////\n//////////     q-sql      //////////\n////////////////////////////////////\n\n/ q has its own syntax for manipulating tables, similar to standard SQL\n/ This contains the usual suspects of select, insert, update etc.\n/ and some new functionality not typically available\n/ q-sql has two significant differences (other than syntax) to normal SQL:\n/ - q tables have well defined record orders\n/ - tables are stored as a collection of columns\n/   (so vectorized column operations are fast)\n/ a full description of q-sql is a little beyond the scope of this intro\n/ so we will just cover enough of the basics to get you going\n\n/ First define ourselves a table\nt:([]name:`Arthur`Thomas`Polly;age:35 32 52;height:180 175 160;sex:`m`m`f)\n\n/ equivalent of SELECT * FROM t\nselect from t / (must be lower case, and the wildcard is not necessary)\n/ => name   age height sex\n/ => ---------------------\n/ => Arthur 35  180    m\n/ => Thomas 32  175    m\n/ => Polly  52  160    f\n\n/ Select specific columns\nselect name,age from t\n/ => name   age\n/ => ----------\n/ => Arthur 35\n/ => Thomas 32\n/ => Polly  52\n\n/ And name them (equivalent of using AS in standard SQL)\nselect charactername:name, currentage:age from t\n/ => charactername currentage\n/ => ------------------------\n/ => Arthur        35\n/ => Thomas        32\n/ => Polly         52\n\n/ This SQL syntax is integrated with the q language\n/ so q can be used seamlessly in SQL statements\nselect name, feet:floor height*0.032, inches:12*(height*0.032) mod 1 from t\n/ => name   feet inches\n/ => ------------------\n/ => Arthur 5    9.12\n/ => Thomas 5    7.2\n/ => Polly  5    1.44\n\n/ Including custom functions\nselect name, growth:{[h;a]h%a}[height;age] from t\n/ => name   growth\n/ => ---------------\n/ => Arthur 5.142857\n/ => Thomas 5.46875\n/ => Polly  3.076923\n\n/ The where clause can contain multiple statements separated by commas\nselect from t where age>33,height>175\n/ => name   age height sex\n/ => ---------------------\n/ => Arthur 35  180    m\n\n/ The where statements are executed sequentially (not the same as logical AND)\nselect from t where age<40,height=min height\n/ => name   age height sex\n/ => ---------------------\n/ => Thomas 32  175    m\nselect from t where (age<40)&(height=min height)\n/ => name age height sex\n/ => -------------------\n\n/ The by clause falls between select and from\n/ and is equivalent to SQL's GROUP BY\nselect avg height by sex from t\n/ => sex| height\n/ => ---| ------\n/ => f  | 160\n/ => m  | 177.5\n\n/ If no aggreation function is specified, last is assumed\nselect by sex from t\n/ => sex| name   age height\n/ => ---| -----------------\n/ => f  | Polly  52  160\n/ => m  | Thomas 32  175\n\n/ Update has the same basic form as select\nupdate sex:`male from t where sex=`m\n/ => name   age height sex\n/ => ----------------------\n/ => Arthur 35  180    male\n/ => Thomas 32  175    male\n/ => Polly  52  160    f\n\n/ As does delete\ndelete from t where sex=`m\n/ => name  age height sex\n/ => --------------------\n/ => Polly 52  160    f\n\n/ None of these sql operations are carried out in place\nt\n/ => name   age height sex\n/ => ---------------------\n/ => Arthur 35  180    m\n/ => Thomas 32  175    m\n/ => Polly  52  160    f\n\n/ Insert however is in place, it takes a table name, and new data\n`t insert (`John;25;178;`m) / => ,3\nt\n/ => name   age height sex\n/ => ---------------------\n/ => Arthur 35  180    m\n/ => Thomas 32  175    m\n/ => Polly  52  160    f\n/ => John   25  178    m\n\n/ Upsert is similar (but doesn't have to be in-place)\nt upsert (`Chester;58;179;`m)\n/ => name    age height sex\n/ => ----------------------\n/ => Arthur  35  180    m\n/ => Thomas  32  175    m\n/ => Polly   52  160    f\n/ => John    25  178    m\n/ => Chester 58  179    m\n\n/ it will also upsert dicts or tables\nt upsert `name`age`height`sex!(`Chester;58;179;`m)\nt upsert (`Chester;58;179;`m)\n/ => name    age height sex\n/ => ----------------------\n/ => Arthur  35  180    m\n/ => Thomas  32  175    m\n/ => Polly   52  160    f\n/ => John    25  178    m\n/ => Chester 58  179    m\n\n/ And if our table is keyed\nkt:`name xkey t\n/ upsert will replace records where required\nkt upsert ([]name:`Thomas`Chester;age:33 58;height:175 179;sex:`f`m)\n/ => name   | age height sex\n/ => -------| --------------\n/ => Arthur | 35  180    m\n/ => Thomas | 33  175    f\n/ => Polly  | 52  160    f\n/ => John   | 25  178    m\n/ => Chester| 58  179    m\n\n/ There is no ORDER BY clause in q-sql, instead use xasc/xdesc\n`name xasc t\n/ => name   age height sex\n/ => ---------------------\n/ => Arthur 35  180    m\n/ => John   25  178    m\n/ => Polly  52  160    f\n/ => Thomas 32  175    m\n\n/ Most of the standard SQL joins are present in q-sql, plus a few new friends\n/ see http://code.kx.com/q4m3/9_Queries_q-sql/#99-joins\n/ the two most important (commonly used) are lj and aj\n\n/ lj is basically the same as SQL LEFT JOIN\n/ where the join is carried out on the key columns of the left table\nle:([sex:`m`f]lifeexpectancy:78 85)\nt lj le\n/ => name   age height sex lifeexpectancy\n/ => ------------------------------------\n/ => Arthur 35  180    m   78\n/ => Thomas 32  175    m   78\n/ => Polly  52  160    f   85\n/ => John   25  178    m   78\n\n/ aj is an asof join.  This is not a standard SQL join, and can be very powerful\n/ The canonical example of this is joining financial trades and quotes tables\ntrades:([]time:10:01:01 10:01:03 10:01:04;sym:`msft`ibm`ge;qty:100 200 150)\nquotes:([]time:10:01:00 10:01:01 10:01:01 10:01:03;\n          sym:`ibm`msft`msft`ibm; px:100 99 101 98)\naj[`time`sym;trades;quotes]\n/ => time     sym  qty px\n/ => ---------------------\n/ => 10:01:01 msft 100 101\n/ => 10:01:03 ibm  200 98\n/ => 10:01:04 ge   150\n/ for each row in the trade table, the last (prevailing) quote (px) for that sym\n/ is joined on.\n/ see http://code.kx.com/q4m3/9_Queries_q-sql/#998-as-of-joins\n\n////////////////////////////////////\n/////     Extra/Advanced      //////\n////////////////////////////////////\n\n////// Adverbs //////\n/ You may have noticed the total lack of loops to this point\n/ This is not a mistake!\n/ q is a vector language so explicit loops (for, while etc.) are not encouraged\n/ where possible functionality should be vectorized (i.e. operations on lists)\n/ adverbs supplement this, modifying the behaviour of functions\n/ and providing loop type functionality when required\n/ (in q functions are sometimes referred to as verbs, hence adverbs)\n/ the \"each\" adverb modifies a function to treat a list as individual variables\nfirst each (1 2 3;4 5 6;7 8 9)\n/ => 1 4 7\n\n/ each-left (\\:) and each-right (/:) modify a two-argument function\n/ to treat one of the arguments and individual variables instead of a list\n1 2 3 +\\: 11 22 33\n/ => 12 23 34\n/ => 13 24 35\n/ => 14 25 36\n1 2 3 +/: 11 22 33\n/ => 12 13 14\n/ => 23 24 25\n/ => 34 35 36\n\n/ The true alternatives to loops in q are the adverbs scan (\\) and over (/)\n/ their behaviour differs based on the number of arguments the function they\n/ are modifying receives.  Here I'll summarise some of the most useful cases\n/ a single argument function modified by scan given 2 args behaves like \"do\"\n{x * 2}\\[5;1] / => 1 2 4 8 16 32 (i.e. multiply by 2, 5 times)\n{x * 2}/[5;1] / => 32 (using over only the final result is shown)\n\n/ If the first argument is a function, we have the equivalent of \"while\"\n{x * 2}\\[{x<100};1] / => 1 2 4 8 16 32 64 128 (iterates until returns 0b)\n{x * 2}/[{x<100};1] / => 128 (again returns only the final result)\n\n/ If the function takes two arguments, and we pass a list, we have \"for\"\n/ where the result of the previous execution is passed back into the next loop\n/ along with the next member of the list\n{x + y}\\[1 2 3 4 5] / => 1 3 6 10 15 (i.e. the running sum)\n{x + y}/[1 2 3 4 5] / => 15 (only the final result)\n\n/ There are other adverbs and uses, this is only intended as quick overview\n/ http://code.kx.com/q4m3/6_Functions/#67-adverbs\n\n////// Scripts //////\n/ q scripts can be loaded from a q session using the \"\\l\" command\n/ for example \"\\l learnkdb.q\" will load this script\n/ or from the command prompt passing the script as an argument\n/ for example \"q learnkdb.q\"\n\n////// On-disk data //////\n/ Tables can be persisted to disk in several formats\n/ the two most fundamental are serialized and splayed\nt:([]a:1 2 3;b:1 2 3f)\n`:serialized set t / saves the table as a single serialized file\n`:splayed/ set t / saves the table splayed into a directory\n\n/ the dir structure will now look something like:\n/ db/\n/ ├── serialized\n/ └── splayed\n/     ├── a\n/     └── b\n\n/ Loading this directory (as if it was as script, see above)\n/ loads these tables into the q session\n\\l .\n/ the serialized table will be loaded into memory\n/ however the splayed table will only be mapped, not loaded\n/ both tables can be queried using q-sql\nselect from serialized\n/ => a b\n/ => ---\n/ => 1 1\n/ => 2 2\n/ => 3 3\nselect from splayed / (the columns are read from disk on request)\n/ => a b\n/ => ---\n/ => 1 1\n/ => 2 2\n/ => 3 3\n/ see http://code.kx.com/q4m3/14_Introduction_to_Kdb+/ for more\n\n////// Frameworks //////\n/ kdb+ is typically used for data capture and analysis.\n/ This involves using an architecture with multiple processes\n/ working together.  kdb+ frameworks are available to streamline the setup\n/ and configuration of this architecture and add additional functionality\n/ such as disaster recovery, logging, access, load balancing etc.\n/ https://github.com/AquaQAnalytics/TorQ\n```\n\n## Want to know more?\n\n* [*q for mortals* q language tutorial](http://code.kx.com/q4m3/)\n* [*Introduction to Kdb+* on disk data tutorial](http://code.kx.com/q4m3/14_Introduction_to_Kdb+/)\n* [q language reference](https://code.kx.com/q/ref/)\n* [Online training courses](http://training.aquaq.co.uk/)\n* [TorQ production framework](https://github.com/AquaQAnalytics/TorQ)"
