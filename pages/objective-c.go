
package pages

const Objective_C = "Objective-C is the main programming language used by Apple for the OS X and iOS operating systems and their respective frameworks, Cocoa and Cocoa Touch.\nIt is a general-purpose, object-oriented programming language that adds Smalltalk-style messaging to the C programming language.\n\n```objective-c\n// Single-line comments start with //\n\n/*\nMulti-line comments look like this\n*/\n\n// XCode supports pragma mark directive that improve jump bar readability\n#pragma mark Navigation Functions // New tag on jump bar named 'Navigation Functions'\n#pragma mark - Navigation Functions // Same tag, now with a separator\n\n// Imports the Foundation headers with #import\n// Use <> to import global files (in general frameworks)\n// Use \"\" to import local files (from project)\n#import <Foundation/Foundation.h>\n#import \"MyClass.h\"\n\n// If you enable modules for iOS >= 7.0 or OS X >= 10.9 projects in\n// Xcode 5 you can import frameworks like that:\n@import Foundation;\n\n// Your program's entry point is a function called\n// main with an integer return type\nint main (int argc, const char * argv[])\n{\n    // Create an autorelease pool to manage the memory into the program\n    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\n    // If using automatic reference counting (ARC), use @autoreleasepool instead:\n    @autoreleasepool {\n\n    // Use NSLog to print lines to the console\n    NSLog(@\"Hello World!\"); // Print the string \"Hello World!\"\n\n    ///////////////////////////////////////\n    // Types & Variables\n    ///////////////////////////////////////\n\n    // Primitive declarations\n    int myPrimitive1  = 1;\n    long myPrimitive2 = 234554664565;\n\n    // Object declarations\n    // Put the * in front of the variable names for strongly-typed object declarations\n    MyClass *myObject1 = nil;  // Strong typing\n    id       myObject2 = nil;  // Weak typing\n    // %@ is an object\n    // 'description' is a convention to display the value of the Objects\n    NSLog(@\"%@ and %@\", myObject1, [myObject2 description]); // prints => \"(null) and (null)\"\n\n    // String\n    NSString *worldString = @\"World\";\n    NSLog(@\"Hello %@!\", worldString); // prints => \"Hello World!\"\n    // NSMutableString is a mutable version of the NSString object\n    NSMutableString *mutableString = [NSMutableString stringWithString:@\"Hello\"];\n    [mutableString appendString:@\" World!\"];\n    NSLog(@\"%@\", mutableString); // prints => \"Hello World!\"\n\n    // Character literals\n    NSNumber *theLetterZNumber = @'Z';\n    char theLetterZ            = [theLetterZNumber charValue]; // or 'Z'\n    NSLog(@\"%c\", theLetterZ);\n\n    // Integral literals\n    NSNumber *fortyTwoNumber = @42;\n    int fortyTwo             = [fortyTwoNumber intValue]; // or 42\n    NSLog(@\"%i\", fortyTwo);\n\n    NSNumber *fortyTwoUnsignedNumber = @42U;\n    unsigned int fortyTwoUnsigned    = [fortyTwoUnsignedNumber unsignedIntValue]; // or 42\n    NSLog(@\"%u\", fortyTwoUnsigned);\n\n    NSNumber *fortyTwoShortNumber = [NSNumber numberWithShort:42];\n    short fortyTwoShort           = [fortyTwoShortNumber shortValue]; // or 42\n    NSLog(@\"%hi\", fortyTwoShort);\n\n    NSNumber *fortyOneShortNumber   = [NSNumber numberWithShort:41];\n    unsigned short fortyOneUnsigned = [fortyOneShortNumber unsignedShortValue]; // or 41\n    NSLog(@\"%u\", fortyOneUnsigned);\n\n    NSNumber *fortyTwoLongNumber = @42L;\n    long fortyTwoLong            = [fortyTwoLongNumber longValue]; // or 42\n    NSLog(@\"%li\", fortyTwoLong);\n\n    NSNumber *fiftyThreeLongNumber   = @53L;\n    unsigned long fiftyThreeUnsigned = [fiftyThreeLongNumber unsignedLongValue]; // or 53\n    NSLog(@\"%lu\", fiftyThreeUnsigned);\n\n    // Floating point literals\n    NSNumber *piFloatNumber = @3.141592654F;\n    float piFloat           = [piFloatNumber floatValue]; // or 3.141592654f\n    NSLog(@\"%f\", piFloat); // prints => 3.141592654\n    NSLog(@\"%5.2f\", piFloat); // prints => \" 3.14\"\n\n    NSNumber *piDoubleNumber = @3.1415926535;\n    double piDouble          = [piDoubleNumber doubleValue]; // or 3.1415926535\n    NSLog(@\"%f\", piDouble);\n    NSLog(@\"%4.2f\", piDouble); // prints => \"3.14\"\n\n    // NSDecimalNumber is a fixed-point class that's more precise than float or double\n    NSDecimalNumber *oneDecNum = [NSDecimalNumber decimalNumberWithString:@\"10.99\"];\n    NSDecimalNumber *twoDecNum = [NSDecimalNumber decimalNumberWithString:@\"5.002\"];\n    // NSDecimalNumber isn't able to use standard +, -, *, / operators so it provides its own:\n    [oneDecNum decimalNumberByAdding:twoDecNum];\n    [oneDecNum decimalNumberBySubtracting:twoDecNum];\n    [oneDecNum decimalNumberByMultiplyingBy:twoDecNum];\n    [oneDecNum decimalNumberByDividingBy:twoDecNum];\n    NSLog(@\"%@\", oneDecNum); // prints => 10.99 as NSDecimalNumber is immutable\n\n    // BOOL literals\n    NSNumber *yesNumber = @YES;\n    NSNumber *noNumber  = @NO;\n    // or\n    BOOL yesBool = YES;\n    BOOL noBool  = NO;\n    NSLog(@\"%i\", yesBool); // prints => 1\n\n    // Array object\n    // May contain different data types, but must be an Objective-C object\n    NSArray *anArray      = @[@1, @2, @3, @4];\n    NSNumber *thirdNumber = anArray[2];\n    NSLog(@\"Third number = %@\", thirdNumber); // prints => \"Third number = 3\"\n    // Since Xcode 7, NSArray objects can be typed (Generics)\n    NSArray<NSString *> *stringArray = @[@\"hello\", @\"world\"];\n    // NSMutableArray is a mutable version of NSArray, allowing you to change\n    // the items in the array and to extend or shrink the array object.\n    // Convenient, but not as efficient as NSArray.\n    NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:2];\n    [mutableArray addObject:@\"Hello\"];\n    [mutableArray addObject:@\"World\"];\n    [mutableArray removeObjectAtIndex:0];\n    NSLog(@\"%@\", [mutableArray objectAtIndex:0]); // prints => \"World\"\n\n    // Dictionary object\n    NSDictionary *aDictionary = @{ @\"key1\" : @\"value1\", @\"key2\" : @\"value2\" };\n    NSObject *valueObject     = aDictionary[@\"A Key\"];\n    NSLog(@\"Object = %@\", valueObject); // prints => \"Object = (null)\"\n    // Since Xcode 7, NSDictionary objects can be typed (Generics)\n    NSDictionary<NSString *, NSNumber *> *numberDictionary = @{@\"a\": @1, @\"b\": @2};\n    // NSMutableDictionary also available as a mutable dictionary object\n    NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithCapacity:2];\n    [mutableDictionary setObject:@\"value1\" forKey:@\"key1\"];\n    [mutableDictionary setObject:@\"value2\" forKey:@\"key2\"];\n    [mutableDictionary removeObjectForKey:@\"key1\"];\n\n    // Change types from Mutable To Immutable\n    //In general [object mutableCopy] will make the object mutable whereas [object copy] will make the object immutable\n    NSMutableDictionary *aMutableDictionary = [aDictionary mutableCopy];\n    NSDictionary *mutableDictionaryChanged = [mutableDictionary copy];\n\n\n    // Set object\n    NSSet *set = [NSSet setWithObjects:@\"Hello\", @\"Hello\", @\"World\", nil];\n    NSLog(@\"%@\", set); // prints => {(Hello, World)} (may be in different order)\n    // Since Xcode 7, NSSet objects can be typed (Generics)\n    NSSet<NSString *> *stringSet = [NSSet setWithObjects:@\"hello\", @\"world\", nil];\n    // NSMutableSet also available as a mutable set object\n    NSMutableSet *mutableSet = [NSMutableSet setWithCapacity:2];\n    [mutableSet addObject:@\"Hello\"];\n    [mutableSet addObject:@\"Hello\"];\n    NSLog(@\"%@\", mutableSet); // prints => {(Hello)}\n\n    ///////////////////////////////////////\n    // Operators\n    ///////////////////////////////////////\n\n    // The operators works like in the C language\n    // For example:\n    2 + 5; // => 7\n    4.2f + 5.1f; // => 9.3f\n    3 == 2; // => 0 (NO)\n    3 != 2; // => 1 (YES)\n    1 && 1; // => 1 (Logical and)\n    0 || 1; // => 1 (Logical or)\n    ~0x0F; // => 0xF0 (bitwise negation)\n    0x0F & 0xF0; // => 0x00 (bitwise AND)\n    0x01 << 1; // => 0x02 (bitwise left shift (by 1))\n\n    ///////////////////////////////////////\n    // Control Structures\n    ///////////////////////////////////////\n\n    // If-Else statement\n    if (NO)\n    {\n        NSLog(@\"I am never run\");\n    } else if (0)\n    {\n        NSLog(@\"I am also never run\");\n    } else\n    {\n        NSLog(@\"I print\");\n    }\n\n    // Switch statement\n    switch (2)\n    {\n        case 0:\n        {\n            NSLog(@\"I am never run\");\n        } break;\n        case 1:\n        {\n            NSLog(@\"I am also never run\");\n        } break;\n        default:\n        {\n            NSLog(@\"I print\");\n        } break;\n    }\n\n    // While loops statements\n    int ii = 0;\n    while (ii < 4)\n    {\n        NSLog(@\"%d,\", ii++); // ii++ increments ii in-place, after using its value\n    } // prints => \"0,\"\n      //           \"1,\"\n      //           \"2,\"\n      //           \"3,\"\n\n    // For loops statements\n    int jj;\n    for (jj=0; jj < 4; jj++)\n    {\n        NSLog(@\"%d,\", jj);\n    } // prints => \"0,\"\n      //           \"1,\"\n      //           \"2,\"\n      //           \"3,\"\n\n    // Foreach statements\n    NSArray *values = @[@0, @1, @2, @3];\n    for (NSNumber *value in values)\n    {\n        NSLog(@\"%@,\", value);\n    } // prints => \"0,\"\n      //           \"1,\"\n      //           \"2,\"\n      //           \"3,\"\n\n    // Object for loop statement. Can be used with any Objective-C object type\n    for (id item in values) {\n        NSLog(@\"%@,\", item);\n    } // prints => \"0,\"\n      //           \"1,\"\n      //           \"2,\"\n      //           \"3,\"\n\n    // Try-Catch-Finally statements\n    @try\n    {\n        // Your statements here\n        @throw [NSException exceptionWithName:@\"FileNotFoundException\"\n                            reason:@\"File Not Found on System\" userInfo:nil];\n    } @catch (NSException * e) // use: @catch (id exceptionName) to catch all objects.\n    {\n        NSLog(@\"Exception: %@\", e);\n    } @finally\n    {\n        NSLog(@\"Finally. Time to clean up.\");\n    } // prints => \"Exception: File Not Found on System\"\n      //           \"Finally. Time to clean up.\"\n\n    // NSError objects are useful for function arguments to populate on user mistakes.\n    NSError *error = [NSError errorWithDomain:@\"Invalid email.\" code:4 userInfo:nil];\n\n    ///////////////////////////////////////\n    // Objects\n    ///////////////////////////////////////\n\n    // Create an object instance by allocating memory and initializing it\n    // An object is not fully functional until both steps have been completed\n    MyClass *myObject = [[MyClass alloc] init];\n\n    // The Objective-C model of object-oriented programming is based on message\n    // passing to object instances\n    // In Objective-C one does not simply call a method; one sends a message\n    [myObject instanceMethodWithParameter:@\"Steve Jobs\"];\n\n    // Clean up the memory you used into your program\n    [pool drain];\n\n    // End of @autoreleasepool\n    }\n\n    // End the program\n    return 0;\n}\n\n///////////////////////////////////////\n// Classes And Functions\n///////////////////////////////////////\n\n// Declare your class in a header file (MyClass.h):\n// Class declaration syntax:\n// @interface ClassName : ParentClassName <ImplementedProtocols>\n// {\n//    type name; <= variable declarations;\n// }\n// @property type name; <= property declarations\n// -/+ (type) Method declarations; <= Method declarations\n// @end\n@interface MyClass : NSObject <MyProtocol> // NSObject is Objective-C's base object class.\n{\n    // Instance variable declarations (can exist in either interface or implementation file)\n    int count; // Protected access by default.\n    @private id data; // Private access (More convenient to declare in implementation file)\n    NSString *name;\n}\n// Convenient notation for public access variables to auto generate a setter method\n// By default, setter method name is 'set' followed by @property variable name\n@property int propInt; // Setter method name = 'setPropInt'\n@property (copy) id copyId; // (copy) => Copy the object during assignment\n// (readonly) => Cannot set value outside @interface\n@property (readonly) NSString *roString; // Use @synthesize in @implementation to create accessor\n// You can customize the getter and setter names instead of using default 'set' name:\n@property (getter=lengthGet, setter=lengthSet:) int length;\n\n// Methods\n+/- (return type)methodSignature:(Parameter Type *)parameterName;\n\n// + for class methods:\n+ (NSString *)classMethod;\n+ (MyClass *)myClassFromHeight:(NSNumber *)defaultHeight;\n\n// - for instance methods:\n- (NSString *)instanceMethodWithParameter:(NSString *)string;\n- (NSNumber *)methodAParameterAsString:(NSString*)string andAParameterAsNumber:(NSNumber *)number;\n\n// Constructor methods with arguments:\n- (id)initWithDistance:(int)defaultDistance;\n// Objective-C method names are very descriptive. Always name methods according to their arguments\n\n@end // States the end of the interface\n\n\n// To access public variables from the implementation file, @property generates a setter method\n// automatically. Method name is 'set' followed by @property variable name:\nMyClass *myClass = [[MyClass alloc] init]; // create MyClass object instance\n[myClass setCount:10];\nNSLog(@\"%d\", [myClass count]); // prints => 10\n// Or using the custom getter and setter method defined in @interface:\n[myClass lengthSet:32];\nNSLog(@\"%i\", [myClass lengthGet]); // prints => 32\n// For convenience, you may use dot notation to set and access object instance variables:\nmyClass.count = 45;\nNSLog(@\"%i\", myClass.count); // prints => 45\n\n// Call class methods:\nNSString *classMethodString = [MyClass classMethod];\nMyClass *classFromName = [MyClass myClassFromName:@\"Hello\"];\n\n// Call instance methods:\nMyClass *myClass = [[MyClass alloc] init]; // Create MyClass object instance\nNSString *stringFromInstanceMethod = [myClass instanceMethodWithParameter:@\"Hello\"];\n\n// Selectors\n// Way to dynamically represent methods. Used to call methods of a class, pass methods\n// through functions to tell other classes they should call it, and to save methods\n// as a variable\n// SEL is the data type. @selector() returns a selector from method name provided\n// methodAParameterAsString:andAParameterAsNumber: is method name for method in MyClass\nSEL selectorVar = @selector(methodAParameterAsString:andAParameterAsNumber:);\nif ([myClass respondsToSelector:selectorVar]) { // Checks if class contains method\n    // Must put all method arguments into one object to send to performSelector function\n    NSArray *arguments = [NSArray arrayWithObjects:@\"Hello\", @4, nil];\n    [myClass performSelector:selectorVar withObject:arguments]; // Calls the method\n} else {\n    // NSStringFromSelector() returns a NSString of the method name of a given selector\n    NSLog(@\"MyClass does not have method: %@\", NSStringFromSelector(selectedVar));\n}\n\n// Implement the methods in an implementation (MyClass.m) file:\n@implementation MyClass {\n    long distance; // Private access instance variable\n    NSNumber height;\n}\n\n// To access a public variable from the interface file, use '_' followed by variable name:\n_count = 5; // References \"int count\" from MyClass interface\n// Access variables defined in implementation file:\ndistance = 18; // References \"long distance\" from MyClass implementation\n// To use @property variable in implementation, use @synthesize to create accessor variable:\n@synthesize roString = _roString; // _roString available now in @implementation\n\n// Called before calling any class methods or instantiating any objects\n+ (void)initialize\n{\n    if (self == [MyClass class]) {\n        distance = 0;\n    }\n}\n\n// Counterpart to initialize method. Called when an object's reference count is zero\n- (void)dealloc\n{\n    [height release]; // If not using ARC, make sure to release class variable objects\n    [super dealloc];  // and call parent class dealloc\n}\n\n// Constructors are a way of creating instances of a class\n// This is a default constructor which is called when the object is initialized.\n- (id)init\n{\n    if ((self = [super init])) // 'super' used to access methods from parent class\n    {\n        self.count = 1; // 'self' used for object to call itself\n    }\n    return self;\n}\n// Can create constructors that contain arguments:\n- (id)initWithDistance:(int)defaultDistance\n{\n    distance = defaultDistance;\n    return self;\n}\n\n+ (NSString *)classMethod\n{\n    return @\"Some string\";\n}\n\n+ (MyClass *)myClassFromHeight:(NSNumber *)defaultHeight\n{\n    height = defaultHeight;\n    return [[self alloc] init];\n}\n\n- (NSString *)instanceMethodWithParameter:(NSString *)string\n{\n    return @\"New string\";\n}\n\n- (NSNumber *)methodAParameterAsString:(NSString*)string andAParameterAsNumber:(NSNumber *)number\n{\n    return @42;\n}\n\n// Objective-C does not have private method declarations, but you can simulate them.\n// To simulate a private method, create the method in the @implementation but not in the @interface.\n- (NSNumber *)secretPrivateMethod {\n    return @72;\n}\n[self secretPrivateMethod]; // Calls private method\n\n// Methods declared into MyProtocol\n- (void)myProtocolMethod\n{\n    // statements\n}\n\n@end // States the end of the implementation\n\n///////////////////////////////////////\n// Categories\n///////////////////////////////////////\n// A category is a group of methods designed to extend a class. They allow you to add new methods\n// to an existing class for organizational purposes. This is not to be mistaken with subclasses.\n// Subclasses are meant to CHANGE functionality of an object while categories instead ADD\n// functionality to an object.\n// Categories allow you to:\n// -- Add methods to an existing class for organizational purposes.\n// -- Allow you to extend Objective-C object classes (ex: NSString) to add your own methods.\n// -- Add ability to create protected and private methods to classes.\n// NOTE: Do not override methods of the base class in a category even though you have the ability\n// to. Overriding methods may cause compiler errors later between different categories and it\n// ruins the purpose of categories to only ADD functionality. Subclass instead to override methods.\n\n// Here is a simple Car base class.\n@interface Car : NSObject\n\n@property NSString *make;\n@property NSString *color;\n\n- (void)turnOn;\n- (void)accelerate;\n\n@end\n\n// And the simple Car base class implementation:\n#import \"Car.h\"\n\n@implementation Car\n\n@synthesize make = _make;\n@synthesize color = _color;\n\n- (void)turnOn {\n    NSLog(@\"Car is on.\");\n}\n- (void)accelerate {\n    NSLog(@\"Accelerating.\");\n}\n\n@end\n\n// Now, if we wanted to create a Truck object, we would instead create a subclass of Car as it would\n// be changing the functionality of the Car to behave like a truck. But lets say we want to just add\n// functionality to this existing Car. A good example would be to clean the car. So we would create\n// a category to add these cleaning methods:\n// @interface filename: Car+Clean.h (BaseClassName+CategoryName.h)\n#import \"Car.h\" // Make sure to import base class to extend.\n\n@interface Car (Clean) // The category name is inside () following the name of the base class.\n\n- (void)washWindows; // Names of the new methods we are adding to our Car object.\n- (void)wax;\n\n@end\n\n// @implementation filename: Car+Clean.m (BaseClassName+CategoryName.m)\n#import \"Car+Clean.h\" // Import the Clean category's @interface file.\n\n@implementation Car (Clean)\n\n- (void)washWindows {\n    NSLog(@\"Windows washed.\");\n}\n- (void)wax {\n    NSLog(@\"Waxed.\");\n}\n\n@end\n\n// Any Car object instance has the ability to use a category. All they need to do is import it:\n#import \"Car+Clean.h\" // Import as many different categories as you want to use.\n#import \"Car.h\" // Also need to import base class to use it's original functionality.\n\nint main (int argc, const char * argv[]) {\n    @autoreleasepool {\n        Car *mustang = [[Car alloc] init];\n        mustang.color = @\"Red\";\n        mustang.make = @\"Ford\";\n\n        [mustang turnOn]; // Use methods from base Car class.\n        [mustang washWindows]; // Use methods from Car's Clean category.\n    }\n    return 0;\n}\n\n// Objective-C does not have protected method declarations but you can simulate them.\n// Create a category containing all of the protected methods, then import it ONLY into the\n// @implementation file of a class belonging to the Car class:\n@interface Car (Protected) // Naming category 'Protected' to remember methods are protected.\n\n- (void)lockCar; // Methods listed here may only be created by Car objects.\n\n@end\n//To use protected methods, import the category, then implement the methods:\n#import \"Car+Protected.h\" // Remember, import in the @implementation file only.\n\n@implementation Car\n\n- (void)lockCar {\n    NSLog(@\"Car locked.\"); // Instances of Car can't use lockCar because it's not in the @interface.\n}\n\n@end\n\n///////////////////////////////////////\n// Extensions\n///////////////////////////////////////\n// Extensions allow you to override public access property attributes and methods of an @interface.\n// @interface filename: Shape.h\n@interface Shape : NSObject // Base Shape class extension overrides below.\n\n@property (readonly) NSNumber *numOfSides;\n\n- (int)getNumOfSides;\n\n@end\n// You can override numOfSides variable or getNumOfSides method to edit them with an extension:\n// @implementation filename: Shape.m\n#import \"Shape.h\"\n// Extensions live in the same file as the class @implementation.\n@interface Shape () // () after base class name declares an extension.\n\n@property (copy) NSNumber *numOfSides; // Make numOfSides copy instead of readonly.\n-(NSNumber)getNumOfSides; // Make getNumOfSides return a NSNumber instead of an int.\n-(void)privateMethod; // You can also create new private methods inside of extensions.\n\n@end\n// The main @implementation:\n@implementation Shape\n\n@synthesize numOfSides = _numOfSides;\n\n-(NSNumber)getNumOfSides { // All statements inside of extension must be in the @implementation.\n    return _numOfSides;\n}\n-(void)privateMethod {\n    NSLog(@\"Private method created by extension. Shape instances cannot call me.\");\n}\n\n@end\n\n// Starting in Xcode 7.0, you can create Generic classes,\n// allowing you to provide greater type safety and clarity\n// without writing excessive boilerplate.\n@interface Result<__covariant A> : NSObject\n\n- (void)handleSuccess:(void(^)(A))success\n              failure:(void(^)(NSError *))failure;\n\n@property (nonatomic) A object;\n\n@end\n\n// we can now declare instances of this class like\nResult<NSNumber *> *result;\nResult<NSArray *> *result;\n\n// Each of these cases would be equivalent to rewriting Result's interface\n// and substituting the appropriate type for A\n@interface Result : NSObject\n- (void)handleSuccess:(void(^)(NSArray *))success\n              failure:(void(^)(NSError *))failure;\n@property (nonatomic) NSArray * object;\n@end\n\n@interface Result : NSObject\n- (void)handleSuccess:(void(^)(NSNumber *))success\n              failure:(void(^)(NSError *))failure;\n@property (nonatomic) NSNumber * object;\n@end\n\n// It should be obvious, however, that writing one\n//  Class to solve a problem is always preferable to writing two\n\n// Note that Clang will not accept generic types in @implementations,\n// so your @implemnation of Result would have to look like this:\n\n@implementation Result\n\n- (void)handleSuccess:(void (^)(id))success\n              failure:(void (^)(NSError *))failure {\n  // Do something\n}\n\n@end\n\n\n///////////////////////////////////////\n// Protocols\n///////////////////////////////////////\n// A protocol declares methods that can be implemented by any class.\n// Protocols are not classes themselves. They simply define an interface\n// that other objects are responsible for implementing.\n// @protocol filename: \"CarUtilities.h\"\n@protocol CarUtilities <NSObject> // <NSObject> => Name of another protocol this protocol includes.\n    @property BOOL engineOn; // Adopting class must @synthesize all defined @properties and\n    - (void)turnOnEngine; // all defined methods.\n@end\n// Below is an example class implementing the protocol.\n#import \"CarUtilities.h\" // Import the @protocol file.\n\n@interface Car : NSObject <CarUtilities> // Name of protocol goes inside <>\n    // You don't need the @property or method names here for CarUtilities. Only @implementation does.\n- (void)turnOnEngineWithUtilities:(id <CarUtilities>)car; // You can use protocols as data too.\n@end\n// The @implementation needs to implement the @properties and methods for the protocol.\n@implementation Car : NSObject <CarUtilities>\n\n@synthesize engineOn = _engineOn; // Create a @synthesize statement for the engineOn @property.\n\n- (void)turnOnEngine { // Implement turnOnEngine however you would like. Protocols do not define\n    _engineOn = YES; // how you implement a method, it just requires that you do implement it.\n}\n// You may use a protocol as data as you know what methods and variables it has implemented.\n- (void)turnOnEngineWithCarUtilities:(id <CarUtilities>)objectOfSomeKind {\n    [objectOfSomeKind engineOn]; // You have access to object variables\n    [objectOfSomeKind turnOnEngine]; // and the methods inside.\n    [objectOfSomeKind engineOn]; // May or may not be YES. Class implements it however it wants.\n}\n\n@end\n// Instances of Car now have access to the protocol.\nCar *carInstance = [[Car alloc] init];\n[carInstance setEngineOn:NO];\n[carInstance turnOnEngine];\nif ([carInstance engineOn]) {\n    NSLog(@\"Car engine is on.\"); // prints => \"Car engine is on.\"\n}\n// Make sure to check if an object of type 'id' implements a protocol before calling protocol methods:\nif ([myClass conformsToProtocol:@protocol(CarUtilities)]) {\n    NSLog(@\"This does not run as the MyClass class does not implement the CarUtilities protocol.\");\n} else if ([carInstance conformsToProtocol:@protocol(CarUtilities)]) {\n    NSLog(@\"This does run as the Car class implements the CarUtilities protocol.\");\n}\n// Categories may implement protocols as well: @interface Car (CarCategory) <CarUtilities>\n// You may implement many protocols: @interface Car : NSObject <CarUtilities, CarCleaning>\n// NOTE: If two or more protocols rely on each other, make sure to forward-declare them:\n#import \"Brother.h\"\n\n@protocol Brother; // Forward-declare statement. Without it, compiler will throw error.\n\n@protocol Sister <NSObject>\n\n- (void)beNiceToBrother:(id <Brother>)brother;\n\n@end\n\n// See the problem is that Sister relies on Brother, and Brother relies on Sister.\n#import \"Sister.h\"\n\n@protocol Sister; // These lines stop the recursion, resolving the issue.\n\n@protocol Brother <NSObject>\n\n- (void)beNiceToSister:(id <Sister>)sister;\n\n@end\n\n\n///////////////////////////////////////\n// Blocks\n///////////////////////////////////////\n// Blocks are statements of code, just like a function, that are able to be used as data.\n// Below is a simple block with an integer argument that returns the argument plus 4.\n^(int n) {\n    return n + 4;\n}\nint (^addUp)(int n); // Declare a variable to store a block.\nvoid (^noParameterBlockVar)(void); // Example variable declaration of block with no arguments.\n// Blocks have access to variables in the same scope. But the variables are readonly and the\n// value passed to the block is the value of the variable when the block is created.\nint outsideVar = 17; // If we edit outsideVar after declaring addUp, outsideVar is STILL 17.\n__block long mutableVar = 3; // __block makes variables writable to blocks, unlike outsideVar.\naddUp = ^(int n) { // Remove (int n) to have a block that doesn't take in any parameters.\n    NSLog(@\"You may have as many lines in a block as you would like.\");\n    NSSet *blockSet; // Also, you can declare local variables.\n    mutableVar = 32; // Assigning new value to __block variable.\n    return n + outsideVar; // Return statements are optional.\n}\nint addUp = addUp(10 + 16); // Calls block code with arguments.\n// Blocks are often used as arguments to functions to be called later, or for callbacks.\n@implementation BlockExample : NSObject\n\n - (void)runBlock:(void (^)(NSString))block {\n    NSLog(@\"Block argument returns nothing and takes in a NSString object.\");\n    block(@\"Argument given to block to execute.\"); // Calling block.\n }\n\n @end\n\n\n///////////////////////////////////////\n// Memory Management\n///////////////////////////////////////\n/*\nFor each object used in an application, memory must be allocated for that object. When the application\nis done using that object, memory must be deallocated to ensure application efficiency.\nObjective-C does not use garbage collection and instead uses reference counting. As long as\nthere is at least one reference to an object (also called \"owning\" an object), then the object\nwill be available to use (known as \"ownership\").\n\nWhen an instance owns an object, its reference counter is increments by one. When the\nobject is released, the reference counter decrements by one. When reference count is zero,\nthe object is removed from memory.\n\nWith all object interactions, follow the pattern of:\n(1) create the object, (2) use the object, (3) then free the object from memory.\n*/\n\nMyClass *classVar = [MyClass alloc]; // 'alloc' sets classVar's reference count to one. Returns pointer to object\n[classVar release]; // Decrements classVar's reference count\n// 'retain' claims ownership of existing object instance and increments reference count. Returns pointer to object\nMyClass *newVar = [classVar retain]; // If classVar is released, object is still in memory because newVar is owner\n[classVar autorelease]; // Removes ownership of object at end of @autoreleasepool block. Returns pointer to object\n\n// @property can use 'retain' and 'assign' as well for small convenient definitions\n@property (retain) MyClass *instance; // Release old value and retain a new one (strong reference)\n@property (assign) NSSet *set; // Pointer to new value without retaining/releasing old (weak reference)\n\n// Automatic Reference Counting (ARC)\n// Because memory management can be a pain, Xcode 4.2 and iOS 4 introduced Automatic Reference Counting (ARC).\n// ARC is a compiler feature that inserts retain, release, and autorelease automatically for you, so when using ARC,\n// you must not use retain, release, or autorelease\nMyClass *arcMyClass = [[MyClass alloc] init];\n// ... code using arcMyClass\n// Without ARC, you will need to call: [arcMyClass release] after you're done using arcMyClass. But with ARC,\n// there is no need. It will insert this release statement for you\n\n// As for the 'assign' and 'retain' @property attributes, with ARC you use 'weak' and 'strong'\n@property (weak) MyClass *weakVar; // 'weak' does not take ownership of object. If original instance's reference count\n// is set to zero, weakVar will automatically receive value of nil to avoid application crashing\n@property (strong) MyClass *strongVar; // 'strong' takes ownership of object. Ensures object will stay in memory to use\n\n// For regular variables (not @property declared variables), use the following:\n__strong NSString *strongString; // Default. Variable is retained in memory until it leaves it's scope\n__weak NSSet *weakSet; // Weak reference to existing object. When existing object is released, weakSet is set to nil\n__unsafe_unretained NSArray *unsafeArray; // Like __weak, but unsafeArray not set to nil when existing object is released\n\n```\n## Further Reading\n\n[Wikipedia Objective-C](http://en.wikipedia.org/wiki/Objective-C)\n\n[Programming with Objective-C. Apple PDF book](https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/ProgrammingWithObjectiveC.pdf)\n\n[Programming with Objective-C for iOS](https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectiveC.html)\n\n[Programming with Objective-C for Mac OSX](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html)\n\n[iOS For High School Students: Getting Started](http://www.raywenderlich.com/5600/ios-for-high-school-students-getting-started)"
