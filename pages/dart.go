
package pages

const Dart = "**Dart** is a single threaded, general purpose programming language.\nIt borrows a lot from other mainstream languages.\nIt supports Streams, Futures(known as Promises in JavaScript), Generics, First-class functions(closures) and static type checking.\nDart can run in any platform such as Web, CLI, Desktop, Mobile and IoT devices.\n\nDart's most controversial feature is its ~~Optional Typing~~ Static Type safety and [Sound Type checks](https://dart.dev/guides/language/sound-dart).\n\n```dart\nimport \"dart:collection\";\nimport \"dart:math\" as math;\n\n/// Welcome to Learn Dart in 15 minutes. http://dart.dev/\n/// This is an executable tutorial. You can run it with Dart or on\n/// the Try Dart! site if you copy/paste it there. http://dartpad.dev/\n/// You can also run Flutter in DartPad by click the `< > New Pad ` and choose Flutter\n\n\n/// In Dart, Everything is an Object.\n/// Every declaration of an object is an instance of Null and\n/// Null is also an object.\n\n\n/// 3 Types of comments in dart\n// Single line comment\n/**\n* Multi-line comment\n* Can comment more than 2 lines\n*/\n/// Code doc comment\n/// It uses markdown syntax to generate code docs when making an API.\n/// Code doc comment is the recommended choice when documenting your APIs, classes and methods.\n\n/// 4 types of variable declaration.\n/// Constants are variables that are immutable cannot be change or altered.\n/// `const` in dart should practice SCREAMING_SNAKE_CASE name declaration.\nconst CONSTANT_VALUE = \"I CANNOT CHANGE\";\nCONSTANT_VALUE = \"DID I?\"; //Error\n/// Final is another variable declaration that cannot be change once it has been instantiated. Commonly used in classes and functions\n/// `final` can be declared in pascalCase.\nfinal finalValue = \"value cannot be change once instantiated\";\nfinalValue = \"Seems not\"; //Error\n\n/// `var` is another variable declaration that is mutable and can change its value. Dart will infer types and will not change its data type\nvar mutableValue = \"Variable string\";\nmutableValue = \"this is valid\";\nmutableValue = false; // Error.\n\n/// `dynamic` is another variable declaration in which the type is not evaluated by the dart static type checking.\n/// It can change its value and data type.\n/// Some dartisans uses dynamic cautiously as it cannot keep track of its data type. so use it at your own risk\ndynamic dynamicValue = \"I'm a string\";\ndynamicValue = false; // false\n\n\n/// Functions can be declared in a global space\n/// Function declaration and method declaration look the same. Function\n/// declarations can be nested. The declaration takes the form of\n/// name() {} or name() => singleLineExpression;\n/// The fat arrow function declaration can be an implicit or\n/// explicit return for the result of the expression.\n/// Dart will execute a function called `main()` anywhere in the dart project.\n///\nexample1() {\n  nested1() {\n    nested2() => print(\"Example1 nested 1 nested 2\");\n    nested2();\n  }\n\n  nested1();\n}\n\n/// Anonymous functions don't include a name but can take number of arguments\nexample2() {\n  //// Explicit return type.\n  nested1(Function<void> fn) {\n    fn();\n  }\n\n  nested1(() => print(\"Example2 nested 1\"));\n}\n\n/// When a function parameter is declared, the declaration can include the\n/// number of parameters the function takes by explicitly specifying the names of the\n/// parameters it takes.\nexample3() {\n  planA(fn(String informSomething)) {\n    fn(\"Example3 plan A\");\n  }\n  planB(fn) {\n    // Or don't declare number of parameters.\n    fn(\"Example3 plan B\");\n  }\n\n  planA((s) => print(s));\n  planB((s) => print(s));\n}\n\n/// Functions have closure access to outer variables.\n/// Dart will infer types when the variable has a value of something.\n/// In this example dart knows that this variable is a String.\nvar example4Something = \"Example4 nested 1\";\nexample4() {\n  nested1(fn(informSomething)) {\n    fn(example4Something);\n  }\n\n  nested1((s) => print(s));\n}\n\n/// Class declaration with a sayIt method, which also has closure access\n/// to the outer variable as though it were a function as seen before.\nvar example5method = \"Example5 sayIt\";\n\nclass Example5Class {\n  sayIt() {\n    print(example5method);\n  }\n}\n\nexample5() {\n  /// Create an anonymous instance of the Example5Class and call the sayIt\n  /// method on it.\n  /// the `new` keyword is optional in Dart.\n  new Example5Class().sayIt();\n}\n\n/// Class declaration takes the form of class name { [classBody] }.\n/// Where classBody can include instance methods and variables, but also\n/// class methods and variables.\nclass Example6Class {\n  var instanceVariable = \"Example6 instance variable\";\n  sayIt() {\n    print(instanceVariable);\n  }\n}\n\nexample6() {\n   Example6Class().sayIt();\n}\n\n/// Class methods and variables are declared with \"static\" terms.\nclass Example7Class {\n  static var classVariable = \"Example7 class variable\";\n  static sayItFromClass() {\n    print(classVariable);\n  }\n\n  sayItFromInstance() {\n    print(classVariable);\n  }\n}\n\nexample7() {\n  Example7Class.sayItFromClass();\n  new Example7Class().sayItFromInstance();\n}\n\n/// Dart supports Generics.\n/// Generics refers to the technique of writing the code for a class\n/// without specifying the data type(s) that the class works on.\n/// Source: https://stackoverflow.com/questions/4560890/what-are-generics-in-c\n\n/// Type `T` refers to any type that has been instantiated\n/// you can call whatever you want\n/// Programmers uses the convention in the following\n/// T - Type(used for class and primitype types)\n/// E - Element(used for List, Set, or Iterable)\n/// K,V - Key Value(used for Map)\nclass GenericExample<T>{\n  void printType(){\n    print(\"$T\")\n  }\n  // methods can also have generics\n  genericMethod<M>(){\n    print(\"class:$T, method: $M\");\n  }\n}\n\n\n/// List are similar to arrays but list is a child of Iterable<E>\n/// Therefore Maps, List, LinkedList are all child of Iterable<E> to be able to loop using the keyword `for`\n/// Important things to remember:\n/// () - Iterable<E>\n/// [] - List<E>\n/// {} - Map<K,V>\n\n\n/// List are great, but there's a restriction for what List can be\n/// outside of function/method bodies. List on the outer scope of class\n/// or outside of class have to be constant. Strings and numbers are constant\n/// by default. But arrays and maps are not. They can be made constant by\n/// declaring them \"const\". Kind of similar to Javascript's Object.freeze()\nconst example8List = [\"Example8 const array\"];\nconst  example8Map = {\"someKey\": \"Example8 const map\"};\n/// Declare List or Maps as Objects.\n List<String> explicitList = new List<String>();\n Map<String,dynamic> explicitMaps = new Map<String,dynamic>();\n\n explicitList.add(\"SomeArray\");\nexample8() {\n  print(example8Map[\"someKey\"]);\n  print(explicitList[0]);\n}\n\n/// Assigning a list from one variable to another will not be the same result.\n/// Because dart is pass-reference-by-value.\n/// So when you assign an existing list to a new variable.\n/// Instead of List, it becomes an Iterable\nvar iterableExplicitList = explicitList;\nprint(iterableExplicitList) // (\"SomeArray\"); \"[]\" becomes \"()\"\nvar newExplicitLists = explicitList.toList() // Converts Iterable<E> to List<E>\n\n/// Loops in Dart take the form of standard for () {} or while () {} loops,\n/// slightly more modern for (.. in ..) {}, or functional callbacks with many\n/// supported features, starting with forEach,map and where.\nvar example9Array = const [\"a\", \"b\"];\nexample9() {\n  for (int i = 0; i < example9Array.length; i++) {\n    print(\"Example9 for loop '${example9Array[i]}'\");\n  }\n  var i = 0;\n  while (i < example9Array.length) {\n    print(\"Example9 while loop '${example9Array[i]}'\");\n    i++;\n  }\n  for (final e in example9Array) {\n    print(\"Example9 for-in loop '${e}'\");\n  }\n\n  example9Array.forEach((e) => print(\"Example9 forEach loop '${e}'\"));\n\n}\n\n/// To loop over the characters of a string or to extract a substring.\nvar example10String = \"ab\";\nexample10() {\n  for (var i = 0; i < example10String.length; i++) {\n    print(\"Example10 String character loop '${example10String[i]}'\");\n  }\n  for (var i = 0; i < example10String.length; i++) {\n    print(\"Example10 substring loop '${example10String.substring(i, i + 1)}'\");\n  }\n}\n\n/// `int`, `double`  and `num` are the three supported number formats.\n/// `num` can be either `int` or `double`.\n/// `int` and `double` are children of type `num`\nexample11() {\n  var i = 1 + 320, d = 3.2 + 0.01;\n  num myNumDouble = 2.2;\n  num myNumInt = 2;\n  int myInt = 1;\n  double myDouble = 0; // Dart will add decimal prefix, becomes 0.0;\n  myNumDouble = myInt; // valid\n  myNumDouble = myDouble; //valid\n  myNumDouble = myNumInt; //valid\n\n  myNumInt = myInt; // valid\n  myNumInt = myDouble; // valid\n  myNumInt = myNumDouble; // valid\n\n  myInt = myNumDouble; //Error\n  myInt = myDouble; //Error\n  myInt = myNumInt; //valid\n\n  myDouble = myInt; //error\n  myDouble = myNumInt; //valid\n  myDouble = myNumDouble; //valid\n\n  print(\"Example11 int ${i}\");\n  print(\"Example11 double ${d}\");\n\n}\n\n/// DateTime provides date/time arithmetic.\nexample12() {\n  var now = new DateTime.now();\n  print(\"Example12 now '${now}'\");\n  now = now.add(new Duration(days: 1));\n  print(\"Example12 tomorrow '${now}'\");\n}\n\n/// Regular expressions are supported.\nexample13() {\n  var s1 = \"some string\", s2 = \"some\", re = new RegExp(\"^s.+?g\\$\");\n  match(s) {\n    if (re.hasMatch(s)) {\n      print(\"Example13 regexp matches '${s}'\");\n    } else {\n      print(\"Example13 regexp doesn't match '${s}'\");\n    }\n  }\n\n  match(s1);\n  match(s2);\n}\n\n/// Boolean expressions support implicit conversions and dynamic type\nexample14() {\n  var a = true;\n  if (a) {\n    print(\"true, a is $a\");\n  }\n  a = null;\n  if (a) {\n    print(\"true, a is $a\");\n  } else {\n    print(\"false, a is $a\"); /// runs here\n  }\n\n  /// dynamic typed null can be convert to bool\n  var b;/// b is dynamic type\n  b = \"abc\";\n  try {\n    if (b) {\n      print(\"true, b is $b\");\n    } else {\n      print(\"false, b is $b\");\n    }\n  } catch (e) {\n    print(\"error, b is $b\"); /// this could be run but got error\n  }\n  b = null;\n  if (b) {\n    print(\"true, b is $b\");\n  } else {\n    print(\"false, b is $b\"); /// runs here\n  }\n\n  /// statically typed null can not be convert to bool\n  var c = \"abc\";\n  c = null;\n  /// complie failed\n  /// if (c) {\n  ///   print(\"true, c is $c\");\n  /// } else {\n  ///   print(\"false, c is $c\");\n  /// }\n}\n\n/// try/catch/finally and throw are used for exception handling.\n/// throw takes any object as parameter;\nexample15() {\n  try {\n    try {\n      throw \"Some unexpected error.\";\n    } catch (e) {\n      print(\"Example15 an exception: '${e}'\");\n      throw e; /// Re-throw\n    }\n  } catch (e) {\n    print(\"Example15 catch exception being re-thrown: '${e}'\");\n  } finally {\n    print(\"Example15 Still run finally\");\n  }\n}\n\n/// To be efficient when creating a long string dynamically, use\n/// StringBuffer. Or you could join a string array.\nexample16() {\n  var sb = new StringBuffer(), a = [\"a\", \"b\", \"c\", \"d\"], e;\n  for (e in a) {\n    sb.write(e);\n  }\n  print(\"Example16 dynamic string created with \"\n      \"StringBuffer '${sb.toString()}'\");\n  print(\"Example16 join string array '${a.join()}'\");\n}\n\n/// Strings can be concatenated by just having string List next to\n/// one another with no further operator needed.\n\nexample17() {\n  print(\"Example17 \"\n      \"concatenate \"\n      \"strings \"\n      \"just like that\");\n}\n\n/// Strings have single-quote or double-quote for delimiters with no\n/// actual difference between the two. The given flexibility can be good\n/// to avoid the need to escape content that matches the delimiter being\n/// used. For example, double-quotes of HTML attributes if the string\n/// contains HTML content.\nexample18() {\n  print('Example18 <a href=\"etc\">'\n      \"Don't can't I'm Etc\"\n      '</a>');\n}\n\n/// Strings with triple single-quotes or triple double-quotes span\n/// multiple lines and include line delimiters.\nexample19() {\n  print('''Example19 <a href=\"etc\">\nExample19 Don't can't I'm Etc\nExample19 </a>''');\n}\n\n/// Strings have the nice interpolation feature with the $ character.\n/// With $ { [expression] }, the return of the expression is interpolated.\n/// $ followed by a variable name interpolates the content of that variable.\n/// $ can be escaped like so \\$ to just add it to the string instead.\nexample20() {\n  var s1 = \"'\\${s}'\", s2 = \"'\\$s'\";\n  print(\"Example20 \\$ interpolation ${s1} or $s2 works.\");\n}\n\n/// Optional types allow for the annotation of APIs and come to the aid of\n/// IDEs so the IDEs can better refactor, auto-complete and check for\n/// errors. So far we haven't declared any types and the programs have\n/// worked just fine. In fact, types are disregarded during runtime.\n/// Types can even be wrong and the program will still be given the\n/// benefit of the doubt and be run as though the types didn't matter.\n/// There's a runtime parameter that checks for type errors which is\n/// the checked mode, which is said to be useful during development time,\n/// but which is also slower because of the extra checking and is thus\n/// avoided during deployment runtime.\nclass Example21 {\n  List<String> _names;\n  Example21() {\n    _names = [\"a\", \"b\"];\n  }\n  List<String> get names => _names;\n  set names(List<String> list) {\n    _names = list;\n  }\n\n  int get length => _names.length;\n  void add(String name) {\n    _names.add(name);\n  }\n}\n\nvoid example21() {\n  Example21 o = new Example21();\n  o.add(\"c\");\n  print(\"Example21 names '${o.names}' and length '${o.length}'\");\n  o.names = [\"d\", \"e\"];\n  print(\"Example21 names '${o.names}' and length '${o.length}'\");\n}\n\n/// Class inheritance takes the form of class name extends AnotherClassName {}.\nclass Example22A {\n  var _name = \"Some Name!\";\n  get name => _name;\n}\n\nclass Example22B extends Example22A {}\n\nexample22() {\n  var o = new Example22B();\n  print(\"Example22 class inheritance '${o.name}'\");\n}\n\n/// Class mixin is also available, and takes the form of\n/// class name extends SomeClass with AnotherClassName {}.\n/// It's necessary to extend some class to be able to mixin another one.\n/// The template class of mixin cannot at the moment have a constructor.\n/// Mixin is mostly used to share methods with distant classes, so the\n/// single inheritance doesn't get in the way of reusable code.\n/// Mixins follow the \"with\" statement during the class declaration.\nclass Example23A {}\n\nclass Example23Utils {\n  addTwo(n1, n2) {\n    return n1 + n2;\n  }\n}\n\nclass Example23B extends Example23A with Example23Utils {\n  addThree(n1, n2, n3) {\n    return addTwo(n1, n2) + n3;\n  }\n}\n\nexample23() {\n  var o = new Example23B(), r1 = o.addThree(1, 2, 3), r2 = o.addTwo(1, 2);\n  print(\"Example23 addThree(1, 2, 3) results in '${r1}'\");\n  print(\"Example23 addTwo(1, 2) results in '${r2}'\");\n}\n\n/// The Class constructor method uses the same name of the class and\n/// takes the form of SomeClass() : super() {}, where the \": super()\"\n/// part is optional and it's used to delegate constant parameters to the\n/// super-parent's constructor.\nclass Example24A {\n  var _value;\n  Example24A({value: \"someValue\"}) {\n    _value = value;\n  }\n  get value => _value;\n}\n\nclass Example24B extends Example24A {\n  Example24B({value: \"someOtherValue\"}) : super(value: value);\n}\n\nexample24() {\n  var o1 = new Example24B(), o2 = new Example24B(value: \"evenMore\");\n  print(\"Example24 calling super during constructor '${o1.value}'\");\n  print(\"Example24 calling super during constructor '${o2.value}'\");\n}\n\n/// There's a shortcut to set constructor parameters in case of simpler classes.\n/// Just use the this.parameterName prefix and it will set the parameter on\n/// an instance variable of same name.\nclass Example25 {\n  var value, anotherValue;\n  Example25({this.value, this.anotherValue});\n}\n\nexample25() {\n  var o = new Example25(value: \"a\", anotherValue: \"b\");\n  print(\"Example25 shortcut for constructor '${o.value}' and \"\n      \"'${o.anotherValue}'\");\n}\n\n/// Named parameters are available when declared between {}.\n/// Parameter order can be optional when declared between {}.\n/// Parameters can be made optional when declared between [].\nexample26() {\n  var _name, _surname, _email;\n  setConfig1({name, surname}) {\n    _name = name;\n    _surname = surname;\n  }\n\n  setConfig2(name, [surname, email]) {\n    _name = name;\n    _surname = surname;\n    _email = email;\n  }\n\n  setConfig1(surname: \"Doe\", name: \"John\");\n  print(\"Example26 name '${_name}', surname '${_surname}', \"\n      \"email '${_email}'\");\n  setConfig2(\"Mary\", \"Jane\");\n  print(\"Example26 name '${_name}', surname '${_surname}', \"\n      \"email '${_email}'\");\n}\n\n/// Variables declared with final can only be set once.\n/// In case of classes, final instance variables can be set via constant\n/// constructor parameter.\nclass Example27 {\n  final color1, color2;\n  /// A little flexibility to set final instance variables with syntax\n  /// that follows the :\n  Example27({this.color1, color2}) : color2 = color2;\n}\n\nexample27() {\n  final color = \"orange\", o = new Example27(color1: \"lilac\", color2: \"white\");\n  print(\"Example27 color is '${color}'\");\n  print(\"Example27 color is '${o.color1}' and '${o.color2}'\");\n}\n\n/// To import a library, use import \"libraryPath\" or if it's a core library,\n/// import \"dart:libraryName\". There's also the \"pub\" package management with\n/// its own convention of import \"package:packageName\".\n/// See import \"dart:collection\"; at the top. Imports must come before\n/// other code declarations. IterableBase comes from dart:collection.\nclass Example28 extends IterableBase {\n  var names;\n  Example28() {\n    names = [\"a\", \"b\"];\n  }\n  get iterator => names.iterator;\n}\n\nexample28() {\n  var o = new Example28();\n  o.forEach((name) => print(\"Example28 '${name}'\"));\n}\n\n/// For control flow we have:\n/// * standard switch with must break statements\n/// * if-else if-else and ternary ..?..:.. operator\n/// * closures and anonymous functions\n/// * break, continue and return statements\nexample29() {\n  var v = true ? 30 : 60;\n  switch (v) {\n    case 30:\n      print(\"Example29 switch statement\");\n      break;\n  }\n  if (v < 30) {\n  } else if (v > 30) {\n  } else {\n    print(\"Example29 if-else statement\");\n  }\n  callItForMe(fn()) {\n    return fn();\n  }\n\n  rand() {\n    v = new DM.Random().nextInt(50);\n    return v;\n  }\n\n  while (true) {\n    print(\"Example29 callItForMe(rand) '${callItForMe(rand)}'\");\n    if (v != 30) {\n      break;\n    } else {\n      continue;\n    }\n    /// Never gets here.\n  }\n}\n\n/// Parse int, convert double to int, or just keep int when dividing numbers\n/// by using the ~/ operation. Let's play a guess game too.\nexample30() {\n  var gn,\n      tooHigh = false,\n      n,\n      n2 = (2.0).toInt(),\n      top = int.parse(\"123\") ~/ n2,\n      bottom = 0;\n  top = top ~/ 6;\n  gn = new DM.Random().nextInt(top + 1); /// +1 because nextInt top is exclusive\n  print(\"Example30 Guess a number between 0 and ${top}\");\n  guessNumber(i) {\n    if (n == gn) {\n      print(\"Example30 Guessed right! The number is ${gn}\");\n    } else {\n      tooHigh = n > gn;\n      print(\"Example30 Number ${n} is too \"\n          \"${tooHigh ? 'high' : 'low'}. Try again\");\n    }\n    return n == gn;\n  }\n\n  n = (top - bottom) ~/ 2;\n  while (!guessNumber(n)) {\n    if (tooHigh) {\n      top = n - 1;\n    } else {\n      bottom = n + 1;\n    }\n    n = bottom + ((top - bottom) ~/ 2);\n  }\n}\n\n/// Optional Positional Parameter:\n/// parameter will be disclosed with square bracket [ ] & square bracketed parameter are optional.\nexample31() {\n    findVolume31(int length, int breath, [int height]) {\n      print('length = $length, breath = $breath, height = $height');\n    }\n\n    findVolume31(10,20,30); //valid\n    findVolume31(10,20); //also valid\n}\n\n/// Optional Named Parameter:\n/// parameter will be disclosed with curly bracket { }\n/// curly bracketed parameter are optional.\n/// have to use parameter name to assign a value which separated with colan :\n/// in curly bracketed parameter order does not matter\n/// these type parameter help us to avoid confusion while passing value for a function which has many parameter.\nexample32() {\n    findVolume32(int length, int breath, {int height}) {\n    print('length = $length, breath = $breath, height = $height');\n    }\n\n    findVolume32(10,20,height:30);//valid & we can see the parameter name is mentioned here.\n    findVolume32(10,20);//also valid\n}\n\n/// Optional Default Parameter:\n/// same like optional named parameter in addition we can assign default value for this parameter.\n/// which means no value is passed this default value will be taken.\nexample33() {\n    findVolume33(int length, int breath, {int height=10}) {\n     print('length = $length, breath = $breath, height = $height');\n    }\n\n    findVolume33(10,20,height:30);//valid\n    findVolume33(10,20);//valid\n}\n\n/// Dart has also added feature such as Null aware operators\nvar isBool = true;\nvar hasString = isBool ?? \"default String\";\n\n/// Programs have only one entry point in the main function.\n/// Nothing is expected to be executed on the outer scope before a program\n/// starts running with what's in its main function.\n/// This helps with faster loading and even lazily loading of just what\n/// the program needs to startup with.\nmain() {\n  print(\"Learn Dart in 15 minutes!\");\n  [\n    example1, example2, example3, example4, example5,\n    example6, example7, example8, example9, example10,\n    example11, example12, example13, example14, example15,\n    example16, example17, example18, example19, example20,\n    example21, example22, example23, example24, example25,\n    example26, example27, example28, example29,\n    example30 // Adding this comment stops the dart formatter from putting all items on a new line\n  ].forEach((ef) => ef());\n}\n\n```\n\n## Further Reading\n\nDart has a comprehensive web-site. It covers API reference, tutorials, articles and more, including a\nuseful Try Dart online.\n[https://www.dartlang.org](https://www.dartlang.org)\n[https://try.dartlang.org](https://try.dartlang.org)"
