
package pages

const Elixir = "Elixir is a modern functional language built on top of the Erlang VM.\nIt's fully compatible with Erlang, but features a more standard syntax\nand many more features.\n\n```elixir\n\n# Single line comments start with a number symbol.\n\n# There's no multi-line comment,\n# but you can stack multiple comments.\n\n# To use the elixir shell use the `iex` command.\n# Compile your modules with the `elixirc` command.\n\n# Both should be in your path if you installed elixir correctly.\n\n## ---------------------------\n## -- Basic types\n## ---------------------------\n\n# There are numbers\n3    # integer\n0x1F # integer\n3.0  # float\n\n# Atoms, that are literals, a constant with name. They start with `:`.\n:hello # atom\n\n# Tuples that are stored contiguously in memory.\n{1,2,3} # tuple\n\n# We can access a tuple element with the `elem` function:\nelem({1, 2, 3}, 0) #=> 1\n\n# Lists that are implemented as linked lists.\n[1,2,3] # list\n\n# We can access the head and tail of a list as follows:\n[head | tail] = [1,2,3]\nhead #=> 1\ntail #=> [2,3]\n\n# In elixir, just like in Erlang, the `=` denotes pattern matching and\n# not an assignment.\n#\n# This means that the left-hand side (pattern) is matched against a\n# right-hand side.\n#\n# This is how the above example of accessing the head and tail of a list works.\n\n# A pattern match will error when the sides don't match, in this example\n# the tuples have different sizes.\n# {a, b, c} = {1, 2} #=> ** (MatchError) no match of right hand side value: {1,2}\n\n# There are also binaries\n<<1,2,3>> # binary\n\n# Strings and char lists\n\"hello\" # string\n'hello' # char list\n\n# Multi-line strings\n\"\"\"\nI'm a multi-line\nstring.\n\"\"\"\n#=> \"I'm a multi-line\\nstring.\\n\"\n\n# Strings are all encoded in UTF-8:\n\"héllò\" #=> \"héllò\"\n\n# Strings are really just binaries, and char lists are just lists.\n<<?a, ?b, ?c>> #=> \"abc\"\n[?a, ?b, ?c]   #=> 'abc'\n\n# `?a` in elixir returns the ASCII integer for the letter `a`\n?a #=> 97\n\n# To concatenate lists use `++`, for binaries use `<>`\n[1,2,3] ++ [4,5]     #=> [1,2,3,4,5]\n'hello ' ++ 'world'  #=> 'hello world'\n\n<<1,2,3>> <> <<4,5>> #=> <<1,2,3,4,5>>\n\"hello \" <> \"world\"  #=> \"hello world\"\n\n# Ranges are represented as `start..end` (both inclusive)\n1..10 #=> 1..10\nlower..upper = 1..10 # Can use pattern matching on ranges as well\n[lower, upper] #=> [1, 10]\n\n# Maps are key-value pairs\ngenders = %{\"david\" => \"male\", \"gillian\" => \"female\"}\ngenders[\"david\"] #=> \"male\"\n\n# Maps with atom keys can be used like this\ngenders = %{david: \"male\", gillian: \"female\"}\ngenders.gillian #=> \"female\"\n\n## ---------------------------\n## -- Operators\n## ---------------------------\n\n# Some math\n1 + 1  #=> 2\n10 - 5 #=> 5\n5 * 2  #=> 10\n10 / 2 #=> 5.0\n\n# In elixir the operator `/` always returns a float.\n\n# To do integer division use `div`\ndiv(10, 2) #=> 5\n\n# To get the division remainder use `rem`\nrem(10, 3) #=> 1\n\n# There are also boolean operators: `or`, `and` and `not`.\n# These operators expect a boolean as their first argument.\ntrue and true #=> true\nfalse or true #=> true\n# 1 and true\n#=> ** (BadBooleanError) expected a boolean on left-side of \"and\", got: 1\n\n# Elixir also provides `||`, `&&` and `!` which accept arguments of any type.\n# All values except `false` and `nil` will evaluate to true.\n1 || true  #=> 1\nfalse && 1 #=> false\nnil && 20  #=> nil\n!true #=> false\n\n# For comparisons we have: `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<` and `>`\n1 == 1 #=> true\n1 != 1 #=> false\n1 < 2  #=> true\n\n# `===` and `!==` are more strict when comparing integers and floats:\n1 == 1.0  #=> true\n1 === 1.0 #=> false\n\n# We can also compare two different data types:\n1 < :hello #=> true\n\n# The overall sorting order is defined below:\n# number < atom < reference < functions < port < pid < tuple < list < bit string\n\n# To quote Joe Armstrong on this: \"The actual order is not important,\n# but that a total ordering is well defined is important.\"\n\n## ---------------------------\n## -- Control Flow\n## ---------------------------\n\n# `if` expression\nif false do\n  \"This will never be seen\"\nelse\n  \"This will\"\nend\n\n# There's also `unless`\nunless true do\n  \"This will never be seen\"\nelse\n  \"This will\"\nend\n\n# Remember pattern matching? Many control-flow structures in elixir rely on it.\n\n# `case` allows us to compare a value against many patterns:\ncase {:one, :two} do\n  {:four, :five} ->\n    \"This won't match\"\n  {:one, x} ->\n    \"This will match and bind `x` to `:two` in this clause\"\n  _ ->\n    \"This will match any value\"\nend\n\n# It's common to bind the value to `_` if we don't need it.\n# For example, if only the head of a list matters to us:\n[head | _] = [1,2,3]\nhead #=> 1\n\n# For better readability we can do the following:\n[head | _tail] = [:a, :b, :c]\nhead #=> :a\n\n# `cond` lets us check for many conditions at the same time.\n# Use `cond` instead of nesting many `if` expressions.\ncond do\n  1 + 1 == 3 ->\n    \"I will never be seen\"\n  2 * 5 == 12 ->\n    \"Me neither\"\n  1 + 2 == 3 ->\n    \"But I will\"\nend\n\n# It is common to set the last condition equal to `true`, which will always match.\ncond do\n  1 + 1 == 3 ->\n    \"I will never be seen\"\n  2 * 5 == 12 ->\n    \"Me neither\"\n  true ->\n    \"But I will (this is essentially an else)\"\nend\n\n# `try/catch` is used to catch values that are thrown, it also supports an\n# `after` clause that is invoked whether or not a value is caught.\ntry do\n  throw(:hello)\ncatch\n  message -> \"Got #{message}.\"\nafter\n  IO.puts(\"I'm the after clause.\")\nend\n#=> I'm the after clause\n# \"Got :hello\"\n\n## ---------------------------\n## -- Modules and Functions\n## ---------------------------\n\n# Anonymous functions (notice the dot)\nsquare = fn(x) -> x * x end\nsquare.(5) #=> 25\n\n# They also accept many clauses and guards.\n# Guards let you fine tune pattern matching,\n# they are indicated by the `when` keyword:\nf = fn\n  x, y when x > 0 -> x + y\n  x, y -> x * y\nend\n\nf.(1, 3)  #=> 4\nf.(-1, 3) #=> -3\n\n# Elixir also provides many built-in functions.\n# These are available in the current scope.\nis_number(10)    #=> true\nis_list(\"hello\") #=> false\nelem({1,2,3}, 0) #=> 1\n\n# You can group several functions into a module. Inside a module use `def`\n# to define your functions.\ndefmodule Math do\n  def sum(a, b) do\n    a + b\n  end\n\n  def square(x) do\n    x * x\n  end\nend\n\nMath.sum(1, 2)  #=> 3\nMath.square(3) #=> 9\n\n# To compile our simple Math module save it as `math.ex` and use `elixirc`\n# in your terminal: elixirc math.ex\n\n# Inside a module we can define functions with `def` and private functions with `defp`.\n# A function defined with `def` is available to be invoked from other modules,\n# a private function can only be invoked locally.\ndefmodule PrivateMath do\n  def sum(a, b) do\n    do_sum(a, b)\n  end\n\n  defp do_sum(a, b) do\n    a + b\n  end\nend\n\nPrivateMath.sum(1, 2)    #=> 3\n# PrivateMath.do_sum(1, 2) #=> ** (UndefinedFunctionError)\n\n# Function declarations also support guards and multiple clauses.\n# When a function with multiple clauses is called, the first function\n# that satisfies the clause will be invoked.\n# Example: invoking area({:circle, 3}) will call the second area\n# function defined below, not the first:\ndefmodule Geometry do\n  def area({:rectangle, w, h}) do\n    w * h\n  end\n\n  def area({:circle, r}) when is_number(r) do\n    3.14 * r * r\n  end\nend\n\nGeometry.area({:rectangle, 2, 3}) #=> 6\nGeometry.area({:circle, 3})       #=> 28.25999999999999801048\n# Geometry.area({:circle, \"not_a_number\"})\n#=> ** (FunctionClauseError) no function clause matching in Geometry.area/1\n\n# Due to immutability, recursion is a big part of elixir\ndefmodule Recursion do\n  def sum_list([head | tail], acc) do\n    sum_list(tail, acc + head)\n  end\n\n  def sum_list([], acc) do\n    acc\n  end\nend\n\nRecursion.sum_list([1,2,3], 0) #=> 6\n\n# Elixir modules support attributes, there are built-in attributes and you\n# may also add custom ones.\ndefmodule MyMod do\n  @moduledoc \"\"\"\n  This is a built-in attribute on a example module.\n  \"\"\"\n\n  @my_data 100 # This is a custom attribute.\n  IO.inspect(@my_data) #=> 100\nend\n\n# The pipe operator |> allows you to pass the output of an expression\n# as the first parameter into a function. \n\nRange.new(1,10)\n|> Enum.map(fn x -> x * x end)\n|> Enum.filter(fn x -> rem(x, 2) == 0 end)\n#=> [4, 16, 36, 64, 100]\n\n## ---------------------------\n## -- Structs and Exceptions\n## ---------------------------\n\n# Structs are extensions on top of maps that bring default values,\n# compile-time guarantees and polymorphism into Elixir.\ndefmodule Person do\n  defstruct name: nil, age: 0, height: 0\nend\n\njoe_info = %Person{ name: \"Joe\", age: 30, height: 180 }\n#=> %Person{age: 30, height: 180, name: \"Joe\"}\n\n# Access the value of name\njoe_info.name #=> \"Joe\"\n\n# Update the value of age\nolder_joe_info = %{ joe_info | age: 31 }\n#=> %Person{age: 31, height: 180, name: \"Joe\"}\n\n# The `try` block with the `rescue` keyword is used to handle exceptions\ntry do\n  raise \"some error\"\nrescue\n  RuntimeError -> \"rescued a runtime error\"\n  _error -> \"this will rescue any error\"\nend\n#=> \"rescued a runtime error\"\n\n# All exceptions have a message\ntry do\n  raise \"some error\"\nrescue\n  x in [RuntimeError] ->\n    x.message\nend\n#=> \"some error\"\n\n## ---------------------------\n## -- Concurrency\n## ---------------------------\n\n# Elixir relies on the actor model for concurrency. All we need to write\n# concurrent programs in elixir are three primitives: spawning processes,\n# sending messages and receiving messages.\n\n# To start a new process we use the `spawn` function, which takes a function\n# as argument.\nf = fn -> 2 * 2 end #=> #Function<erl_eval.20.80484245>\nspawn(f) #=> #PID<0.40.0>\n\n# `spawn` returns a pid (process identifier), you can use this pid to send\n# messages to the process. To do message passing we use the `send` operator.\n# For all of this to be useful we need to be able to receive messages. This is\n# achieved with the `receive` mechanism:\n\n# The `receive do` block is used to listen for messages and process\n# them when they are received. A `receive do` block will only\n# process one received message. In order to process multiple\n# messages, a function with a `receive do` block must recursively\n# call itself to get into the `receive do` block again.\n\ndefmodule Geometry do\n  def area_loop do\n    receive do\n      {:rectangle, w, h} ->\n        IO.puts(\"Area = #{w * h}\")\n        area_loop()\n      {:circle, r} ->\n        IO.puts(\"Area = #{3.14 * r * r}\")\n        area_loop()\n    end\n  end\nend\n\n# Compile the module and create a process that evaluates `area_loop` in the shell\npid = spawn(fn -> Geometry.area_loop() end) #=> #PID<0.40.0>\n# Alternatively\npid = spawn(Geometry, :area_loop, [])\n\n# Send a message to `pid` that will match a pattern in the receive statement\nsend pid, {:rectangle, 2, 3}\n#=> Area = 6\n#   {:rectangle,2,3}\n\nsend pid, {:circle, 2}\n#=> Area = 12.56000000000000049738\n#   {:circle,2}\n\n# The shell is also a process, you can use `self` to get the current pid\nself() #=> #PID<0.27.0>\n\n## ---------------------------\n## -- Agents\n## ---------------------------\n\n# An agent is a process that keeps track of some changing value\n\n# Create an agent with `Agent.start_link`, passing in a function\n# The initial state of the agent will be whatever that function returns\n{:ok, my_agent} = Agent.start_link(fn -> [\"red\", \"green\"] end)\n\n# `Agent.get` takes an agent name and a `fn` that gets passed the current state\n# Whatever that `fn` returns is what you'll get back\nAgent.get(my_agent, fn colors -> colors end) #=> [\"red\", \"green\"]\n\n# Update the agent's state the same way\nAgent.update(my_agent, fn colors -> [\"blue\" | colors] end)\n```\n\n## References\n\n* [Getting started guide](https://elixir-lang.org/getting-started/introduction.html) from the [Elixir website](https://elixir-lang.org)\n* [Elixir Documentation](https://elixir-lang.org/docs.html)\n* [\"Programming Elixir\"](https://pragprog.com/book/elixir/programming-elixir) by Dave Thomas\n* [Elixir Cheat Sheet](https://media.pragprog.com/titles/elixir/ElixirCheat.pdf)\n* [\"Learn You Some Erlang for Great Good!\"](https://learnyousomeerlang.com/) by Fred Hebert\n* [\"Programming Erlang: Software for a Concurrent World\"](https://pragprog.com/book/jaerlang2/programming-erlang) by Joe Armstrong\n* [Introduction to Elixir](https://learn-elixir.com/)"
