
package pages

const Kotlin = "Kotlin is a statically typed programming language for the JVM, Android and the\nbrowser. It is 100% interoperable with Java.\n[Read more here.](https://kotlinlang.org/)\n\n```kotlin\n// Single-line comments start with //\n/*\nMulti-line comments look like this.\n*/\n\n// The \"package\" keyword works in the same way as in Java.\npackage com.learnxinyminutes.kotlin\n\n/*\nThe entry point to a Kotlin program is a function named \"main\".\nThe function is passed an array containing any command-line arguments.\nSince Kotlin 1.3 the \"main\" function can also be defined without\nany parameters.\n*/\nfun main(args: Array<String>) {\n    /*\n    Declaring values is done using either \"var\" or \"val\".\n    \"val\" declarations cannot be reassigned, whereas \"vars\" can.\n    */\n    val fooVal = 10 // we cannot later reassign fooVal to something else\n    var fooVar = 10\n    fooVar = 20 // fooVar can be reassigned\n\n    /*\n    In most cases, Kotlin can determine what the type of a variable is,\n    so we don't have to explicitly specify it every time.\n    We can explicitly declare the type of a variable like so:\n    */\n    val foo: Int = 7\n\n    /*\n    Strings can be represented in a similar way as in Java.\n    Escaping is done with a backslash.\n    */\n    val fooString = \"My String Is Here!\"\n    val barString = \"Printing on a new line?\\nNo Problem!\"\n    val bazString = \"Do you want to add a tab?\\tNo Problem!\"\n    println(fooString)\n    println(barString)\n    println(bazString)\n\n    /*\n    A raw string is delimited by a triple quote (\"\"\").\n    Raw strings can contain newlines and any other characters.\n    */\n    val fooRawString = \"\"\"\nfun helloWorld(val name : String) {\n   println(\"Hello, world!\")\n}\n\"\"\"\n    println(fooRawString)\n\n    /*\n    Strings can contain template expressions.\n    A template expression starts with a dollar sign ($).\n    */\n    val fooTemplateString = \"$fooString has ${fooString.length} characters\"\n    println(fooTemplateString) // => My String Is Here! has 18 characters\n\n    /*\n    For a variable to hold null it must be explicitly specified as nullable.\n    A variable can be specified as nullable by appending a ? to its type.\n    We can access a nullable variable by using the ?. operator.\n    We can use the ?: operator to specify an alternative value to use\n    if a variable is null.\n    */\n    var fooNullable: String? = \"abc\"\n    println(fooNullable?.length) // => 3\n    println(fooNullable?.length ?: -1) // => 3\n    fooNullable = null\n    println(fooNullable?.length) // => null\n    println(fooNullable?.length ?: -1) // => -1\n\n    /*\n    Functions can be declared using the \"fun\" keyword.\n    Function arguments are specified in brackets after the function name.\n    Function arguments can optionally have a default value.\n    The function return type, if required, is specified after the arguments.\n    */\n    fun hello(name: String = \"world\"): String {\n        return \"Hello, $name!\"\n    }\n    println(hello(\"foo\")) // => Hello, foo!\n    println(hello(name = \"bar\")) // => Hello, bar!\n    println(hello()) // => Hello, world!\n\n    /*\n    A function parameter may be marked with the \"vararg\" keyword\n    to allow a variable number of arguments to be passed to the function.\n    */\n    fun varargExample(vararg names: Int) {\n        println(\"Argument has ${names.size} elements\")\n    }\n    varargExample() // => Argument has 0 elements\n    varargExample(1) // => Argument has 1 elements\n    varargExample(1, 2, 3) // => Argument has 3 elements\n\n    /*\n    When a function consists of a single expression then the curly brackets can\n    be omitted. The body is specified after the = symbol.\n    */\n    fun odd(x: Int): Boolean = x % 2 == 1\n    println(odd(6)) // => false\n    println(odd(7)) // => true\n\n    // If the return type can be inferred then we don't need to specify it.\n    fun even(x: Int) = x % 2 == 0\n    println(even(6)) // => true\n    println(even(7)) // => false\n\n    // Functions can take functions as arguments and return functions.\n    fun not(f: (Int) -> Boolean): (Int) -> Boolean {\n        return {n -> !f.invoke(n)}\n    }\n    // Named functions can be specified as arguments using the :: operator.\n    val notOdd = not(::odd)\n    val notEven = not(::even)\n    // Lambda expressions can be specified as arguments.\n    val notZero = not {n -> n == 0}\n    /*\n    If a lambda has only one parameter\n    then its declaration can be omitted (along with the ->).\n    The name of the single parameter will be \"it\".\n    */\n    val notPositive = not {it > 0}\n    for (i in 0..4) {\n        println(\"${notOdd(i)} ${notEven(i)} ${notZero(i)} ${notPositive(i)}\")\n    }\n\n    // The \"class\" keyword is used to declare classes.\n    class ExampleClass(val x: Int) {\n        fun memberFunction(y: Int): Int {\n            return x + y\n        }\n\n        infix fun infixMemberFunction(y: Int): Int {\n            return x * y\n        }\n    }\n    /*\n    To create a new instance we call the constructor.\n    Note that Kotlin does not have a \"new\" keyword.\n    */\n    val fooExampleClass = ExampleClass(7)\n    // Member functions can be called using dot notation.\n    println(fooExampleClass.memberFunction(4)) // => 11\n    /*\n    If a function has been marked with the \"infix\" keyword then it can be\n    called using infix notation.\n    */\n    println(fooExampleClass infixMemberFunction 4) // => 28\n\n    /*\n    Data classes are a concise way to create classes that just hold data.\n    The \"hashCode\"/\"equals\" and \"toString\" methods are automatically generated.\n    */\n    data class DataClassExample (val x: Int, val y: Int, val z: Int)\n    val fooData = DataClassExample(1, 2, 4)\n    println(fooData) // => DataClassExample(x=1, y=2, z=4)\n\n    // Data classes have a \"copy\" function.\n    val fooCopy = fooData.copy(y = 100)\n    println(fooCopy) // => DataClassExample(x=1, y=100, z=4)\n\n    // Objects can be destructured into multiple variables.\n    val (a, b, c) = fooCopy\n    println(\"$a $b $c\") // => 1 100 4\n\n    // destructuring in \"for\" loop\n    for ((a, b, c) in listOf(fooData)) {\n        println(\"$a $b $c\") // => 1 2 4\n    }\n\n    val mapData = mapOf(\"a\" to 1, \"b\" to 2)\n    // Map.Entry is destructurable as well\n    for ((key, value) in mapData) {\n        println(\"$key -> $value\")\n    }\n\n    // The \"with\" function is similar to the JavaScript \"with\" statement.\n    data class MutableDataClassExample (var x: Int, var y: Int, var z: Int)\n    val fooMutableData = MutableDataClassExample(7, 4, 9)\n    with (fooMutableData) {\n        x -= 2\n        y += 2\n        z--\n    }\n    println(fooMutableData) // => MutableDataClassExample(x=5, y=6, z=8)\n\n    /*\n    We can create a list using the \"listOf\" function.\n    The list will be immutable - elements cannot be added or removed.\n    */\n    val fooList = listOf(\"a\", \"b\", \"c\")\n    println(fooList.size) // => 3\n    println(fooList.first()) // => a\n    println(fooList.last()) // => c\n    // Elements of a list can be accessed by their index.\n    println(fooList[1]) // => b\n\n    // A mutable list can be created using the \"mutableListOf\" function.\n    val fooMutableList = mutableListOf(\"a\", \"b\", \"c\")\n    fooMutableList.add(\"d\")\n    println(fooMutableList.last()) // => d\n    println(fooMutableList.size) // => 4\n\n    // We can create a set using the \"setOf\" function.\n    val fooSet = setOf(\"a\", \"b\", \"c\")\n    println(fooSet.contains(\"a\")) // => true\n    println(fooSet.contains(\"z\")) // => false\n\n    // We can create a map using the \"mapOf\" function.\n    val fooMap = mapOf(\"a\" to 8, \"b\" to 7, \"c\" to 9)\n    // Map values can be accessed by their key.\n    println(fooMap[\"a\"]) // => 8\n\n    /*\n    Sequences represent lazily-evaluated collections.\n    We can create a sequence using the \"generateSequence\" function.\n    */\n    val fooSequence = generateSequence(1, { it + 1 })\n    val x = fooSequence.take(10).toList()\n    println(x) // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    // An example of using a sequence to generate Fibonacci numbers:\n    fun fibonacciSequence(): Sequence<Long> {\n        var a = 0L\n        var b = 1L\n\n        fun next(): Long {\n            val result = a + b\n            a = b\n            b = result\n            return a\n        }\n\n        return generateSequence(::next)\n    }\n    val y = fibonacciSequence().take(10).toList()\n    println(y) // => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n\n    // Kotlin provides higher-order functions for working with collections.\n    val z = (1..9).map {it * 3}\n                  .filter {it < 20}\n                  .groupBy {it % 2 == 0}\n                  .mapKeys {if (it.key) \"even\" else \"odd\"}\n    println(z) // => {odd=[3, 9, 15], even=[6, 12, 18]}\n\n    // A \"for\" loop can be used with anything that provides an iterator.\n    for (c in \"hello\") {\n        println(c)\n    }\n\n    // \"while\" loops work in the same way as other languages.\n    var ctr = 0\n    while (ctr < 5) {\n        println(ctr)\n        ctr++\n    }\n    do {\n        println(ctr)\n        ctr++\n    } while (ctr < 10)\n\n    /*\n    \"if\" can be used as an expression that returns a value.\n    For this reason the ternary ?: operator is not needed in Kotlin.\n    */\n    val num = 5\n    val message = if (num % 2 == 0) \"even\" else \"odd\"\n    println(\"$num is $message\") // => 5 is odd\n\n    // \"when\" can be used as an alternative to \"if-else if\" chains.\n    val i = 10\n    when {\n        i < 7 -> println(\"first block\")\n        fooString.startsWith(\"hello\") -> println(\"second block\")\n        else -> println(\"else block\")\n    }\n\n    // \"when\" can be used with an argument.\n    when (i) {\n        0, 21 -> println(\"0 or 21\")\n        in 1..20 -> println(\"in the range 1 to 20\")\n        else -> println(\"none of the above\")\n    }\n\n    // \"when\" can be used as a function that returns a value.\n    var result = when (i) {\n        0, 21 -> \"0 or 21\"\n        in 1..20 -> \"in the range 1 to 20\"\n        else -> \"none of the above\"\n    }\n    println(result)\n\n    /*\n    We can check if an object is of a particular type by using the \"is\" operator.\n    If an object passes a type check then it can be used as that type without\n    explicitly casting it.\n    */\n    fun smartCastExample(x: Any) : Boolean {\n        if (x is Boolean) {\n            // x is automatically cast to Boolean\n            return x\n        } else if (x is Int) {\n            // x is automatically cast to Int\n            return x > 0\n        } else if (x is String) {\n            // x is automatically cast to String\n            return x.isNotEmpty()\n        } else {\n            return false\n        }\n    }\n    println(smartCastExample(\"Hello, world!\")) // => true\n    println(smartCastExample(\"\")) // => false\n    println(smartCastExample(5)) // => true\n    println(smartCastExample(0)) // => false\n    println(smartCastExample(true)) // => true\n\n    // Smartcast also works with when block\n    fun smartCastWhenExample(x: Any) = when (x) {\n        is Boolean -> x\n        is Int -> x > 0\n        is String -> x.isNotEmpty()\n        else -> false\n    }\n\n    /*\n    Extensions are a way to add new functionality to a class.\n    This is similar to C# extension methods.\n    */\n    fun String.remove(c: Char): String {\n        return this.filter {it != c}\n    }\n    println(\"Hello, world!\".remove('l')) // => Heo, word!\n}\n\n// Enum classes are similar to Java enum types.\nenum class EnumExample {\n    A, B, C // Enum constants are separated with commas.\n}\nfun printEnum() = println(EnumExample.A) // => A\n\n// Since each enum is an instance of the enum class, they can be initialized as:\nenum class EnumExample(val value: Int) {\n    A(value = 1),\n    B(value = 2),\n    C(value = 3)\n}\nfun printProperty() = println(EnumExample.A.value) // => 1\n\n// Every enum has properties to obtain its name and ordinal(position) in the enum class declaration:\nfun printName() = println(EnumExample.A.name) // => A\nfun printPosition() = println(EnumExample.A.ordinal) // => 0\n\n/*\nThe \"object\" keyword can be used to create singleton objects.\nWe cannot instantiate it but we can refer to its unique instance by its name.\nThis is similar to Scala singleton objects.\n*/\nobject ObjectExample {\n    fun hello(): String {\n        return \"hello\"\n    }\n\n    override fun toString(): String {\n        return \"Hello, it's me, ${ObjectExample::class.simpleName}\"\n    }\n}\n\n\nfun useSingletonObject() {\n    println(ObjectExample.hello()) // => hello\n    // In Kotlin, \"Any\" is the root of the class hierarchy, just like \"Object\" is in Java\n    val someRef: Any = ObjectExample\n    println(someRef) // => Hello, it's me, ObjectExample\n}\n\n\n/* The not-null assertion operator (!!) converts any value to a non-null type and\nthrows an exception if the value is null.\n*/\nvar b: String? = \"abc\"\nval l = b!!.length\n\ndata class Counter(var value: Int) {\n    // overload Counter += Int\n    operator fun plusAssign(increment: Int) {\n        this.value += increment\n    }\n\n    // overload Counter++ and ++Counter\n    operator fun inc() = Counter(value + 1)\n\n    // overload Counter + Counter\n    operator fun plus(other: Counter) = Counter(this.value + other.value)\n\n    // overload Counter * Counter\n    operator fun times(other: Counter) = Counter(this.value * other.value)\n\n    // overload Counter * Int\n    operator fun times(value: Int) = Counter(this.value * value)\n\n    // overload Counter in Counter\n    operator fun contains(other: Counter) = other.value == this.value\n\n    // overload Counter[Int] = Int\n    operator fun set(index: Int, value: Int) {\n        this.value = index + value\n    }\n\n    // overload Counter instance invocation\n    operator fun invoke() = println(\"The value of the counter is $value\")\n\n}\n/* You can also overload operators through extension methods */\n// overload -Counter\noperator fun Counter.unaryMinus() = Counter(-this.value)\n\nfun operatorOverloadingDemo() {\n    var counter1 = Counter(0)\n    var counter2 = Counter(5)\n    counter1 += 7\n    println(counter1) // => Counter(value=7)\n    println(counter1 + counter2) // => Counter(value=12)\n    println(counter1 * counter2) // => Counter(value=35)\n    println(counter2 * 2) // => Counter(value=10)\n    println(counter1 in Counter(5)) // => false\n    println(counter1 in Counter(7)) // => true\n    counter1[26] = 10\n    println(counter1) // => Counter(value=36)\n    counter1() // => The value of the counter is 36\n    println(-counter2) // => Counter(value=-5)\n}\n```\n\n### Further Reading\n\n* [Kotlin tutorials](https://kotlinlang.org/docs/tutorials/)\n* [Try Kotlin in your browser](https://play.kotlinlang.org/)\n* [A list of Kotlin resources](http://kotlin.link/)"
