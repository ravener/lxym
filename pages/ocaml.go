
package pages

const Ocaml = "OCaml is a strictly evaluated functional language with some imperative\nfeatures.\n\nAlong with StandardML and its dialects it belongs to ML language family.\nF# is also heavily influenced by OCaml.\n\nJust like StandardML, OCaml features both an interpreter, that can be\nused interactively, and a compiler.\nThe interpreter binary is normally called \"ocaml\" and the compiler is \"ocamlopt\".\nThere is also a bytecode compiler, \"ocamlc\", but there are few reasons to use it.\n\nIt is strongly and statically typed, but instead of using manually written\ntype annotations, it infers types of expressions using Hindley-Milner algorithm.\nIt makes type annotations unnecessary in most cases, but can be a major\nsource of confusion for beginners.\n\nWhen you are in the top level loop, OCaml will print the inferred type\nafter you enter an expression.\n\n```\n# let inc x = x\t+ 1 ;;\nval inc : int -> int = <fun>\n# let a = 99 ;;\nval a : int = 99\n```\n\nFor a source file you can use \"ocamlc -i /path/to/file.ml\" command\nto print all names and type signatures.\n\n```\n$ cat sigtest.ml\nlet inc x = x + 1\nlet add x y = x + y\n\nlet a = 1\n\n$ ocamlc -i ./sigtest.ml\nval inc : int -> int\nval add : int -> int -> int\nval a : int\n```\n\nNote that type signatures of functions of multiple arguments are\nwritten in curried form. A function that takes multiple arguments can be\nrepresented as a composition of functions that take only one argument.\nThe \"f(x,y) = x + y\" function from the example above applied to\narguments 2 and 3 is equivalent to the \"f0(y) = 2 + y\" function applied to 3.\nHence the \"int -> int -> int\" signature.\n\n\n```ocaml\n(*** Comments ***)\n\n(* Comments are enclosed in (* and *). It's fine to nest comments. *)\n\n(* There are no single-line comments. *)\n\n\n(*** Variables and functions ***)\n\n(* Expressions can be separated by a double semicolon symbol, \";;\".\n   In many cases it's redundant, but in this tutorial we use it after\n   every expression for easy pasting into the interpreter shell.\n   Unnecessary use of expression separators in source code files\n   is often considered to be a bad style. *)\n\n(* Variable and function declarations use \"let\" keyword. *)\nlet x = 10 ;;\n\n(* OCaml allows single quote characters in identifiers.\n   Single quote doesn't have a special meaning in this case, it's often used\n   in cases when in other languages one would use names like \"foo_tmp\". *)\nlet foo = 1 ;;\nlet foo' = foo * 2 ;;\n\n(* Since OCaml compiler infers types automatically, you normally don't need to\n   specify argument types explicitly. However, you can do it if\n   you want or need to. *)\nlet inc_int (x: int) : int = x + 1 ;;\n\n(* One of the cases when explicit type annotations may be needed is\n   resolving ambiguity between two record types that have fields with\n   the same name. The alternative is to encapsulate those types in\n   modules, but both topics are a bit out of scope of this\n   tutorial. *)\n\n(* You need to mark recursive function definitions as such with \"rec\" keyword. *)\nlet rec factorial n =\n    if n = 0 then 1\n    else n * factorial (n-1)\n;;\n\n(* Function application usually doesn't need parentheses around arguments *)\nlet fact_5 = factorial 5 ;;\n\n(* ...unless the argument is an expression. *)\nlet fact_4 = factorial (5-1) ;;\nlet sqr2 = sqr (-2) ;;\n\n(* Every function must have at least one argument.\n   Since some functions naturally don't take any arguments, there's\n   \"unit\" type for it that has the only one value written as \"()\" *)\nlet print_hello () = print_endline \"hello world\" ;;\n\n(* Note that you must specify \"()\" as argument when calling it. *)\nprint_hello () ;;\n\n(* Calling a function with insufficient number of arguments\n   does not cause an error, it produces a new function. *)\nlet make_inc x y = x + y ;; (* make_inc is int -> int -> int *)\nlet inc_2 = make_inc 2 ;;   (* inc_2 is int -> int *)\ninc_2 3 ;; (* Evaluates to 5 *)\n\n(* You can use multiple expressions in function body.\n   The last expression becomes the return value. All other\n   expressions must be of the \"unit\" type.\n   This is useful when writing in imperative style, the simplest\n   form of it is inserting a debug print. *)\nlet print_and_return x =\n    print_endline (string_of_int x);\n    x\n;;\n\n(* Since OCaml is a functional language, it lacks \"procedures\".\n   Every function must return something. So functions that\n   do not really return anything and are called solely for their\n   side effects, like print_endline, return value of \"unit\" type. *)\n\n\n(* Definitions can be chained with \"let ... in\" construct.\n   This is roughly the same to assigning values to multiple\n   variables before using them in expressions in imperative\n   languages. *)\nlet x = 10 in\nlet y = 20 in\nx + y ;;\n\n(* Alternatively you can use \"let ... and ... in\" construct.\n   This is especially useful for mutually recursive functions,\n   with ordinary \"let .. in\" the compiler will complain about\n   unbound values. *)\nlet rec\n  is_even = function\n  | 0 -> true\n  | n -> is_odd (n-1)\nand\n  is_odd = function\n  | 0 -> false\n  | n -> is_even (n-1)\n;;\n\n(* Anonymous functions use the following syntax: *)\nlet my_lambda = fun x -> x * x ;;\n\n(*** Operators ***)\n\n(* There is little distinction between operators and functions.\n   Every operator can be called as a function. *)\n\n(+) 3 4  (* Same as 3 + 4 *)\n\n(* There's a number of built-in operators. One unusual feature is\n   that OCaml doesn't just refrain from any implicit conversions\n   between integers and floats, it also uses different operators\n   for floats. *)\n12 + 3 ;; (* Integer addition. *)\n12.0 +. 3.0 ;; (* Floating point addition. *)\n\n12 / 3 ;; (* Integer division. *)\n12.0 /. 3.0 ;; (* Floating point division. *)\n5 mod 2 ;; (* Remainder. *)\n\n(* Unary minus is a notable exception, it's polymorphic.\n   However, it also has \"pure\" integer and float forms. *)\n- 3 ;; (* Polymorphic, integer *)\n- 4.5 ;; (* Polymorphic, float *)\n~- 3 (* Integer only *)\n~- 3.4 (* Type error *)\n~-. 3.4 (* Float only *)\n\n(* You can define your own operators or redefine existing ones.\n   Unlike SML or Haskell, only selected symbols can be used\n   for operator names and first symbol defines associativity\n   and precedence rules. *)\nlet (+) a b = a - b ;; (* Surprise maintenance programmers. *)\n\n(* More useful: a reciprocal operator for floats.\n   Unary operators must start with \"~\". *)\nlet (~/) x = 1.0 /. x ;;\n~/4.0 (* = 0.25 *)\n\n\n(*** Built-in data structures ***)\n\n(* Lists are enclosed in square brackets, items are separated by\n   semicolons. *)\nlet my_list = [1; 2; 3] ;;\n\n(* Tuples are (optionally) enclosed in parentheses, items are separated\n   by commas. *)\nlet first_tuple = 3, 4 ;; (* Has type \"int * int\". *)\nlet second_tuple = (4, 5) ;;\n\n(* Corollary: if you try to separate list items by commas, you get a list\n   with a tuple inside, probably not what you want. *)\nlet bad_list = [1, 2] ;; (* Becomes [(1, 2)] *)\n\n(* You can access individual list items with the List.nth function. *)\nList.nth my_list 1 ;;\n\n(* There are higher-order functions for lists such as map and filter. *)\nList.map (fun x -> x * 2) [1; 2; 3] ;;\nList.filter (fun x -> x mod 2 = 0) [1; 2; 3; 4] ;;\n\n(* You can add an item to the beginning of a list with the \"::\" constructor\n   often referred to as \"cons\". *)\n1 :: [2; 3] ;; (* Gives [1; 2; 3] *)\n\n(* Arrays are enclosed in [| |] *)\nlet my_array = [| 1; 2; 3 |] ;;\n\n(* You can access array items like this: *)\nmy_array.(0) ;;\n\n\n(*** Strings and characters ***)\n\n(* Use double quotes for string literals. *)\nlet my_str = \"Hello world\" ;;\n\n(* Use single quotes for character literals. *)\nlet my_char = 'a' ;;\n\n(* Single and double quotes are not interchangeable. *)\nlet bad_str = 'syntax error' ;; (* Syntax error. *)\n\n(* This will give you a single character string, not a character. *)\nlet single_char_str = \"w\" ;;\n\n(* Strings can be concatenated with the \"^\" operator. *)\nlet some_str = \"hello\" ^ \"world\" ;;\n\n(* Strings are not arrays of characters.\n   You can't mix characters and strings in expressions.\n   You can convert a character to a string with \"String.make 1 my_char\".\n   There are more convenient functions for this purpose in additional\n   libraries such as Core.Std that may not be installed and/or loaded\n   by default. *)\nlet ocaml = (String.make 1 'O') ^ \"Caml\" ;;\n\n(* There is a printf function. *)\nPrintf.printf \"%d %s\" 99 \"bottles of beer\" ;;\n\n(* Unformatted read and write functions are there too. *)\nprint_string \"hello world\\n\" ;;\nprint_endline \"hello world\" ;;\nlet line = read_line () ;;\n\n\n(*** User-defined data types ***)\n\n(* You can define types with the \"type some_type =\" construct. Like in this\n   useless type alias: *)\ntype my_int = int ;;\n\n(* More interesting types include so called type constructors.\n   Constructors must start with a capital letter. *)\ntype ml = OCaml | StandardML ;;\nlet lang = OCaml ;;  (* Has type \"ml\". *)\n\n(* Type constructors don't need to be empty. *)\ntype my_number = PlusInfinity | MinusInfinity | Real of float ;;\nlet r0 = Real (-3.4) ;; (* Has type \"my_number\". *)\n\n(* Can be used to implement polymorphic arithmetics. *)\ntype number = Int of int | Float of float ;;\n\n(* Point on a plane, essentially a type-constrained tuple *)\ntype point2d = Point of float * float ;;\nlet my_point = Point (2.0, 3.0) ;;\n\n(* Types can be parameterized, like in this type for \"list of lists\n   of anything\". 'a can be substituted with any type. *)\ntype 'a list_of_lists = 'a list list ;;\ntype int_list_list = int list_of_lists ;;\n\n(* Types can also be recursive. Like in this type analogous to\n   built-in list of integers. *)\ntype my_int_list = EmptyList | IntList of int * my_int_list ;;\nlet l = IntList (1, EmptyList) ;;\n\n\n(*** Pattern matching ***)\n\n(* Pattern matching is somewhat similar to switch statement in imperative\n   languages, but offers a lot more expressive power.\n\n   Even though it may look complicated, it really boils down to matching\n   an argument against an exact value, a predicate, or a type constructor.\n   The type system is what makes it so powerful. *)\n\n(** Matching exact values.  **)\n\nlet is_zero x =\n    match x with\n    | 0 -> true\n    | _ -> false  (* The \"_\" pattern means \"anything else\". *)\n;;\n\n(* Alternatively, you can use the \"function\" keyword. *)\nlet is_one = function\n| 1 -> true\n| _ -> false\n;;\n\n(* Matching predicates, aka \"guarded pattern matching\". *)\nlet abs x =\n    match x with\n    | x when x < 0 -> -x\n    | _ -> x\n;;\n\nabs 5 ;; (* 5 *)\nabs (-5) (* 5 again *)\n\n(** Matching type constructors **)\n\ntype animal = Dog of string | Cat of string ;;\n\nlet say x =\n    match x with\n    | Dog x -> x ^ \" says woof\"\n    | Cat x -> x ^ \" says meow\"\n;;\n\nsay (Cat \"Fluffy\") ;; (* \"Fluffy says meow\". *)\n\n(** Traversing data structures with pattern matching **)\n\n(* Recursive types can be traversed with pattern matching easily.\n   Let's see how we can traverse a data structure of the built-in list type.\n   Even though the built-in cons (\"::\") looks like an infix operator,\n   it's actually a type constructor and can be matched like any other. *)\nlet rec sum_list l =\n    match l with\n    | [] -> 0\n    | head :: tail -> head + (sum_list tail)\n;;\n\nsum_list [1; 2; 3] ;; (* Evaluates to 6 *)\n\n(* Built-in syntax for cons obscures the structure a bit, so we'll make\n   our own list for demonstration. *)\n\ntype int_list = Nil | Cons of int * int_list ;;\nlet rec sum_int_list l =\n  match l with\n      | Nil -> 0\n      | Cons (head, tail) -> head + (sum_int_list tail)\n;;\n\nlet t = Cons (1, Cons (2, Cons (3, Nil))) ;;\nsum_int_list t ;;\n\n```\n\n## Further reading\n\n* Visit the official website to get the compiler and read the docs: <http://ocaml.org/>\n* Try interactive tutorials and a web-based interpreter by OCaml Pro: <http://try.ocamlpro.com/>"
