
package pages

const Qsharp = "Q# is a high-level domain-specific language which enables developers to write quantum algorithms. Q# programs can be executed on a quantum simulator running on a classical computer and (in future) on quantum computers.\n\n```C#\n// Single-line comments start with //\n\n\n/////////////////////////////////////\n// 1. Quantum data types and operators\n\n// The most important part of quantum programs is qubits. \n// In Q# type Qubit represents the qubits which can be used.\n// This will allocate an array of two new qubits as the variable qs.\nusing (qs = Qubit[2]) {\n\n    // The qubits have internal state that you cannot access to read or modify directly.\n    // You can inspect the current state of your quantum program \n    // if you're running it on a classical simulator.\n    // Note that this will not work on actual quantum hardware!\n    DumpMachine();\n\n    // If you want to change the state of a qubit\n    // you have to do this by applying quantum gates to the qubit.\n    H(q[0]);    // This changes the state of the first qubit \n                // from |0⟩ (the initial state of allocated qubits) \n                // to (|0⟩ + |1⟩) / sqrt(2).\n    // q[1] = |1⟩; - this does NOT work, you have to manipulate a qubit by using gates.\n\n    // You can apply multi-qubit gates to several qubits.\n    CNOT(qs[0], qs[1]);\n\n    // You can also apply a controlled version of a gate: \n    // a gate that is applied if all control qubits are in |1⟩ state.\n    // The first argument is an array of control qubits, \n    // the second argument is the target qubit.\n    Controlled Y([qs[0]], qs[1]); \n\n    // If you want to apply an anti-controlled gate \n    // (a gate that is applied if all control qubits are in |0⟩ state), \n    // you can use a library function.\n    ApplyControlledOnInt(0, X, [qs[0]], qs[1]);\n\n    // To read the information from the quantum system, you use measurements.\n    // Measurements return a value of Result data type: Zero or One.\n    // You can print measurement results as a classical value.\n    Message($\"Measured {M(qs[0])}, {M(qs[1])}\");\n}\n\n\n/////////////////////////////////////\n// 2. Classical data types and operators\n\n// Numbers in Q# can be stored in Int, BigInt or Double.\nlet i = 1;            // This defines an Int variable i equal to 1\nlet bi = 1L;          // This defines a BigInt variable bi equal to 1\nlet d = 1.0;          // This defines a Double variable d equal to 1\n\n// Arithmetic is done as expected, as long as the types are the same\nlet n = 2 * 10;                // = 20\n// Q# does not have implicit type cast, \n// so to perform arithmetic on values of different types, \n// you need to cast type explicitly\nlet nd = IntAsDouble(2) * 1.0; // = 20.0\n\n// Boolean type is called Bool\nlet trueBool = true;\nlet falseBool = false;\n\n// Logic operators work as expected\nlet andBool = true and false;\nlet orBool = true or false;\nlet notBool = not false;\n\n// Strings\nlet str = \"Hello World!\";\n\n// Equality is ==\nlet x = 10 == 15; // is false\n\n// Range is a sequence of integers and can be defined like: start..step..stop\nlet xi = 1..2..7; // Gives the sequence 1,3,5,7\n\n// Assigning new value to a variable:\n// by default all Q# variables are immutable;\n// if the variable was defined using let, you cannot reassign its value.\n\n// When you want to make a variable mutable, you have to declare it as such, \n// and use the set word to update value\nmutable xii = true;\nset xii = false;\n\n// You can create an array for any data type like this\nlet xiii = new Double[10];\n\n// Getting an element from an array \nlet xiv = xiii[8];\n\n// Assigning a new value to an array element\nmutable xv = new Double[10];\nset xv w/= 5 <- 1;\n\n\n/////////////////////////////////////\n// 3. Control flow\n\n// If structures work a little different than most languages\nif (a == 1) {\n    // ...\n} elif (a == 2) {\n    // ... \n} else {\n    // ...\n}\n\n// Foreach loops can be used to iterate over an array\nfor (qubit in qubits) {\n    X(qubit);\n}\n\n// Regular for loops can be used to iterate over a range of numbers\nfor (index in 0 .. Length(qubits) - 1) {\n    X(qubits[index]);\n}\n\n// While loops are restricted for use in classical context only\nmutable index = 0;\nwhile (index < 10) {\n    set index += 1;\n}\n\n// Quantum equivalent of a while loop is a repeat-until-success loop.\n// Because of the probabilistic nature of quantum computing sometimes\n// you want to repeat a certain sequence of operations \n// until a specific condition is achieved; you can use this loop to express this.\nrepeat {\n    // Your operation here\n}\nuntil (success criteria) // This could be a measurement to check if the state is reached\nfixup {\n    // Resetting to the initial conditions, if required\n}\n\n\n/////////////////////////////////////\n// 4. Putting it all together\n\n// Q# code is written in operations and functions\noperation ApplyXGate(source : Qubit) : Unit {\n    X(source);\n}\n\n// If the operation implements a unitary transformation, you can define \n// adjoint and controlled variants of it. \n// The easiest way to do that is to add \"is Adj + Ctl\" after Unit. \n// This will tell the compiler to generate the variants automatically.\noperation ApplyXGateCA (source : Qubit) : Unit is Adj + Ctl {\n    X(source);\n}\n\n// Now you can call Adjoint ApplyXGateCA and Controlled ApplyXGateCA.\n\n\n// To run Q# code, you can put @EntryPoint() before the operation you want to run first\n@EntryPoint()\noperation XGateDemo() : Unit {\n    using (q = Qubit()) {\n        ApplyXGate(q);\n    }\n}\n\n// Here is a simple example: a quantum random number generator. \n// We will generate a classical array of random bits using quantum code.\n@EntryPoint()\noperation QRNGDemo() : Unit {\n    mutable bits = new Int[5];                // Array we'll use to store bits\n    using (q = Qubit()) {                     // Allocate a qubit\n        for (i in 0 .. 4) {                   // Generate each bit independently\n            H(q);                             // Hadamard gate sets equal superposition\n            let result = M(q);                // Measure qubit gets 0|1 with 50/50 prob\n            let bit = result == Zero ? 0 | 1; // Convert measurement result to integer\n            set bits w/= i <- bit;            // Write generated bit to an array\n        }\n    }\n    Message($\"{bits}\");                       // Print the result\n}\n```\n\n\n## Further Reading\n\nThe [Quantum Katas][1] offer great self-paced tutorials and programming exercises to learn quantum computing and Q#. \n\n[Q# Documentation][2] is official Q# documentation, including language reference and user guides.\n\n[1]: https://github.com/microsoft/QuantumKatas\n[2]: https://docs.microsoft.com/quantum/"
