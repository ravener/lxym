
package pages

const Elm = "Elm is a functional reactive programming language that compiles to (client-side)\nJavaScript. Elm is statically typed, meaning that the compiler catches most\nerrors immediately and provides a clear and understandable error message. Elm is\ngreat for designing user interfaces and games for the web.\n\n\n```haskell\n-- Single line comments start with two dashes.\n{- Multiline comments can be enclosed in a block like this.\n{- They can be nested. -}\n-}\n\n{-- The Basics --}\n\n-- Arithmetic\n1 + 1 -- 2\n8 - 1 -- 7\n10 * 2 -- 20\n\n-- Every number literal without a decimal point can be either an Int or a Float.\n33 / 2 -- 16.5 with floating point division\n33 // 2 -- 16 with integer division\n\n-- Exponents\n5 ^ 2 -- 25\n\n-- Booleans\nnot True -- False\nnot False -- True\n1 == 1 -- True\n1 /= 1 -- False\n1 < 10 -- True\n\n-- Strings and characters\n\"This is a string because it uses double quotes.\"\n'a' -- characters in single quotes\n\n-- Strings can be appended.\n\"Hello \" ++ \"world!\" -- \"Hello world!\"\n\n{-- Lists, Tuples, and Records --}\n\n-- Every element in a list must have the same type.\n[\"the\", \"quick\", \"brown\", \"fox\"]\n[1, 2, 3, 4, 5]\n-- The second example can also be written with two dots.\nList.range 1 5\n\n-- Append lists just like strings.\nList.range 1 5 ++ List.range 6 10 == List.range 1 10 -- True\n\n-- To add one item, use \"cons\".\n0 :: List.range 1 5 -- [0, 1, 2, 3, 4, 5]\n\n-- The head and tail of a list are returned as a Maybe. Instead of checking\n-- every value to see if it's null, you deal with missing values explicitly.\nList.head (List.range 1 5) -- Just 1\nList.tail (List.range 1 5) -- Just [2, 3, 4, 5]\nList.head [] -- Nothing\n-- List.functionName means the function lives in the List module.\n\n-- Every element in a tuple can be a different type, but a tuple has a\n-- fixed length.\n(\"elm\", 42)\n\n-- Access the elements of a pair with the first and second functions.\n-- (This is a shortcut; we'll come to the \"real way\" in a bit.)\nTuple.first (\"elm\", 42) -- \"elm\"\nTuple.second (\"elm\", 42) -- 42\n\n-- The empty tuple, or \"unit\", is sometimes used as a placeholder.\n-- It is the only value of its type, also called \"Unit\".\n()\n\n-- Records are like tuples but the fields have names. The order of fields\n-- doesn't matter. Notice that record values use equals signs, not colons.\n{ x = 3, y = 7 }\n\n-- Access a field with a dot and the field name.\n{ x = 3, y = 7 }.x -- 3\n\n-- Or with an accessor function, which is a dot and the field name on its own.\n.y { x = 3, y = 7 } -- 7\n\n-- Update the fields of a record. (It must have the fields already.)\n{ person |\n  name = \"George\" }\n\n-- Update multiple fields at once, using the current values.\n{ particle |\n  position = particle.position + particle.velocity,\n  velocity = particle.velocity + particle.acceleration }\n\n{-- Control Flow --}\n\n-- If statements always have an else, and the branches must be the same type.\nif powerLevel > 9000 then\n  \"WHOA!\"\nelse\n  \"meh\"\n\n-- If statements can be chained.\nif n < 0 then\n  \"n is negative\"\nelse if n > 0 then\n  \"n is positive\"\nelse\n  \"n is zero\"\n\n-- Use case statements to pattern match on different possibilities.\ncase aList of\n  [] -> \"matches the empty list\"\n  [x]-> \"matches a list of exactly one item, \" ++ toString x\n  x::xs -> \"matches a list of at least one item whose head is \" ++ toString x\n-- Pattern matches go in order. If we put [x] last, it would never match because\n-- x::xs also matches (xs would be the empty list). Matches do not \"fall through\".\n-- The compiler will alert you to missing or extra cases.\n\n-- Pattern match on a Maybe.\ncase List.head aList of\n  Just x -> \"The head is \" ++ toString x\n  Nothing -> \"The list was empty.\"\n\n{-- Functions --}\n\n-- Elm's syntax for functions is very minimal, relying mostly on whitespace\n-- rather than parentheses and curly brackets. There is no \"return\" keyword.\n\n-- Define a function with its name, arguments, an equals sign, and the body.\nmultiply a b =\n  a * b\n\n-- Apply (call) a function by passing it arguments (no commas necessary).\nmultiply 7 6 -- 42\n\n-- Partially apply a function by passing only some of its arguments.\n-- Then give that function a new name.\ndouble =\n  multiply 2\n\n-- Constants are similar, except there are no arguments.\nanswer =\n  42\n\n-- Pass functions as arguments to other functions.\nList.map double (List.range 1 4) -- [2, 4, 6, 8]\n\n-- Or write an anonymous function.\nList.map (\\a -> a * 2) (List.range 1 4) -- [2, 4, 6, 8]\n\n-- You can pattern match in function definitions when there's only one case.\n-- This function takes one tuple rather than two arguments.\n-- This is the way you'll usually unpack/extract values from tuples.\narea (width, height) =\n  width * height\n\narea (6, 7) -- 42\n\n-- Use curly brackets to pattern match record field names.\n-- Use let to define intermediate values.\nvolume {width, height, depth} =\n  let\n    area = width * height\n  in\n    area * depth\n\nvolume { width = 3, height = 2, depth = 7 } -- 42\n\n-- Functions can be recursive.\nfib n =\n  if n < 2 then\n    1\n  else\n    fib (n - 1) + fib (n - 2)\n\nList.map fib (List.range 0 8) -- [1, 1, 2, 3, 5, 8, 13, 21, 34]\n\n-- Another recursive function (use List.length in real code).\nlistLength aList =\n  case aList of\n    [] -> 0\n    x::xs -> 1 + listLength xs\n\n-- Function calls happen before any infix operator. Parens indicate precedence.\ncos (degrees 30) ^ 2 + sin (degrees 30) ^ 2 -- 1\n-- First degrees is applied to 30, then the result is passed to the trig\n-- functions, which is then squared, and the addition happens last.\n\n{-- Types and Type Annotations --}\n\n-- The compiler will infer the type of every value in your program.\n-- Types are always uppercase. Read x : T as \"x has type T\".\n-- Some common types, which you might see in Elm's REPL.\n5 : Int\n6.7 : Float\n\"hello\" : String\nTrue : Bool\n\n-- Functions have types too. Read -> as \"goes to\". Think of the rightmost type\n-- as the type of the return value, and the others as arguments.\nnot : Bool -> Bool\nround : Float -> Int\n\n-- When you define a value, it's good practice to write its type above it.\n-- The annotation is a form of documentation, which is verified by the compiler.\ndouble : Int -> Int\ndouble x = x * 2\n\n-- Function arguments are passed in parentheses.\n-- Lowercase types are type variables: they can be any type, as long as each\n-- call is consistent.\nList.map : (a -> b) -> List a -> List b\n-- \"List dot map has type a-goes-to-b, goes to list of a, goes to list of b.\"\n\n-- There are three special lowercase types: number, comparable, and appendable.\n-- Numbers allow you to use arithmetic on Ints and Floats.\n-- Comparable allows you to order numbers and strings, like a < b.\n-- Appendable things can be combined with a ++ b.\n\n{-- Type Aliases and Union Types --}\n\n-- When you write a record or tuple, its type already exists.\n-- (Notice that record types use colon and record values use equals.)\norigin : { x : Float, y : Float, z : Float }\norigin =\n  { x = 0, y = 0, z = 0 }\n\n-- You can give existing types a nice name with a type alias.\ntype alias Point3D =\n  { x : Float, y : Float, z : Float }\n\n-- If you alias a record, you can use the name as a constructor function.\notherOrigin : Point3D\notherOrigin =\n  Point3D 0 0 0\n\n-- But it's still the same type, so you can equate them.\norigin == otherOrigin -- True\n\n-- By contrast, defining a union type creates a type that didn't exist before.\n-- A union type is so called because it can be one of many possibilities.\n-- Each of the possibilities is represented as a \"tag\".\ntype Direction =\n  North | South | East | West\n\n-- Tags can carry other values of known type. This can work recursively.\ntype IntTree =\n  Leaf | Node Int IntTree IntTree\n-- \"Leaf\" and \"Node\" are the tags. Everything following a tag is a type.\n\n-- Tags can be used as values or functions.\nroot : IntTree\nroot =\n  Node 7 Leaf Leaf\n\n-- Union types (and type aliases) can use type variables.\ntype Tree a =\n  Leaf | Node a (Tree a) (Tree a)\n-- \"The type tree-of-a is a leaf, or a node of a, tree-of-a, and tree-of-a.\"\n\n-- Pattern match union tags. The uppercase tags will be matched exactly. The\n-- lowercase variables will match anything. Underscore also matches anything,\n-- but signifies that you aren't using it.\nleftmostElement : Tree a -> Maybe a\nleftmostElement tree =\n  case tree of\n    Leaf -> Nothing\n    Node x Leaf _ -> Just x\n    Node _ subtree _ -> leftmostElement subtree\n\n-- That's pretty much it for the language itself. Now let's see how to organize\n-- and run your code.\n\n{-- Modules and Imports --}\n\n-- The core libraries are organized into modules, as are any third-party\n-- libraries you may use. For large projects, you can define your own modules.\n\n-- Put this at the top of the file. If omitted, you're in Main.\nmodule Name where\n\n-- By default, everything is exported. You can specify exports explicitly.\nmodule Name (MyType, myValue) where\n\n-- One common pattern is to export a union type but not its tags. This is known\n-- as an \"opaque type\", and is frequently used in libraries.\n\n-- Import code from other modules to use it in this one.\n-- Places Dict in scope, so you can call Dict.insert.\nimport Dict\n\n-- Imports the Dict module and the Dict type, so your annotations don't have to\n-- say Dict.Dict. You can still use Dict.insert.\nimport Dict exposing (Dict)\n\n-- Rename an import.\nimport Graphics.Collage as C\n\n{-- Ports --}\n\n-- A port indicates that you will be communicating with the outside world.\n-- Ports are only allowed in the Main module.\n\n-- An incoming port is just a type signature.\nport clientID : Int\n\n-- An outgoing port has a definition.\nport clientOrders : List String\nport clientOrders = [\"Books\", \"Groceries\", \"Furniture\"]\n\n-- We won't go into the details, but you set up callbacks in JavaScript to send\n-- on incoming ports and receive on outgoing ports.\n\n{-- Command Line Tools --}\n\n-- Compile a file.\n$ elm make MyFile.elm\n\n-- The first time you do this, Elm will install the core libraries and create\n-- elm-package.json, where information about your project is kept.\n\n-- The reactor is a server that compiles and runs your files.\n-- Click the wrench next to file names to enter the time-travelling debugger!\n$ elm reactor\n\n-- Experiment with simple expressions in a Read-Eval-Print Loop.\n$ elm repl\n\n-- Packages are identified by GitHub username and repo name.\n-- Install a new package, and record it in elm-package.json.\n$ elm package install elm-lang/html\n\n-- See what changed between versions of a package.\n$ elm package diff elm-lang/html 1.1.0 2.0.0\n-- Elm's package manager enforces semantic versioning, so minor version bumps\n-- will never break your build!\n```\n\nThe Elm language is surprisingly small. You can now look through almost any Elm\nsource code and have a rough idea of what is going on. However, the possibilities\nfor error-resistant and easy-to-refactor code are endless!\n\nHere are some useful resources.\n\n* The [Elm website](http://elm-lang.org/). Includes:\n  * Links to the [installers](http://elm-lang.org/install)\n  * [Documentation guides](http://elm-lang.org/docs), including the [syntax reference](http://elm-lang.org/docs/syntax)\n  * Lots of helpful [examples](http://elm-lang.org/examples)\n\n* Documentation for [Elm's core libraries](http://package.elm-lang.org/packages/elm-lang/core/latest/). Take note of:\n  * [Basics](http://package.elm-lang.org/packages/elm-lang/core/latest/Basics), which is imported by default\n  * [Maybe](http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe) and its cousin [Result](http://package.elm-lang.org/packages/elm-lang/core/latest/Result), commonly used for missing values or error handling\n  * Data structures like [List](http://package.elm-lang.org/packages/elm-lang/core/latest/List), [Array](http://package.elm-lang.org/packages/elm-lang/core/latest/Array), [Dict](http://package.elm-lang.org/packages/elm-lang/core/latest/Dict), and [Set](http://package.elm-lang.org/packages/elm-lang/core/latest/Set)\n  * JSON [encoding](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Encode) and [decoding](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode)\n\n* [The Elm Architecture](https://github.com/evancz/elm-architecture-tutorial#the-elm-architecture). An essay by Elm's creator with examples on how to organize code into components.\n\n* The [Elm mailing list](https://groups.google.com/forum/#!forum/elm-discuss). Everyone is friendly and helpful.\n\n* [Scope in Elm](https://github.com/elm-guides/elm-for-js/blob/master/Scope.md#scope-in-elm) and [How to Read a Type Annotation](https://github.com/elm-guides/elm-for-js/blob/master/How%20to%20Read%20a%20Type%20Annotation.md#how-to-read-a-type-annotation). More community guides on the basics of Elm, written for JavaScript developers.\n\nGo out and write some Elm!"
