
package pages

const Powershell = "PowerShell is the Windows scripting language and configuration management\nframework from Microsoft built on the .NET Framework. Windows 7 and up ship\nwith PowerShell.  \nNearly all examples below can be a part of a shell script or executed directly\nin the shell.\n\nA key difference with Bash is that it is mostly objects that you manipulate\nrather than plain text. After years of evolving, it resembles Python a bit.\n\n[Read more here.](https://docs.microsoft.com/powershell/scripting/overview)\n\nPowershell as a Language:\n\n```powershell\n\n# Single line comments start with a number symbol.\n\n<#\n  Multi-line comments\n  like so\n#>\n\n\n####################################################\n## 1. Primitive Datatypes and Operators\n####################################################\n\n# Numbers\n3 # => 3\n\n# Math\n1 + 1   # => 2\n8 - 1   # => 7\n10 * 2  # => 20\n35 / 5  # => 7.0\n\n# Powershell uses banker's rounding,\n# meaning [int]1.5 would round to 2 but so would [int]2.5\n# Division always returns a float. \n# You must cast result to [int] to round.\n[int]5 / [int]3       # => 1.66666666666667\n[int]-5 / [int]3      # => -1.66666666666667\n5.0 / 3.0   # => 1.66666666666667\n-5.0 / 3.0  # => -1.66666666666667\n[int]$result = 5 / 3 \n$result # => 2\n\n# Modulo operation\n7 % 3  # => 1\n\n# Exponentiation requires longform or the built-in [Math] class.\n[Math]::Pow(2,3)  # => 8\n\n# Enforce order of operations with parentheses.\n1 + 3 * 2  # => 7\n(1 + 3) * 2  # => 8\n\n# Boolean values are primitives (Note: the $)\n$True  # => True\n$False  # => False\n\n# negate with !\n!$True   # => False\n!$False  # => True\n\n# Boolean Operators\n# Note \"-and\" and \"-or\" usage\n$True -and $False  # => False\n$False -or $True   # => True\n\n# True and False are actually 1 and 0 but only support limited arithmetic.\n# However, casting the bool to int resolves this.\n$True + $True # => 2\n$True * 8    # => '[System.Boolean] * [System.Int32]' is undefined\n[int]$True * 8 # => 8\n$False - 5   # => -5\n\n# Comparison operators look at the numerical value of True and False.\n0 -eq $False  # => True\n1 -eq $True   # => True\n2 -eq $True   # => False\n-5 -ne $False # => True\n\n# Using boolean logical operators on ints casts to booleans for evaluation.\n# but their non-cast value is returned\n# Don't mix up with bool(ints) and bitwise -band/-bor\n[bool](0)     # => False\n[bool](4)     # => True\n[bool](-6)    # => True\n0 -band 2     # => 0\n-5 -bor 0     # => -5\n\n# Equality is -eq (equals)\n1 -eq 1  # => True\n2 -eq 1  # => False\n\n# Inequality is -ne (notequals)\n1 -ne 1  # => False\n2 -ne 1  # => True\n\n# More comparisons\n1 -lt 10  # => True\n1 -gt 10  # => False\n2 -le 2  # => True\n2 -ge 2  # => True\n\n# Seeing whether a value is in a range\n1 -lt 2 -and 2 -lt 3  # => True\n2 -lt 3 -and 3 -lt 2  # => False\n\n# (-is vs. -eq) -is checks if two objects are the same type.\n# -eq checks if the objects have the same values.\n# Note: we called '[Math]' from .NET previously without the preceeding\n# namespaces. We can do the same with [Collections.ArrayList] if preferred.\n[System.Collections.ArrayList]$a = @()  # Point a at a new list\n$a = (1,2,3,4)\n$b = $a                                 # => Point b at what a is pointing to\n$b -is $a.GetType()                     # => True, a and b equal same type\n$b -eq $a                               # => True, a and b values are equal\n[System.Collections.Hashtable]$b = @{}  # => Point a at a new hash table\n$b = @{'one' = 1 \n       'two' = 2}\n$b -is $a.GetType()                     # => False, a and b types not equal\n\n# Strings are created with \" or ' but \" is required for string interpolation\n\"This is a string.\"\n'This is also a string.'\n\n# Strings can be added too! But try not to do this.\n\"Hello \" + \"world!\"  # => \"Hello world!\"\n\n# A string can be treated like a list of characters\n\"Hello world!\"[0]  # => 'H'\n\n# You can find the length of a string\n(\"This is a string\").Length  # => 16\n\n# You can also format using f-strings or formatted string literals.\n$name = \"Steve\"\n$age = 22\n\"He said his name is $name.\" \n# => \"He said his name is Steve\"\n\"{0} said he is {1} years old.\" -f $name, $age \n# => \"Steve said he is 22 years old\"\n\"$name's name is $($name.Length) characters long.\" \n# => \"Steve's name is 5 characters long.\"\n\n# Escape Characters in Powershell\n# Many languages use the '\\', but Windows uses this character for \n# file paths. Powershell thus uses '`' to escape characters\n# Take caution when working with files, as '`' is a\n# valid character in NTFS filenames.\n\"Showing`nEscape Chars\" # => new line between Showing and Escape\n\"Making`tTables`tWith`tTabs\" # => Format things with tabs\n\n# Negate pound sign to prevent comment\n# Note that the function of '#' is removed, but '#' is still present\n`#Get-Process # => Fail: not a recognized cmdlet\n\n# $null is not an object\n$null  # => None\n\n# $null, 0, and empty strings and arrays all evaluate to False.\n# All other values are True\nfunction Test-Value ($value) {\n  if ($value) {\n    Write-Output 'True'\n  }\n  else {\n    Write-Output 'False'\n  }\n}\n\nTest-Value ($null) # => False\nTest-Value (0)     # => False\nTest-Value (\"\")    # => False\nTest-Value []      # => True \n# *[] calls .NET class; creates '[]' string when passed to function\nTest-Value ({})    # => True\nTest-Value @()     # => False\n\n\n####################################################\n## 2. Variables and Collections\n####################################################\n\n# Powershell uses the \"Write-Output\" function to print\nWrite-Output \"I'm Posh. Nice to meet you!\"  # => I'm Posh. Nice to meet you!\n\n# Simple way to get input data from console\n$userInput = Read-Host \"Enter some data: \" # Returns the data as a string\n\n# There are no declarations, only assignments.\n# Convention is to use camelCase or PascalCase, whatever your team uses.\n$someVariable = 5\n$someVariable  # => 5\n\n# Accessing a previously unassigned variable does not throw exception.\n# The value is $null by default\n\n# Ternary Operators exist in Powershell 7 and up\n0 ? 'yes' : 'no'  # => no\n\n\n# The default array object in Powershell is an fixed length array.\n$defaultArray = \"thing\",\"thing2\",\"thing3\"\n# you can add objects with '+=', but cannot remove objects.\n$defaultArray.Add(\"thing4\") # => Exception \"Collection was of a fixed size.\"\n# To have a more workable array, you'll want the .NET [ArrayList] class\n# It is also worth noting that ArrayLists are significantly faster\n\n# ArrayLists store sequences\n[System.Collections.ArrayList]$array = @()\n# You can start with a prefilled ArrayList\n[System.Collections.ArrayList]$otherArray = @(4, 5, 6)\n\n# Add to the end of a list with 'Add' (Note: produces output, append to $null)\n$array.Add(1) > $null    # $array is now [1]\n$array.Add(2) > $null    # $array is now [1, 2]\n$array.Add(4) > $null    # $array is now [1, 2, 4]\n$array.Add(3) > $null    # $array is now [1, 2, 4, 3]\n# Remove from end with index of count of objects-1; array index starts at 0\n$array.RemoveAt($array.Count-1) # => 3 and array is now [1, 2, 4]\n# Let's put it back\n$array.Add(3) > $null   # array is now [1, 2, 4, 3] again.\n\n# Access a list like you would any array\n$array[0]   # => 1\n# Look at the last element\n$array[-1]  # => 3\n\n# Looking out of bounds returns nothing\n$array[4]  # blank line returned\n\n# You can look at ranges with slice syntax.\n# The start index is included, the end index is not\n# (It's a closed/open range for you mathy types.)\n$array[1..3]   # Return array from index 1 to 3 => [2, 4]\n$array[2..-1]    # Return array starting from index 2 => [4, 3]\n$array[0..3]    # Return array from beginning until index 3  => [1, 2, 4]\n$array[0..2]   # Return array selecting every second entry => [1, 4]\n$array.Reverse()  # mutates array to reverse order => [3, 4, 2, 1]\n# Use any combination of these to make advanced slices\n\n# Remove arbitrary elements from a array with \"del\"\n$array.Remove($array[2])  # $array is now [1, 2, 3]\n\n# Insert an element at a specific index\n$array.Insert(1, 2)  # $array is now [1, 2, 3] again\n\n# Get the index of the first item found matching the argument\n$array.IndexOf(2)  # => 1\n$array.IndexOf(6)  # Returns -1 as \"outside array\" \n\n# You can add arrays\n# Note: values for $array and for $otherArray are not modified.\n$array + $otherArray  # => [1, 2, 3, 4, 5, 6]\n\n# Concatenate arrays with \"AddRange()\"\n$array.AddRange($otherArray)  # Now $array is [1, 2, 3, 4, 5, 6]\n\n# Check for existence in a array with \"in\"\n1 -in $array  # => True\n\n# Examine length with \"Count\" (Note: \"Length\" on arrayList = each items length)\n$array.Count  # => 6\n\n\n# Tuples are like arrays but are immutable.\n# To use Tuples in powershell, you must use the .NET tuple class.\n$tuple = [System.Tuple]::Create(1, 2, 3)\n$tuple.Item(0)      # => 1\n$tuple.Item(0) = 3  # Raises a TypeError\n\n# You can do some of the array methods on tuples, but they are limited.\n$tuple.Length       # => 3\n$tuple + (4, 5, 6)  # => Exception\n$tuple[0..2]        # => $null\n2 -in $tuple        # => False\n\n\n# Hashtables store mappings from keys to values, similar to Dictionaries.\n$emptyHash = @{}\n# Here is a prefilled dictionary\n$filledHash = @{\"one\"= 1 \n                \"two\"= 2 \n                \"three\"= 3}\n\n# Look up values with []\n$filledHash[\"one\"]  # => 1\n\n# Get all keys as an iterable with \".Keys\".\n# items maintain the order at which they are inserted into the dictionary.\n$filledHash.Keys  # => [\"one\", \"two\", \"three\"]\n\n# Get all values as an iterable with \".Values\".\n$filledHash.Values  # => [1, 2, 3]\n\n# Check for existence of keys or values in a hash with \"-in\"\n\"one\" -in $filledHash.Keys  # => True\n1 -in $filledHash.Values    # => False\n\n# Looking up a non-existing key returns $null\n$filledHash[\"four\"]  # $null\n\n# Adding to a dictionary\n$filledHash.Add(\"five\",5)  # $filledHash[\"five\"] is set to 5\n$filledHash.Add(\"five\",6)  # exception \"Item with key \"five\" has already been added\"\n$filledHash[\"four\"] = 4 # $filledHash[\"four\"] is set to 4, running again does nothing\n\n# Remove keys from a dictionary with del\n$filledHash.Remove(\"one\") # Removes the key \"one\" from filled dict\n\n\n####################################################\n## 3. Control Flow and Iterables\n####################################################\n\n# Let's just make a variable\n$someVar = 5\n\n# Here is an if statement.\n# This prints \"$someVar is smaller than 10\"\nif ($someVar -gt 10) {\n    Write-Output \"$someVar is bigger than 10.\"\n}\nelseif ($someVar -lt 10) {    # This elseif clause is optional.\n    Write-Output \"$someVar is smaller than 10.\"\n}\nelse {                        # This is optional too.\n    Write-Output \"$someVar is indeed 10.\"\n}\n\n\n<#\nForeach loops iterate over arrays\nprints:\n    dog is a mammal\n    cat is a mammal\n    mouse is a mammal\n#>\nforeach ($animal in (\"dog\", \"cat\", \"mouse\")) {\n    # You can use -f to interpolate formatted strings\n    \"{0} is a mammal\" -f $animal\n}\n\n<#\nFor loops iterate over arrays and you can specify indices\nprints:\n   0 a\n   1 b\n   2 c\n   3 d\n   4 e\n   5 f\n   6 g\n   7 h\n#>\n$letters = ('a','b','c','d','e','f','g','h')\nfor($i=0; $i -le $letters.Count-1; $i++){\n    Write-Host $i, $letters[$i]\n}\n\n<#\nWhile loops go until a condition is no longer met.\nprints:\n    0\n    1\n    2\n    3\n#>\n$x = 0\nwhile ($x -lt 4) {\n    Write-Output $x\n    $x += 1  # Shorthand for x = x + 1\n}\n\n# Switch statements are more powerful compared to most languages\n$val = \"20\"\nswitch($val) {\n  { $_ -eq 42 }           { \"The answer equals 42\"; break }\n  '20'                    { \"Exactly 20\"; break }\n  { $_ -like 's*' }       { \"Case insensitive\"; break }\n  { $_ -clike 's*'}       { \"clike, ceq, cne for case sensitive\"; break }\n  { $_ -notmatch '^.*$'}  { \"Regex matching. cnotmatch, cnotlike, ...\"; break }\n  default                 { \"Others\" }\n}\n\n# Handle exceptions with a try/catch block\ntry {\n    # Use \"throw\" to raise an error\n    throw \"This is an error\"\n}\ncatch {\n    Write-Output $Error.ExceptionMessage\n}\nfinally {\n    Write-Output \"We can clean up resources here\"\n}\n\n\n# Writing to a file\n$contents = @{\"aa\"= 12 \n             \"bb\"= 21}\n$contents | Export-CSV \"$env:HOMEDRIVE\\file.csv\" # writes to a file\n\n$contents = \"test string here\"\n$contents | Out-File \"$env:HOMEDRIVE\\file.txt\" # writes to another file\n\n# Read file contents and convert to json\nGet-Content \"$env:HOMEDRIVE\\file.csv\" | ConvertTo-Json\n\n\n####################################################\n## 4. Functions\n####################################################\n\n# Use \"function\" to create new functions\n# Keep the Verb-Noun naming convention for functions\nfunction Add-Numbers {\n $args[0] + $args[1]\n}\n\nAdd-Numbers 1 2 # => 3\n\n# Calling functions with parameters\nfunction Add-ParamNumbers {\n param( [int]$firstNumber, [int]$secondNumber )\n $firstNumber + $secondNumber\n}\n\nAdd-ParamNumbers -FirstNumber 1 -SecondNumber 2 # => 3 \n\n# Functions with named parameters, parameter attributes, parsable documentation\n<#\n.SYNOPSIS\nSetup a new website\n.DESCRIPTION\nCreates everything your new website needs for much win\n.PARAMETER siteName\nThe name for the new website\n.EXAMPLE\nNew-Website -Name FancySite -Po 5000\nNew-Website SiteWithDefaultPort\nNew-Website siteName 2000 # ERROR! Port argument could not be validated\n('name1','name2') | New-Website -Verbose\n#>\nfunction New-Website() {\n    [CmdletBinding()]\n    param (\n        [Parameter(ValueFromPipeline=$true, Mandatory=$true)]\n        [Alias('name')]\n        [string]$siteName,\n        [ValidateSet(3000,5000,8000)]\n        [int]$port = 3000\n    )\n    BEGIN { Write-Output 'Creating new website(s)' }\n    PROCESS { Write-Output \"name: $siteName, port: $port\" }\n    END { Write-Output 'Website(s) created' }\n}\n\n\n####################################################\n## 5. Modules\n####################################################\n\n# You can import modules and install modules\n# The Install-Module is similar to pip or npm, pulls from Powershell Gallery\nInstall-Module dbaTools\nImport-Module dbaTools\n\n$query = \"SELECT * FROM dbo.sometable\"\n$queryParams = @{\n    SqlInstance = 'testInstance'\n    Database    = 'testDatabase'\n    Query       = $query\n}\nInvoke-DbaQuery @queryParams\n\n# You can get specific functions from a module\nImport-Module -Function Invoke-DbaQuery\n\n\n# Powershell modules are just ordinary Posh files. You\n# can write your own, and import them. The name of the\n# module is the same as the name of the file.\n\n# You can find out which functions and attributes\n# are defined in a module.\nGet-Command -module dbaTools\nGet-Help dbaTools -Full\n\n\n####################################################\n## 6. Classes\n####################################################\n\n# We use the \"class\" statement to create a class\nclass Instrument {\n    [string]$Type\n    [string]$Family\n}\n\n$instrument = [Instrument]::new()\n$instrument.Type = \"String Instrument\"\n$instrument.Family = \"Plucked String\"\n\n$instrument\n\n<# Output:\nType              Family        \n----              ------        \nString Instrument Plucked String\n#>\n\n\n####################################################\n## 6.1 Inheritance\n####################################################\n\n# Inheritance allows new child classes to be defined that inherit \n# methods and variables from their parent class.\n\nclass Guitar : Instrument\n{\n    [string]$Brand\n    [string]$SubType\n    [string]$ModelType\n    [string]$ModelNumber\n}\n\n$myGuitar = [Guitar]::new()\n$myGuitar.Brand       = \"Taylor\"\n$myGuitar.SubType     = \"Acoustic\"\n$myGuitar.ModelType   = \"Presentation\"\n$myGuitar.ModelNumber = \"PS14ce Blackwood\"\n\n$myGuitar.GetType()\n\n<#\nIsPublic IsSerial Name                                     BaseType                                               \n-------- -------- ----                                     --------                                               \nTrue     False    Guitar                                   Instrument  \n#>\n\n\n####################################################\n## 7. Advanced\n####################################################\n\n# The powershell pipeline allows things like High-Order Functions.\n\n# Group-Object is a handy cmdlet that does incredible things.\n# It works much like a GROUP BY in SQL.\n\n<#\n The following will get all the running processes,\n group them by Name,\n and tell us how many instances of each process we have running.\n Tip: Chrome and svcHost are usually big numbers in this regard.\n#>\nGet-Process | Foreach-Object ProcessName | Group-Object\n\n# Useful pipeline examples are iteration and filtering.\n1..10 | ForEach-Object { \"Loop number $PSITEM\" }\n1..10 | Where-Object { $PSITEM -gt 5 } | ConvertTo-Json\n\n# A notable pitfall of the pipeline is it's performance when\n# compared with other options.\n# Additionally, raw bytes are not passed through the pipeline,\n# so passing an image causes some issues.\n# See more on that in the link at the bottom.\n\n<#\n Asynchronous functions exist in the form of jobs.\n Typically a procedural language,\n Powershell can operate non-blocking functions when invoked as Jobs.\n#>\n\n# This function is known to be non-optimized, and therefore slow.\n$installedApps = Get-CimInstance -ClassName Win32_Product\n\n# If we had a script, it would hang at this func for a period of time.\n$scriptBlock = {Get-CimInstance -ClassName Win32_Product}\nStart-Job -ScriptBlock $scriptBlock\n\n# This will start a background job that runs the command.\n# You can then obtain the status of jobs and their returned results.\n$allJobs = Get-Job\n$jobResponse = Get-Job | Receive-Job\n\n\n# Math is built in to powershell and has many functions.\n$r=2\n$pi=[math]::pi\n$r2=[math]::pow( $r, 2 )\n$area = $pi*$r2\n$area\n\n# To see all possibilities, check the members.\n[System.Math] | Get-Member -Static -MemberType All\n\n\n<#\n This is a silly one:\n You may one day be asked to create a func that could take $start and $end\n and reverse anything in an array within the given range\n based on an arbitrary array without mutating the original array.\n Let's see one way to do that and introduce another data structure.\n#>\n\n$targetArray = 'a','b','c','d','e','f','g','h','i','j','k','l','m'\n\nfunction Format-Range ($start, $end, $array) {\n    [System.Collections.ArrayList]$firstSectionArray = @()\n    [System.Collections.ArrayList]$secondSectionArray = @()\n    [System.Collections.Stack]$stack = @()\n    for ($index = 0; $index -lt $array.Count; $index++) {\n        if ($index -lt $start) {\n            $firstSectionArray.Add($array[$index]) > $null\n        }\n        elseif ($index -ge $start -and $index -le $end) {\n            $stack.Push($array[$index])\n        }\n        else {\n            $secondSectionArray.Add($array[$index]) > $null\n        }\n    }\n    $finalArray = $firstSectionArray + $stack.ToArray() + $secondSectionArray\n    return $finalArray\n}\n\nFormat-Range 2 6 $targetArray \n# => 'a','b','g','f','e','d','c','h','i','j','k','l','m'\n\n# The previous method works, but uses extra memory by allocating new arrays.\n# It's also kind of lengthy.\n# Let's see how we can do this without allocating a new array.\n# This is slightly faster as well.\n\nfunction Format-Range ($start, $end) {\n  while ($start -lt $end)\n  {\n      $temp = $targetArray[$start]\n      $targetArray[$start] = $targetArray[$end]\n      $targetArray[$end] = $temp\n      $start++\n      $end--\n  }\n  return $targetArray\n}\n\nFormat-Range 2 6 # => 'a','b','g','f','e','d','c','h','i','j','k','l','m'\n```\nPowershell as a Tool:\n\nGetting Help:\n\n```Powershell\n# Find commands\nGet-Command about_* # alias: gcm\nGet-Command -Verb Add\nGet-Alias ps\nGet-Alias -Definition Get-Process\n\nGet-Help ps | less # alias: help\nps | Get-Member # alias: gm\n\nShow-Command Get-WinEvent # Display GUI to fill in the parameters\n\nUpdate-Help # Run as admin\n```\n\nIf you are uncertain about your environment:\n\n```Powershell\nGet-ExecutionPolicy -List\nSet-ExecutionPolicy AllSigned\n# Execution policies include:\n# - Restricted: Scripts won't run.\n# - RemoteSigned: Downloaded scripts run only if signed by a trusted publisher. \n# - AllSigned: Scripts need to be signed by a trusted publisher.\n# - Unrestricted: Run all scripts.\nhelp about_Execution_Policies # for more info\n\n# Current PowerShell version:\n$PSVersionTable\n```\n\n```Powershell\n# Calling external commands, executables, \n# and functions with the call operator.\n# Exe paths with arguments passed or containing spaces can create issues.\nC:\\Program Files\\dotnet\\dotnet.exe\n# The term 'C:\\Program' is not recognized as a name of a cmdlet,\n# function, script file, or executable program.\n# Check the spelling of the name, or if a path was included, \n# verify that the path is correct and try again\n\n\"C:\\Program Files\\dotnet\\dotnet.exe\"\nC:\\Program Files\\dotnet\\dotnet.exe    # returns string rather than execute\n\n&\"C:\\Program Files\\dotnet\\dotnet.exe --help\"   # fail\n&\"C:\\Program Files\\dotnet\\dotnet.exe\" --help   # success\n# Alternatively, you can use dot-sourcing here\n.\"C:\\Program Files\\dotnet\\dotnet.exe\" --help   # success\n\n# the call operator (&) is similar to Invoke-Expression, \n# but IEX runs in current scope.\n# One usage of '&' would be to invoke a scriptblock inside of your script.\n# Notice the variables are scoped\n$i = 2\n$scriptBlock = { $i=5; Write-Output $i }\n& $scriptBlock # => 5\n$i # => 2\n\ninvoke-expression ' $i=5; Write-Output $i ' # => 5\n$i # => 5\n\n# Alternatively, to preserve changes to public variables\n# you can use \"Dot-Sourcing\". This will run in the current scope.\n$x=1\n&{$x=2};$x # => 1\n\n.{$x=2};$x # => 2\n\n\n# Remoting into computers is easy.\nEnter-PSSession -ComputerName RemoteComputer\n\n# Once remoted in, you can run commands as if you're local.\nRemoteComputer\\PS> Get-Process powershell\n\n<#\nHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName                                             \n-------  ------    -----      -----     ------     --  -- -----------                                             \n   1096      44   156324     179068      29.92  11772   1 powershell                                              \n    545      25    49512      49852             25348   0 powershell \n#>\nRemoteComputer\\PS> Exit-PSSession\n\n<#\n Powershell is an incredible tool for Windows management and Automation.\n Let's take the following scenario:\n You have 10 servers.\n You need to check whether a service is running on all of them.\n You can RDP and log in, or PSSession to all of them, but why?\n Check out the following\n#>\n\n$serverList = @(\n    'server1',\n    'server2',\n    'server3',\n    'server4',\n    'server5',\n    'server6',\n    'server7',\n    'server8',\n    'server9',\n    'server10'\n)\n\n[scriptblock]$script = {\n    Get-Service -DisplayName 'Task Scheduler'\n}\n\nforeach ($server in $serverList) {\n    $cmdSplat = @{\n        ComputerName  = $server\n        JobName       = 'checkService'\n        ScriptBlock   = $script\n        AsJob         = $true\n        ErrorAction   = 'SilentlyContinue'\n    }\n    Invoke-Command @cmdSplat | Out-Null\n}\n\n<#\n Here we've invoked jobs across many servers.\n We can now Receive-Job and see if they're all running.\n Now scale this up 100x as many servers :)\n#>\n```\n\nInteresting Projects  \n\n* [Channel9](https://channel9.msdn.com/Search?term=powershell%20pipeline#ch9Search&lang-en=en) PowerShell tutorials\n* [KevinMarquette's Powershell Blog](https://powershellexplained.com/) Excellent blog that goes into great detail on Powershell\n* [PSGet](https://github.com/psget/psget) NuGet for PowerShell\n* [PSReadLine](https://github.com/lzybkr/PSReadLine/) A bash inspired readline implementation for PowerShell (So good that it now ships with Windows10 by default!)\n* [Posh-Git](https://github.com/dahlbyk/posh-git/) Fancy Git Prompt (Recommended!)\n* [Oh-My-Posh](https://github.com/JanDeDobbeleer/oh-my-posh) Shell customization similar to the popular Oh-My-Zsh on Mac\n* [PSake](https://github.com/psake/psake) Build automation tool\n* [Pester](https://github.com/pester/Pester) BDD Testing Framework\n* [Jump-Location](https://github.com/tkellogg/Jump-Location) Powershell `cd` that reads your mind\n* [PowerShell Community Extensions](https://github.com/Pscx/Pscx)\n* [More on the Powershell Pipeline Issue](https://github.com/PowerShell/PowerShell/issues/1908)"
