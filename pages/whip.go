
package pages

const Whip = "Whip is a LISP-dialect made for scripting and simplified concepts.\nIt has also borrowed a lot of functions and syntax from Haskell (a non-related language).\n\nThese docs were written by the creator of the language himself. So is this line.\n\n```scheme\n; Comments are like LISP. Semi-colons...\n\n; Majority of first-level statements are inside \"forms\"\n; which are just things inside parens separated by whitespace\nnot_in_form\n(in_form)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; 1. Numbers, Strings, and Operators\n\n; Whip has one number type (which is a 64-bit IEEE 754 double, from JavaScript).\n3 ; => 3\n1.5 ; => 1.5\n\n; Functions are called if they are the first element in a form\n(called_function args)\n\n; Majority of operations are done with functions\n; All the basic arithmetic is pretty straight forward\n(+ 1 1) ; => 2\n(- 2 1) ; => 1\n(* 1 2) ; => 2\n(/ 2 1) ; => 2\n; even modulo\n(% 9 4) ; => 1\n; JavaScript-style uneven division.\n(/ 5 2) ; => 2.5\n\n; Nesting forms works as you expect.\n(* 2 (+ 1 3)) ; => 8\n\n; There's a boolean type.\ntrue\nfalse\n\n; Strings are created with \".\n\"Hello, world\"\n\n; Single chars are created with '.\n'a'\n\n; Negation uses the 'not' function.\n(not true) ; => false\n(not false) ; => true\n\n; But the majority of non-haskell functions have shortcuts\n; not's shortcut is a '!'.\n(! (! true)) ; => true\n\n; Equality is `equal` or `=`.\n(= 1 1) ; => true\n(equal 2 1) ; => false\n\n; For example, inequality would be combining the not and equal functions.\n(! (= 2 1)) ; => true\n\n; More comparisons\n(< 1 10) ; => true\n(> 1 10) ; => false\n; and their word counterpart.\n(lesser 1 10) ; => true\n(greater 1 10) ; => false\n\n; Strings can be concatenated with +.\n(+ \"Hello \" \"world!\") ; => \"Hello world!\"\n\n; You can use JavaScript's comparative abilities.\n(< 'a' 'b') ; => true\n; ...and type coercion\n(= '5' 5)\n\n; The `at` or @ function will access characters in strings, starting at 0.\n(at 0 'a') ; => 'a'\n(@ 3 \"foobar\") ; => 'b'\n\n; There is also the `null` and `undefined` variables.\nnull ; used to indicate a deliberate non-value\nundefined ; user to indicate a value that hasn't been set\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; 2. Variables, Lists, and Dicts\n\n; Variables are declared with the `def` or `let` functions.\n; Variables that haven't been set will be `undefined`.\n(def some_var 5)\n; `def` will keep the variable in the global context.\n; `let` will only have the variable inside its context, and has a weirder syntax.\n(let ((a_var 5)) (+ a_var 5)) ; => 10\n(+ a_var 5) ; = undefined + 5 => undefined\n\n; Lists are arrays of values of any type.\n; They basically are just forms without functions at the beginning.\n(1 2 3) ; => [1, 2, 3] (JavaScript syntax)\n\n; Dictionaries are Whip's equivalent to JavaScript 'objects' or Python 'dicts'\n; or Ruby 'hashes': an unordered collection of key-value pairs.\n{\"key1\" \"value1\" \"key2\" 2 3 3}\n\n; Keys are just values, either identifier, number, or string.\n(def my_dict {my_key \"my_value\" \"my other key\" 4})\n; But in Whip, dictionaries get parsed like: value, whitespace, value;\n; with more whitespace between each. So that means\n{\"key\" \"value\"\n\"another key\"\n1234\n}\n; is evaluated to the same as\n{\"key\" \"value\" \"another key\" 1234}\n\n; Dictionary definitions can be accessed used the `at` function\n; (like strings and lists.)\n(@ \"my other key\" my_dict) ; => 4\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; 3. Logic and Control sequences\n\n; The `if` function is pretty simple, though different than most imperative langs.\n(if true \"returned if first arg is true\" \"returned if first arg is false\")\n; => \"returned if first arg is true\"\n\n; And for the sake of ternary operator legacy\n; `?` is if's unused shortcut.\n(? false true false) ; => false\n\n; `both` is a logical 'and' statement, and `either` is a logical 'or'.\n(both true true) ; => true\n(both true false) ; => false\n(either true false) ; => true\n(either false false) ; => false\n; And their shortcuts are\n; & => both\n; ^ => either\n(& true true) ; => true\n(^ false true) ; => true\n\n;;;;;;;;;\n; Lambdas\n\n; Lambdas in Whip are declared with the `lambda` or `->` function.\n; And functions are really just lambdas with names.\n(def my_function (-> (x y) (+ (+ x y) 10)))\n;         |       |    |          |\n;         |       |    |    returned value(with scope containing argument vars)\n;         |       | arguments\n;         | lambda declaration function\n;         |\n;   name of the to-be-declared lambda\n\n(my_function 10 10) ; = (+ (+ 10 10) 10) => 30\n\n; Obviously, all lambdas by definition are anonymous and\n; technically always used anonymously. Redundancy.\n((lambda (x) x) 10) ; => 10\n\n;;;;;;;;;;;;;;;;\n; Comprehensions\n\n; `range` or `..` generates a list of numbers for\n; each number between its two args.\n(range 1 5) ; => (1 2 3 4 5)\n(.. 0 2)    ; => (0 1 2)\n\n; `map` applies its first arg (which should be a lambda/function)\n; to each item in the following arg (which should be a list)\n(map (-> (x) (+ x 1)) (1 2 3)) ; => (2 3 4)\n\n; Reduce\n(reduce + (.. 1 5))\n; equivalent to\n((+ (+ (+ 1 2) 3) 4) 5)\n\n; Note: map and reduce don't have shortcuts\n\n; `slice` or `\\` is just like JavaScript's .slice()\n; But do note, it takes the list as the first argument, not the last.\n(slice (.. 1 5) 2) ; => (3 4 5)\n(\\ (.. 0 100) -5) ; => (96 97 98 99 100)\n\n; `append` or `<<` is self explanatory\n(append 4 (1 2 3)) ; => (1 2 3 4)\n(<< \"bar\" (\"foo\")) ; => (\"foo\" \"bar\")\n\n; Length is self explanatory.\n(length (1 2 3)) ; => 3\n(_ \"foobar\") ; => 6\n\n;;;;;;;;;;;;;;;\n; Haskell fluff\n\n; First item in list\n(head (1 2 3)) ; => 1\n; List from second to last elements in list\n(tail (1 2 3)) ; => (2 3)\n; Last item in list\n(last (1 2 3)) ; => 3\n; Reverse of `tail`\n(init (1 2 3)) ; => (1 2)\n; List from first to specified elements in list\n(take 1 (1 2 3 4)) ; (1 2)\n; Reverse of `take`\n(drop 1 (1 2 3 4)) ; (3 4)\n; Lowest value in list\n(min (1 2 3 4)) ; 1\n; Highest value in list\n(max (1 2 3 4)) ; 4\n; If value is in list or object\n(elem 1 (1 2 3)) ; true\n(elem \"foo\" {\"foo\" \"bar\"}) ; true\n(elem \"bar\" {\"foo\" \"bar\"}) ; false\n; Reverse list order\n(reverse (1 2 3 4)) ; => (4 3 2 1)\n; If value is even or odd\n(even 1) ; => false\n(odd 1) ; => true\n; Split string into list of strings by whitespace\n(words \"foobar nachos cheese\") ; => (\"foobar\" \"nachos\" \"cheese\")\n; Join list of strings together.\n(unwords (\"foo\" \"bar\")) ; => \"foobar\"\n; Successor and Predecessor\n(pred 21) ; => 20\n(succ 20) ; => 21\n```\n\nFor more info, check out the [repo](http://github.com/L8D/whip)"
