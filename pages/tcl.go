
package pages

const Tcl = "Tcl was created by [John Ousterhout](https://wiki.tcl-lang.org/page/John+Ousterhout) as a\nreusable scripting language for circuit design tools that he authored.  In 1997 he\nwas awarded the [ACM Software System\nAward](https://en.wikipedia.org/wiki/ACM_Software_System_Award) for Tcl.   Tcl\ncan be used both as an embeddable scripting language and as a general\nprogramming language.  It can also be used as a portable C library, even in\ncases where no scripting capability is needed, as it provides data structures\nsuch as dynamic strings, lists, and hash tables.  The C library also provides\nportable functionality for loading dynamic libraries, string formatting and\ncode conversion, filesystem operations, network operations, and more.  Various\nfeatures of Tcl stand out:\n\n* Convenient cross-platform networking API\n\n* Fully virtualized filesystem\n\n* Stackable I/O channels\n\n* Asynchronous to the core\n\n* Full coroutines\n\n* A threading model recognized as robust and easy to use\n\n\nTcl has much in common with Lisp, but instead of lists, Tcl uses strings as the\ncurrency of the language.  All values are strings.  A list is a string with a\ndefined format, and the body of a procedure (a script) is also a string rather\nthan a block.  To achieve performance, Tcl internally caches structured\nrepresentations of these values.  list routines, for example, operate on\nthe internal cached representation, and Tcl takes care of updating the string\nrepresentation if it is ever actually needed in the script.  The copy-on-write\ndesign of Tcl allows script authors to pass around large data values without\nactually incurring additional memory overhead.  Procedures are automatically\nbyte-compiled unless they use the more dynamic routines such as \"uplevel\",\n\"upvar\", and \"trace\".\n\nTcl is a pleasure to program in.  It will appeal to hacker types who find Lisp,\nForth, or Smalltalk interesting, as well as to engineers and scientists who\njust want to get down to business with a tool that bends to their will.  Its\ndiscipline of exposing all programmatic functionality as routines, including\nthings like looping and mathematical operations that are usually baked into the\nsyntax of other languages, allows it to fade into the background of whatever\ndomain-specific functionality a project needs. Its syntax, which is even\nlighter than that of Lisp, just gets out of the way.\n\n\n\n```tcl\n#! /bin/env tclsh\n\n###############################################################################\n## 1. Guidelines\n###############################################################################\n\n# Tcl is not Sh or C!  This needs to be said because standard shell quoting\n# habits almost work in Tcl and it is common for people to pick up Tcl and try\n# to get by with syntax they know from another language.  It works at first,\n# but soon leads to frustration when scripts become more complex.\n\n# Braces are a quoting mechanism, not syntax for the construction of code\n# blocks or lists. Tcl doesn't have either of those things.  Braces are used to\n# escape special characters, which makes them well-suited for quoting procedure\n# bodies and strings that should be interpreted as lists.\n\n\n###############################################################################\n## 2. Syntax\n###############################################################################\n\n# A script is made up of commands delimited by newlines or semicolons.  Each\n# command is a call to a routine.  The first word is the name of a routine to\n# call, and subsequent words are arguments to the routine.  Words are delimited\n# by whitespace.  Since each argument is a word in the command it is already a\n# string, and may be unquoted:\nset part1 Sal\nset part2 ut; set part3 ations\n\n\n# a dollar sign introduces variable substitution:\nset greeting $part1$part2$part3\n\n\n# When \"set\" is given only the name of a variable, it returns the\n# value of that variable:\nset part3 ;# Returns the value of the variable.\n\n\n# Left and right brackets embed a script to be evaluated for a result to\n# substitute into the word:\nset greeting $part1$part2[set part3]\n\n\n# An embedded script may be composed of multiple commands, the last of which provides\n# the result for the substitution:\nset greeting $greeting[\n    incr i\n    incr i\n    incr i\n]\nputs $greeting ;# The output is \"Salutations3\"\n\n# Every word in a command is a string, including the name of the routine, so\n# substitutions can be used on it as well. Given this variable\n# assignment,\nset action pu\n\n# , the following three commands are equivalent:\nputs $greeting\n${action}ts $greeting \n[set action]ts $greeting\n\n\n# backslash suppresses the special meaning of characters:\nset amount \\$16.42\n\n\n# backslash adds special meaning to certain characters:\nputs lots\\nof\\n\\n\\n\\n\\n\\nnewlines\n\n\n# A word enclosed in braces is not subject to any special interpretation or\n# substitutions, except that a backslash before a brace is not counted when\n# looking for the closing brace:\nset somevar {\n    This is a literal $ sign, and this \\} escaped\n    brace remains uninterpreted\n}\n\n\n# In a word enclosed in double quotes, whitespace characters lose their special\n# meaning:\nset name Neo\nset greeting \"Hello, $name\"\n\n\n# A variable name can be any string:\nset {first name} New\n\n\n# The braced form of variable substitution handles more complex variable names:\nset greeting \"Hello, ${first name}\"\n\n\n# \"set\" can always be used instead of variable substitution, and can handle all\n# variable names:\nset greeting \"Hello, [set {first name}]\"\n\n\n# To unpack a list into the command, use the expansion operator, \"{*}\".  These\n# two commands are equivalent:\nset name Neo\nset {*}{name Neo}\n\n\n# An array is a special variable that is a container for other variables.\nset person(name) Neo\nset person(destiny) {The One}\nset greeting \"Hello, $person(name)\"\n\n\n# \"variable\" can be used to declare or set variables. In contrast with \"set\",\n# which uses both the global namespace and the current namespace to resolve a\n# variable name, \"variable\" uses only the current namespace:\nvariable name New\n\n\n# \"namespace eval\" creates a new namespace if it doesn't exist.  A namespace\n# can contain both routines and variables:\nnamespace eval people {\n    namespace eval person1 {\n        variable name Neo\n    }\n}\n\n\n# Use two or more colons to delimit namespace components in variable names:\nnamespace eval people {\n    set greeting \"Hello $person1::name\"\n}\n\n# Two or more colons also delimit namespace components in routine names:\nproc people::person1::speak {} {\n    puts {I am The One.}\n}\n\n# Fully-qualified names begin with two colons:\nset greeting \"Hello $::people::person1::name\"\n\n\n\n###############################################################################\n## 3. No More Syntax\n###############################################################################\n\n# All other functionality is implemented via routines.  From this point on,\n# there is no new syntax.  Everything else there is to learn about\n# Tcl is about the behaviour of individual routines and what meaning they\n# assign to their arguments.\n\n\n\n###############################################################################\n## 4. Variables and Namespaces\n###############################################################################\n\n# Each variable and routine is associated with some namespace.\n\n# To end up with an interpreter that can do nothing, delete the global\n# namespace.  It's not very useful to do such a thing, but it illustrates the\n# nature of Tcl.  The name of the global namespace is actually the empty\n# string, but the only way to represent it is as a fully-qualified name. To\n# try it out call this routine:\nproc delete_global_namespace {} {\n    namespace delete ::\n}\n\n# Because \"set\" always keeps its eye on both the global namespace and the\n# current namespace, it's safer to use \"variable\" to declare a variable or\n# assign a value to a variable.  If a variable called \"name\" already exists in\n# the global namespace, using \"set\" here will assign a value to the global\n# variable instead of to a variable in the current namespace, whereas\n# \"variable\" operates only on the current namespace.\nnamespace eval people {\n    namespace eval person1 {\n        variable name Neo\n    }\n}\n\n# Once a variable is declared in a namespace, [set] sees it instead of seeing\n# an identically-named variable in the global namespace:\nnamespace eval people {\n    namespace eval person1 {\n        variable name\n        set name Neo\n    }\n}\n\n# But if \"set\" has to create a new variable, it always does it relative to the\n# current namespace:\nunset name\nnamespace eval people {\n    namespace eval person1 {\n        set name neo\n    }\n\n}\nset people::person1::name\n\n\n# An absolute name always begins with the name of the global namespace (the\n# empty string), followed by two colons:\nset ::people::person1::name Neo\n\n\n# Within a procedure, the \"variable\" links a variable in the current namespace\n# into the local scope:\nnamespace eval people::person1 {\n    proc fly {} {\n        variable name\n        puts \"$name is flying!\"\n    }\n}\n\n\n\n\n###############################################################################\n## 5. Built-in Routines\n###############################################################################\n\n# Math can be done with the \"expr\":\nset a 3\nset b 4\nset c [expr {$a + $b}]\n\n# Since \"expr\" performs variable substitution on its own, brace the expression\n# to prevent Tcl from performing variable substitution first.  See\n# \"https://wiki.tcl-lang.org/page/Brace+your+expr-essions\" for details.\n\n\n# \"expr\" understands variable and script substitution:\nset c [expr {$a + [set b]}]\n\n\n# \"expr\" provides a set of mathematical functions:\nset c [expr {pow($a,$b)}]\n\n\n# Mathematical operators are available as routines in the ::tcl::mathop\n# namespace:\n::tcl::mathop::+ 5 3\n\n# Routines can be imported from other namespaces:\nnamespace import ::tcl::mathop::+\nset result [+ 5 3]\n\n\n# Non-numeric values must be quoted, and operators like \"eq\" can be used to\n# constrain the operation to string comparison:\nset name Neo\nexpr {{Bob} eq $name}\n\n# The general operators fall back to string string comparison if numeric\n# operation isn't feasible:\nexpr {{Bob} == $name}\n\n\n# \"proc\" creates new routines:\nproc greet name {\n    return \"Hello, $name!\"\n}\n\n#multiple parameters can be specified:\nproc greet {greeting name} {\n    return \"$greeting, $name!\"\n}\n\n\n# As noted earlier, braces do not construct a code block.  Every value, even\n# the third argument to \"proc\", is a string.  The previous command\n# can be rewritten using no braces:\nproc greet greeting\\ name return\\ \\\"\\$greeting,\\ \\$name!\\\"\n# \"\n\n\n\n# When the last parameter is the literal value \"args\", all extra arguments\n# passed to the routine are collected into a list and assigned to \"args\":\nproc fold {cmd first args} {\n    foreach arg $args {\n        set first [$cmd $first $arg]\n    }\n    return $first\n}\nfold ::tcl::mathop::* 5 3 3 ;# ->  45\n\n\n# Conditional execution is implemented as a routine:\nif {3 > 4} {\n    puts {This will never happen}\n} elseif {4 > 4} {\n    puts {This will also never happen}\n} else {\n    puts {This will always happen}\n}\n\n\n# Loops are implemented as routines.  The first and third arguments to \n# \"for\" are treated as scripts, while the second argument is treated as\n# an expression:\nset res 0\nfor {set i 0} {$i < 10} {incr i} {\n    set res [expr {$res + $i}]\n}\nunset res\n\n\n# The first argument to \"while\" is also treated as an expression:\nset i 0\nwhile {$i < 10} {\n    incr i 2\n}\n\n\n# A list is a string, and items in the list are delimited by whitespace:\nset amounts 10\\ 33\\ 18\nset amount [lindex $amounts 1]\n\n# Whitespace in a list item must be quoted:\nset inventory {\"item 1\" item\\ 2 {item 3}}\n\n\n# It's generally a better idea to use list routines when modifying lists:\nlappend inventory {item 1} {item 2} {item 3}\n\n\n# Braces and backslash can be used to format more complex values in a list.  A\n# list looks exactly like a script, except that the newline character and the\n# semicolon character lose their special meanings, and there is no script or\n# variable substitution.  This feature makes Tcl homoiconic.  There are three\n# items in the following list:\nset values {\n\n    one\\ two\n\n    {three four}\n\n    five\\{six\n\n}\n\n\n# Since, like all values, a list is a string, string operations could be\n# performed on it, at the risk of corrupting the formatting of the list:\nset values {one two three four}\nset values [string map {two \\{} $values] ;# $values is no-longer a \\\n    properly-formatted list\n\n\n# The sure-fire way to get a properly-formatted list is to use \"list\" routines:\nset values [list one \\{ three four]\nlappend values { } ;# add a single space as an item in the list\n\n\n# Use \"eval\" to evaluate a value as a script:\neval {\n    set name Neo\n    set greeting \"Hello, $name\"\n}\n\n\n# A list can always be passed to \"eval\" as a script composed of a single\n# command:\neval {set name Neo}\neval [list set greeting \"Hello, $name\"]\n\n\n# Therefore, when using \"eval\", use \"list\" to build up the desired command:\nset command {set name}\nlappend command {Archibald Sorbisol}\neval $command\n\n\n# A common mistake is not to use list functions when building up a command:\nset command {set name}\nappend command { Archibald Sorbisol}\ntry {\n    eval $command ;# The error here is that there are too many arguments \\\n        to \"set\" in {set name Archibald Sorbisol}\n} on error {result eoptions} {\n    puts [list {received an error} $result]\n}\n\n# This mistake can easily occur with \"subst\":\n\nset replacement {Archibald Sorbisol}\nset command {set name $replacement}\nset command [subst $command] \ntry {\n    eval $command ;# The same error as before:  too many arguments to \"set\" in \\\n        {set name Archibald Sorbisol}\n} trap {TCL WRONGARGS} {result options} {\n    puts [list {received another error} $result]\n}\n\n\n# \"list\" correctly formats a value for substitution:\nset replacement [list {Archibald Sorbisol}]\nset command {set name $replacement}\nset command [subst $command]\neval $command\n\n\n# \"list\" is commonly used to format values for substitution into scripts: There\n# are several examples of this, below.\n\n\n# \"apply\" evaluates a two-item list as a routine:\nset cmd {{greeting name} {\n    return \"$greeting, $name!\"\n}}\napply $cmd Whaddup Neo\n\n# A third item can be used to specify the namespace to apply the routine in:\nset cmd [list {greeting name} {\n    return \"$greeting, $name!\"\n} [namespace current]]\napply $cmd Whaddup Neo\n\n\n# \"uplevel\" evaluates a script at some higher level in the call stack:\nproc greet {} {\n    uplevel {puts \"$greeting, $name\"}\n}\n\nproc set_double {varname value} {\n    if {[string is double $value]} {\n        uplevel [list variable $varname $value]\n    } else {\n        error [list {not a double} $value]\n    }\n}\n\n\n# \"upvar\" links a variable at the current level in the call stack to a variable\n# at some higher level:\nproc set_double {varname value} {\n    if {[string is double $value]} {\n        upvar 1 $varname var\n        set var $value\n    } else {\n        error [list {not a double} $value]\n    }\n}\n\n\n# Get rid of the built-in \"while\" routine, and use \"proc\" to define a new one:\nrename ::while {}\n# handling is left as an exercise:\nproc while {condition script} {\n    if {[uplevel 1 [list expr $condition]]} {\n        uplevel 1 $script\n        tailcall [namespace which while] $condition $script\n    }\n}\n\n\n# \"coroutine\" creates a new call stack, a new routine to enter that call stack,\n# and then calls that routine.  \"yield\" suspends evaluation in that stack and\n# returns control to the calling stack:\nproc countdown count {\n    # send something back to the creator of the coroutine, effectively pausing\n    # this call stack for the time being.\n    yield [info coroutine]\n\n    while {$count > 1} {\n        yield [incr count -1]\n    }\n    return 0\n}\ncoroutine countdown1 countdown 3\ncoroutine countdown2 countdown 5\nputs [countdown1] ;# -> 2 \nputs [countdown2] ;# -> 4 \nputs [countdown1] ;# -> 1 \nputs [countdown1] ;# -> 0 \ncatch {\n    puts [coundown1] ;# -> invalid command name \"countdown1\"\n} cres copts \nputs $cres\nputs [countdown2] ;# -> 3 \n\n\n# Coroutine stacks can yield control to each other:\n\nproc pass {whom args} {\n    return [yieldto $whom {*}$args]\n}\n\ncoroutine a apply {{} {\n        yield\n        set result [pass b {please pass the salt}]\n        puts [list got the $result]\n        set result [pass b {please pass the pepper}]\n        puts [list got the $result]\n}}\n\ncoroutine b apply {{} {\n    set request [yield]\n    while 1 {\n        set response [pass c $request]\n        puts [list [info coroutine] is now yielding]\n        set request [pass a $response]\n    }\n}}\n\ncoroutine c apply {{} {\n    set request [yield]\n    while 1 {\n        if {[string match *salt* $request]} {\n            set request [pass b salt]\n        } else {\n            set request [pass b huh?]\n        }\n    }\n}}\n\n# get things moving\na\n\n\n```\n\n## Reference\n\n[Official Tcl Documentation](https://www.tcl-lang.org)\n\n[Tcl Wiki](https://wiki.tcl-lang.org)\n\n[Tcl Subreddit](http://www.reddit.com/r/Tcl)"
