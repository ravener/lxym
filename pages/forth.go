
package pages

const Forth = "Forth was created by Charles H. Moore in the 70s. It is an imperative,\nstack-based language and programming environment, being used in projects\nsuch as Open Firmware. It's also used by NASA.\n\nNote: This article focuses predominantly on the Gforth implementation of\nForth, but most of what is written here should work elsewhere.\n\n```forth\n\\ This is a comment\n( This is also a comment but it's only used when defining words )\n\n\\ --------------------------------- Precursor ----------------------------------\n\n\\ All programming in Forth is done by manipulating the parameter stack (more\n\\ commonly just referred to as \"the stack\").\n5 2 3 56 76 23 65    \\ ok\n\n\\ Those numbers get added to the stack, from left to right.\n.s    \\ <7> 5 2 3 56 76 23 65 ok\n\n\\ In Forth, everything is either a word or a number.\n\n\\ ------------------------------ Basic Arithmetic ------------------------------\n\n\\ Arithmetic (in fact most words requiring data) works by manipulating data on\n\\ the stack.\n5 4 +    \\ ok\n\n\\ `.` pops the top result from the stack:\n.    \\ 9 ok\n\n\\ More examples of arithmetic:\n6 7 * .        \\ 42 ok\n1360 23 - .    \\ 1337 ok\n12 12 / .      \\ 1 ok\n13 2 mod .     \\ 1 ok\n\n99 negate .    \\ -99 ok\n-99 abs .      \\ 99 ok\n52 23 max .    \\ 52 ok\n52 23 min .    \\ 23 ok\n\n\\ ----------------------------- Stack Manipulation -----------------------------\n\n\\ Naturally, as we work with the stack, we'll want some useful methods:\n\n3 dup -          \\ duplicate the top item (1st now equals 2nd): 3 - 3\n2 5 swap /       \\ swap the top with the second element:        5 / 2\n6 4 5 rot .s     \\ rotate the top 3 elements:                   4 5 6\n4 0 drop 2 /     \\ remove the top item (don't print to screen):  4 / 2\n1 2 3 nip .s     \\ remove the second item (similar to drop):    1 3\n\n\\ ---------------------- More Advanced Stack Manipulation ----------------------\n\n1 2 3 4 tuck   \\ duplicate the top item below the second slot:      1 2 4 3 4 ok\n1 2 3 4 over   \\ duplicate the second item to the top:             1 2 3 4 3 ok\n1 2 3 4 2 roll \\ *move* the item at that position to the top:      1 3 4 2 ok\n1 2 3 4 2 pick \\ *duplicate* the item at that position to the top: 1 2 3 4 2 ok\n\n\\ When referring to stack indexes, they are zero-based.\n\n\\ ------------------------------ Creating Words --------------------------------\n\n\\ The `:` word sets Forth into compile mode until it sees the `;` word.\n: square ( n -- n ) dup * ;    \\ ok\n5 square .                     \\ 25 ok\n\n\\ We can view what a word does too:\nsee square     \\ : square dup * ; ok\n\n\\ -------------------------------- Conditionals --------------------------------\n\n\\ -1 == true, 0 == false. However, any non-zero value is usually treated as\n\\ being true:\n42 42 =    \\ -1 ok\n12 53 =    \\ 0 ok\n\n\\ `if` is a compile-only word. `if` <stuff to do> `then` <rest of program>.\n: ?>64 ( n -- n ) dup 64 > if .\" Greater than 64!\" then ; \\ ok\n100 ?>64                                                  \\ Greater than 64! ok\n\n\\ Else:\n: ?>64 ( n -- n ) dup 64 > if .\" Greater than 64!\" else .\" Less than 64!\" then ;\n100 ?>64    \\ Greater than 64! ok\n20 ?>64     \\ Less than 64! ok\n\n\\ ------------------------------------ Loops -----------------------------------\n\n\\ `do` is also a compile-only word.\n: myloop ( -- ) 5 0 do cr .\" Hello!\" loop ; \\ ok\nmyloop\n\\ Hello!\n\\ Hello!\n\\ Hello!\n\\ Hello!\n\\ Hello! ok\n\n\\ `do` expects two numbers on the stack: the end number and the start number.\n\n\\ We can get the value of the index as we loop with `i`:\n: one-to-12 ( -- ) 12 0 do i . loop ;     \\ ok\none-to-12                                 \\ 0 1 2 3 4 5 6 7 8 9 10 11 12 ok\n\n\\ `?do` works similarly, except it will skip the loop if the end and start\n\\ numbers are equal.\n: squares ( n -- ) 0 ?do i square . loop ;   \\ ok\n10 squares                                   \\ 0 1 4 9 16 25 36 49 64 81 ok\n\n\\ Change the \"step\" with `+loop`:\n: threes ( n n -- ) ?do i . 3 +loop ;    \\ ok\n15 0 threes                             \\ 0 3 6 9 12 ok\n\n\\ Indefinite loops with `begin` <stuff to do> <flag> `until`:\n: death ( -- ) begin .\" Are we there yet?\" 0 until ;    \\ ok\n\n\\ ---------------------------- Variables and Memory ----------------------------\n\n\\ Use `variable` to declare `age` to be a variable.\nvariable age    \\ ok\n\n\\ Then we write 21 to age with the word `!`.\n21 age !    \\ ok\n\n\\ Finally we can print our variable using the \"read\" word `@`, which adds the\n\\ value to the stack, or use `?` that reads and prints it in one go.\nage @ .    \\ 21 ok\nage ?      \\ 21 ok\n\n\\ Constants are quite similar, except we don't bother with memory addresses:\n100 constant WATER-BOILING-POINT    \\ ok\nWATER-BOILING-POINT .               \\ 100 ok\n\n\\ ----------------------------------- Arrays -----------------------------------\n\n\\ Creating arrays is similar to variables, except we need to allocate more\n\\ memory to them.\n\n\\ You can use `2 cells allot` to create an array that's 3 cells long:\nvariable mynumbers 2 cells allot    \\ ok\n\n\\ Initialize all the values to 0\nmynumbers 3 cells erase    \\ ok\n\n\\ Alternatively we could use `fill`:\nmynumbers 3 cells 0 fill\n\n\\ or we can just skip all the above and initialize with specific values:\ncreate mynumbers 64 , 9001 , 1337 , \\ ok (the last `,` is important!)\n\n\\ ...which is equivalent to:\n\n\\ Manually writing values to each index:\n64 mynumbers 0 cells + !      \\ ok\n9001 mynumbers 1 cells + !    \\ ok\n1337 mynumbers 2 cells + !    \\ ok\n\n\\ Reading values at certain array indexes:\n0 cells mynumbers + ?    \\ 64 ok\n1 cells mynumbers + ?    \\ 9001 ok\n\n\\ We can simplify it a little by making a helper word for manipulating arrays:\n: of-arr ( n n -- n ) cells + ;    \\ ok\nmynumbers 2 of-arr ?               \\ 1337 ok\n\n\\ Which we can use for writing too:\n20 mynumbers 1 of-arr !    \\ ok\nmynumbers 1 of-arr ?       \\ 20 ok\n\n\\ ------------------------------ The Return Stack ------------------------------\n\n\\ The return stack is used to the hold pointers to things when words are\n\\ executing other words, e.g. loops.\n\n\\ We've already seen one use of it: `i`, which duplicates the top of the return\n\\ stack. `i` is equivalent to `r@`.\n: myloop ( -- ) 5 0 do r@ . loop ;    \\ ok\n\n\\ As well as reading, we can add to the return stack and remove from it:\n5 6 4 >r swap r> .s    \\ 6 5 4 ok\n\n\\ NOTE: Because Forth uses the return stack for word pointers,  `>r` should\n\\ always be followed by `r>`.\n\n\\ ------------------------- Floating Point Operations --------------------------\n\n\\ Most Forths tend to eschew the use of floating point operations.\n8.3e 0.8e f+ f.    \\ 9.1 ok\n\n\\ Usually we simply prepend words with 'f' when dealing with floats:\nvariable myfloatingvar    \\ ok\n4.4e myfloatingvar f!     \\ ok\nmyfloatingvar f@ f.       \\ 4.4 ok\n\n\\ --------------------------------- Final Notes --------------------------------\n\n\\ Typing a non-existent word will empty the stack. However, there's also a word\n\\ specifically for that:\nclearstack\n\n\\ Clear the screen:\npage\n\n\\ Loading Forth files:\n\\ s\" forthfile.fs\" included\n\n\\ You can list every word that's in Forth's dictionary (but it's a huge list!):\n\\ words\n\n\\ Exiting Gforth:\n\\ bye\n\n```\n\n##Ready For More?\n\n* [Starting Forth](http://www.forth.com/starting-forth/)\n* [Simple Forth](http://www.murphywong.net/hello/simple.htm)\n* [Thinking Forth](http://thinking-forth.sourceforge.net/)"
