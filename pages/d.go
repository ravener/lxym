
package pages

const D = "```d\n// You know what's coming...\nmodule hello;\n\nimport std.stdio;\n\n// args is optional\nvoid main(string[] args) {\n    writeln(\"Hello, World!\");\n}\n```\n\nIf you're like me and spend way too much time on the internet, odds are you've heard\nabout [D](http://dlang.org/). The D programming language is a modern, general-purpose,\nmulti-paradigm language with support for everything from low-level features to\nexpressive high-level abstractions.\n\nD is actively developed by a large group of super-smart people and is spearheaded by\n[Walter Bright](https://en.wikipedia.org/wiki/Walter_Bright) and\n[Andrei Alexandrescu](https://en.wikipedia.org/wiki/Andrei_Alexandrescu).\nWith all that out of the way, let's look at some examples!\n\n```d\nimport std.stdio;\n\nvoid main() {\n\n    // Conditionals and loops work as expected.\n    for(int i = 0; i < 10000; i++) {\n        writeln(i);\n    }\n\n    // 'auto' can be used for inferring types.\n    auto n = 1;\n\n    // Numeric literals can use '_' as a digit separator for clarity.\n    while(n < 10_000) {\n        n += n;\n    }\n\n    do {\n        n -= (n / 2);\n    } while(n > 0);\n\n    // For and while are nice, but in D-land we prefer 'foreach' loops.\n    // The '..' creates a continuous range, including the first value\n    // but excluding the last.\n    foreach(n; 1..1_000_000) {\n        if(n % 2 == 0)\n            writeln(n);\n    }\n\n    // There's also 'foreach_reverse' when you want to loop backwards.\n    foreach_reverse(n; 1..int.max) {\n        if(n % 2 == 1) {\n            writeln(n);\n        } else {\n            writeln(\"No!\");\n        }\n    }\n}\n```\n\nWe can define new types with `struct`, `class`, `union`, and `enum`. Structs and unions\nare passed to functions by value (i.e. copied) and classes are passed by reference. Furthermore,\nwe can use templates to parameterize all of these on both types and values!\n\n```d\n// Here, 'T' is a type parameter. Think '<T>' from C++/C#/Java.\nstruct LinkedList(T) {\n    T data = null;\n\n    // Use '!' to instantiate a parameterized type. Again, think '<T>'.\n    LinkedList!(T)* next;\n}\n\nclass BinTree(T) {\n    T data = null;\n\n    // If there is only one template parameter, we can omit the parentheses.\n    BinTree!T left;\n    BinTree!T right;\n}\n\nenum Day {\n    Sunday,\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday,\n}\n\n// Use alias to create abbreviations for types.\nalias IntList = LinkedList!int;\nalias NumTree = BinTree!double;\n\n// We can create function templates as well!\nT max(T)(T a, T b) {\n    if(a < b)\n        return b;\n\n    return a;\n}\n\n// Use the ref keyword to ensure pass by reference. That is, even if 'a' and 'b'\n// are value types, they will always be passed by reference to 'swap()'.\nvoid swap(T)(ref T a, ref T b) {\n    auto temp = a;\n\n    a = b;\n    b = temp;\n}\n\n// With templates, we can also parameterize on values, not just types.\nclass Matrix(uint m, uint n, T = int) {\n    T[m] rows;\n    T[n] columns;\n}\n\nauto mat = new Matrix!(3, 3); // We've defaulted type 'T' to 'int'.\n\n```\n\nSpeaking of classes, let's talk about properties for a second. A property\nis roughly a function that may act like an lvalue, so we can\nhave the syntax of POD structures (`structure.x = 7`) with the semantics of\ngetter and setter methods (`object.setX(7)`)!\n\n```d\n// Consider a class parameterized on types 'T' & 'U'.\nclass MyClass(T, U) {\n    T _data;\n    U _other;\n}\n\n// And \"getter\" and \"setter\" methods like so:\nclass MyClass(T, U) {\n    T _data;\n    U _other;\n\n    // Constructors are always named 'this'.\n    this(T t, U u) {\n        // This will call the setter methods below.\n        data = t;\n        other = u;\n    }\n\n    // getters\n    @property T data() {\n        return _data;\n    }\n\n    @property U other() {\n        return _other;\n    }\n\n    // setters\n    @property void data(T t) {\n        _data = t;\n    }\n\n    @property void other(U u) {\n        _other = u;\n    }\n}\n\n// And we use them in this manner:\nvoid main() {\n    auto mc = new MyClass!(int, string)(7, \"seven\");\n\n    // Import the 'stdio' module from the standard library for writing to\n    // console (imports can be local to a scope).\n    import std.stdio;\n\n    // Call the getters to fetch the values.\n    writefln(\"Earlier: data = %d, str = %s\", mc.data, mc.other);\n\n    // Call the setters to assign new values.\n    mc.data = 8;\n    mc.other = \"eight\";\n\n    // Call the getters again to fetch the new values.\n    writefln(\"Later: data = %d, str = %s\", mc.data, mc.other);\n}\n```\n\nWith properties, we can add any amount of logic to\nour getter and setter methods, and keep the clean syntax of\naccessing members directly!\n\nOther object-oriented goodies at our disposal\ninclude interfaces, abstract classes,\nand overriding methods. D does inheritance just like Java:\nExtend one class, implement as many interfaces as you please.\n\nWe've seen D's OOP facilities, but let's switch gears. D offers\nfunctional programming with first-class functions, `pure`\nfunctions, and immutable data. In addition, all of your favorite\nfunctional algorithms (map, filter, reduce and friends) can be\nfound in the wonderful `std.algorithm` module!\n\n```d\nimport std.algorithm : map, filter, reduce;\nimport std.range : iota; // builds an end-exclusive range\nimport std.stdio;\n\nvoid main() {\n    // We want to print the sum of a list of squares of even ints\n    // from 1 to 100. Easy!\n\n    // Just pass lambda expressions as template parameters!\n    // You can pass any function you like, but lambdas are convenient here.\n    auto num = iota(1, 101).filter!(x => x % 2 == 0)\n                           .map!(y => y ^^ 2)\n                           .reduce!((a, b) => a + b);\n\n    writeln(num);\n}\n```\n\nNotice how we got to build a nice Haskellian pipeline to compute num?\nThat's thanks to a D innovation know as Uniform Function Call Syntax (UFCS).\nWith UFCS, we can choose whether to write a function call as a method\nor free function call! Walter wrote a nice article on this\n[here.](http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394)\nIn short, you can call functions whose first parameter\nis of some type A on any expression of type A as a method.\n\nI like parallelism. Anyone else like parallelism? Sure you do. Let's do some!\n\n```d\n// Let's say we want to populate a large array with the square root of all\n// consecutive integers starting from 1 (up until the size of the array), and we\n// want to do this concurrently taking advantage of as many cores as we have\n// available.\n\nimport std.stdio;\nimport std.parallelism : parallel;\nimport std.math : sqrt;\n\nvoid main() {\n    // Create your large array\n    auto arr = new double[1_000_000];\n\n    // Use an index, access every array element by reference (because we're\n    // going to change each element) and just call parallel on the array!\n    foreach(i, ref elem; parallel(arr)) {\n        elem = sqrt(i + 1.0);\n    }\n}\n```"
