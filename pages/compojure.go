
package pages

const Compojure = "## Getting Started with Compojure\n\nCompojure is a DSL for *quickly* creating *performant* web applications\nin Clojure with minimal effort:\n\n```clojure\n(ns myapp.core\n  (:require [compojure.core :refer :all]\n            [org.httpkit.server :refer [run-server]])) ; httpkit is a server\n\n(defroutes myapp\n  (GET \"/\" [] \"Hello World\"))\n\n(defn -main []\n  (run-server myapp {:port 5000}))\n```\n\n**Step 1:** Create a project with [Leiningen](http://leiningen.org/):\n\n```\nlein new myapp\n```\n\n**Step 2:** Put the above code in `src/myapp/core.clj`\n\n**Step 3:** Add some dependencies to `project.clj`:\n\n```\n[compojure \"1.1.8\"]\n[http-kit \"2.1.16\"]\n```\n\n**Step 4:** Run:\n\n```\nlein run -m myapp.core\n```\n\nView at: <http://localhost:5000/>\n\nCompojure apps will run on any ring-compatible server, but we recommend\n[http-kit](http://http-kit.org/) for its performance and\n[massive concurrency](http://http-kit.org/600k-concurrent-connection-http-kit.html).\n\n### Routes\n\nIn compojure, each route is an HTTP method paired with a URL-matching pattern,\nan argument list, and a body.\n\n```clojure\n(defroutes myapp\n  (GET \"/\" [] \"Show something\")\n  (POST \"/\" [] \"Create something\")\n  (PUT \"/\" [] \"Replace something\")\n  (PATCH \"/\" [] \"Modify Something\")\n  (DELETE \"/\" [] \"Annihilate something\")\n  (OPTIONS \"/\" [] \"Appease something\")\n  (HEAD \"/\" [] \"Preview something\"))\n```\n\nCompojure route definitions are just functions which\n[accept request maps and return response maps](https://github.com/mmcgrana/ring/blob/master/SPEC):\n\n```clojure\n(myapp {:uri \"/\" :request-method :post})\n; => {:status 200\n;     :headers {\"Content-Type\" \"text/html; charset=utf-8}\n;     :body \"Create Something\"}\n```\n\nThe body may be a function, which must accept the request as a parameter:\n\n```clojure\n(defroutes myapp\n  (GET \"/\" [] (fn [req] \"Do something with req\")))\n```\n\nOr, you can just use the request directly:\n\n```clojure\n(defroutes myapp\n  (GET \"/\" req \"Do something with req\"))\n```\n\nRoute patterns may include named parameters:\n\n```clojure\n(defroutes myapp\n  (GET \"/hello/:name\" [name] (str \"Hello \" name)))\n```\n\nYou can adjust what each parameter matches by supplying a regex:\n\n```clojure\n(defroutes myapp\n  (GET [\"/file/:name.:ext\" :name #\".*\", :ext #\".*\"] [name ext]\n    (str \"File: \" name ext)))\n```\n\n### Middleware\n\nClojure uses [Ring](https://github.com/ring-clojure/ring) for routing.\nHandlers are just functions that accept a request map and return a\nresponse map (Compojure will turn strings into 200 responses for you).\n\nYou can easily write middleware that wraps all or part of your\napplication to modify requests or responses:\n\n```clojure\n(defroutes myapp\n  (GET \"/\" req (str \"Hello World v\" (:app-version req))))\n\n(defn wrap-version [handler]\n  (fn [request]\n    (handler (assoc request :app-version \"1.0.1\"))))\n\n(defn -main []\n  (run-server (wrap-version myapp) {:port 5000}))\n```\n\n[Ring-Defaults](https://github.com/ring-clojure/ring-defaults) provides some handy\nmiddlewares for sites and apis, so add it to your dependencies:\n\n```\n[ring/ring-defaults \"0.1.1\"]\n```\n\nThen, you can import it in your ns:\n\n```\n(ns myapp.core\n  (:require [compojure.core :refer :all]\n            [ring.middleware.defaults :refer :all]\n            [org.httpkit.server :refer [run-server]]))\n```\n\nAnd use `wrap-defaults` to add the `site-defaults` middleware to your\napp:\n\n```\n(defn -main []\n  (run-server (wrap-defaults myapp site-defaults) {:port 5000}))\n```\n\nNow, your handlers may utilize query parameters:\n\n```clojure\n(defroutes myapp\n  (GET \"/posts\" req\n    (let [title (get (:params req) :title)\n          author (get (:params req) :author)]\n      (str \"Title: \" title \", Author: \" author))))\n```\n\nOr, for POST and PUT requests, form parameters as well\n\n```clojure\n(defroutes myapp\n  (POST \"/posts\" req\n    (let [title (get (:params req) :title)\n          author (get (:params req) :author)]\n      (str \"Title: \" title \", Author: \" author))))\n```\n\n\n### Return values\n\nThe return value of a route block determines the response body\npassed on to the HTTP client, or at least the next middleware in the\nring stack. Most commonly, this is a string, as in the above examples.\nBut, you may also return a [response map](https://github.com/mmcgrana/ring/blob/master/SPEC):\n\n```clojure\n(defroutes myapp\n  (GET \"/\" []\n    {:status 200 :body \"Hello World\"})\n  (GET \"/is-403\" []\n    {:status 403 :body \"\"})\n  (GET \"/is-json\" []\n    {:status 200 :headers {\"Content-Type\" \"application/json\"} :body \"{}\"}))\n```\n\n### Static Files\n\nTo serve up static files, use `compojure.route.resources`.\nResources will be served from your project's `resources/` folder.\n\n```clojure\n(require '[compojure.route :as route])\n\n(defroutes myapp\n  (GET \"/\")\n  (route/resources \"/\")) ; Serve static resources at the root path\n\n(myapp {:uri \"/js/script.js\" :request-method :get})\n; => Contents of resources/public/js/script.js\n```\n\n### Views / Templates\n\nTo use templating with Compojure, you'll need a template library. Here are a few:\n\n#### [Stencil](https://github.com/davidsantiago/stencil)\n\n[Stencil](https://github.com/davidsantiago/stencil) is a [Mustache](http://mustache.github.com/) template library:\n\n```clojure\n(require '[stencil.core :refer [render-string]])\n\n(defroutes myapp\n  (GET \"/hello/:name\" [name]\n    (render-string \"Hello {{name}}\" {:name name})))\n```\n\nYou can easily read in templates from your resources directory. Here's a helper function\n\n```clojure\n(require 'clojure.java.io)\n\n(defn read-template [filename]\n  (slurp (clojure.java.io/resource filename)))\n\n(defroutes myapp\n  (GET \"/hello/:name\" [name]\n    (render-string (read-template \"templates/hello.html\") {:name name})))\n```\n\n#### [Selmer](https://github.com/yogthos/Selmer)\n\n[Selmer](https://github.com/yogthos/Selmer) is a Django and Jinja2-inspired templating language:\n\n```clojure\n(require '[selmer.parser :refer [render-file]])\n\n(defroutes myapp\n  (GET \"/hello/:name\" [name]\n    (render-file \"templates/hello.html\" {:name name})))\n```\n\n#### [Hiccup](https://github.com/weavejester/hiccup)\n\n[Hiccup](https://github.com/weavejester/hiccup) is a library for representing HTML as Clojure code\n\n```clojure\n(require '[hiccup.core :as hiccup])\n\n(defroutes myapp\n  (GET \"/hello/:name\" [name]\n    (hiccup/html\n      [:html\n        [:body\n          [:h1 {:class \"title\"}\n            (str \"Hello \" name)]]])))\n```\n\n#### [Markdown](https://github.com/yogthos/markdown-clj)\n\n[Markdown-clj](https://github.com/yogthos/markdown-clj) is a Markdown implementation.\n\n```clojure\n(require '[markdown.core :refer [md-to-html-string]])\n\n(defroutes myapp\n  (GET \"/hello/:name\" [name]\n    (md-to-html-string \"## Hello, world\")))\n```\n\nFurther reading:\n\n* [Official Compojure Documentation](https://github.com/weavejester/compojure/wiki)\n\n* [Clojure for the Brave and True](http://www.braveclojure.com/)"
