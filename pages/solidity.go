
package pages

const Solidity = "Solidity lets you program on [Ethereum](https://www.ethereum.org/), a\nblockchain-based virtual machine that allows the creation and\nexecution of smart contracts, without requiring centralized or trusted parties.\n\nSolidity is a statically typed, contract programming language that has\nsimilarities to Javascript and C. Like objects in OOP, each contract contains\nstate variables, functions, and common data types. Contract-specific features\ninclude modifier (guard) clauses, event notifiers for listeners, and custom\nglobal variables.\n\nSome Ethereum contract examples include crowdfunding, voting, and blind auctions.\n\nThere is a high risk and high cost of errors in Solidity code, so you must be very careful to test\nand slowly rollout. WITH THE RAPID CHANGES IN ETHEREUM, THIS DOCUMENT IS UNLIKELY TO STAY UP TO\nDATE, SO YOU SHOULD FOLLOW THE SOLIDITY CHAT ROOM AND ETHEREUM BLOG FOR THE LATEST. ALL CODE HERE IS\nPROVIDED AS IS, WITH SUBSTANTIAL RISK OF ERRORS OR DEPRECATED CODE PATTERNS.\n\nUnlike other code, you may also need to add in design patterns like pausing, deprecation, and\nthrottling usage to reduce risk. This document primarily discusses syntax, and so excludes many\npopular design patterns.\n\nAs Solidity and Ethereum are under active development, experimental or beta\nfeatures are typically marked, and subject to change. Pull requests welcome.\n\n```javascript\n// First, a simple Bank contract\n// Allows deposits, withdrawals, and balance checks\n\n// simple_bank.sol (note .sol extension)\n/* **** START EXAMPLE **** */\n\n// Declare the source file compiler version\npragma solidity ^0.4.19;\n\n// Start with Natspec comment (the three slashes)\n// used for documentation - and as descriptive data for UI elements/actions\n\n/// @title SimpleBank\n/// @author nemild\n\n/* 'contract' has similarities to 'class' in other languages (class variables,\ninheritance, etc.) */\ncontract SimpleBank { // CapWords\n    // Declare state variables outside function, persist through life of contract\n\n    // dictionary that maps addresses to balances\n    // always be careful about overflow attacks with numbers\n    mapping (address => uint) private balances;\n\n    // \"private\" means that other contracts can't directly query balances\n    // but data is still viewable to other parties on blockchain\n\n    address public owner;\n    // 'public' makes externally readable (not writeable) by users or contracts\n\n    // Events - publicize actions to external listeners\n    event LogDepositMade(address accountAddress, uint amount);\n\n    // Constructor, can receive one or many variables here; only one allowed\n    function SimpleBank() public {\n        // msg provides details about the message that's sent to the contract\n        // msg.sender is contract caller (address of contract creator)\n        owner = msg.sender;\n    }\n\n    /// @notice Deposit ether into bank\n    /// @return The balance of the user after the deposit is made\n    function deposit() public payable returns (uint) {\n        // Use 'require' to test user inputs, 'assert' for internal invariants\n        // Here we are making sure that there isn't an overflow issue\n        require((balances[msg.sender] + msg.value) >= balances[msg.sender]);\n\n        balances[msg.sender] += msg.value;\n        // no \"this.\" or \"self.\" required with state variable\n        // all values set to data type's initial value by default\n\n        LogDepositMade(msg.sender, msg.value); // fire event\n\n        return balances[msg.sender];\n    }\n\n    /// @notice Withdraw ether from bank\n    /// @dev This does not return any excess ether sent to it\n    /// @param withdrawAmount amount you want to withdraw\n    /// @return The balance remaining for the user\n    function withdraw(uint withdrawAmount) public returns (uint remainingBal) {\n        require(withdrawAmount <= balances[msg.sender]);\n\n        // Note the way we deduct the balance right away, before sending\n        // Every .transfer/.send from this contract can call an external function\n        // This may allow the caller to request an amount greater\n        // than their balance using a recursive call\n        // Aim to commit state before calling external functions, including .transfer/.send\n        balances[msg.sender] -= withdrawAmount;\n\n        // this automatically throws on a failure, which means the updated balance is reverted\n        msg.sender.transfer(withdrawAmount);\n\n        return balances[msg.sender];\n    }\n\n    /// @notice Get balance\n    /// @return The balance of the user\n    // 'view' (ex: constant) prevents function from editing state variables;\n    // allows function to run locally/off blockchain\n    function balance() view public returns (uint) {\n        return balances[msg.sender];\n    }\n}\n// ** END EXAMPLE **\n\n\n// Now, the basics of Solidity\n\n// 1. DATA TYPES AND ASSOCIATED METHODS\n// uint used for currency amount (there are no doubles\n//  or floats) and for dates (in unix time)\nuint x;\n\n// int of 256 bits, cannot be changed after instantiation\nint constant a = 8;\nint256 constant a = 8; // same effect as line above, here the 256 is explicit\nuint constant VERSION_ID = 0x123A1; // A hex constant\n// with 'constant', compiler replaces each occurrence with actual value\n\n// All state variables (those outside a function)\n// are by default 'internal' and accessible inside contract\n// and in all contracts that inherit ONLY\n// Need to explicitly set to 'public' to allow external contracts to access\nint256 public a = 8;\n\n// For int and uint, can explicitly set space in steps of 8 up to 256\n// e.g., int8, int16, int24\nuint8 b;\nint64 c;\nuint248 e;\n\n// Be careful that you don't overflow, and protect against attacks that do\n// For example, for an addition, you'd do:\nuint256 c = a + b;\nassert(c >= a); // assert tests for internal invariants; require is used for user inputs\n// For more examples of common arithmetic issues, see Zeppelin's SafeMath library\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n\n\n// No random functions built in, use other contracts for randomness\n\n// Type casting\nint x = int(b);\n\nbool b = true; // or do 'var b = true;' for inferred typing\n\n// Addresses - holds 20 byte/160 bit Ethereum addresses\n// No arithmetic allowed\naddress public owner;\n\n// Types of accounts:\n// Contract account: address set on create (func of creator address, num transactions sent)\n// External Account: (person/external entity): address created from public key\n\n// Add 'public' field to indicate publicly/externally accessible\n// a getter is automatically created, but NOT a setter\n\n// All addresses can be sent ether\nowner.transfer(SOME_BALANCE); // fails and reverts on failure\n\n// Can also do a lower level .send call, which returns a false if it failed\nif (owner.send) {} // REMEMBER: wrap send in 'if', as contract addresses have\n// functions executed on send and these can fail\n// Also, make sure to deduct balances BEFORE attempting a send, as there is a risk of a recursive\n// call that can drain the contract\n\n// Can check balance\nowner.balance; // the balance of the owner (user or contract)\n\n\n// Bytes available from 1 to 32\nbyte a; // byte is same as bytes1\nbytes2 b;\nbytes32 c;\n\n// Dynamically sized bytes\nbytes m; // A special array, same as byte[] array (but packed tightly)\n// More expensive than byte1-byte32, so use those when possible\n\n// same as bytes, but does not allow length or index access (for now)\nstring n = \"hello\"; // stored in UTF8, note double quotes, not single\n// string utility functions to be added in future\n// prefer bytes32/bytes, as UTF8 uses more storage\n\n// Type inference\n// var does inferred typing based on first assignment,\n// can't be used in functions parameters\nvar a = true;\n// use carefully, inference may provide wrong type\n// e.g., an int8, when a counter needs to be int16\n\n// var can be used to assign function to variable\nfunction a(uint x) returns (uint) {\n    return x * 2;\n}\nvar f = a;\nf(22); // call\n\n// by default, all values are set to 0 on instantiation\n\n// Delete can be called on most types\n// (does NOT destroy value, but sets value to 0, the initial value)\nuint x = 5;\n\n\n// Destructuring/Tuples\n(x, y) = (2, 7); // assign/swap multiple values\n\n\n// 2. DATA STRUCTURES\n// Arrays\nbytes32[5] nicknames; // static array\nbytes32[] names; // dynamic array\nuint newLength = names.push(\"John\"); // adding returns new length of the array\n// Length\nnames.length; // get length\nnames.length = 1; // lengths can be set (for dynamic arrays in storage only)\n\n// multidimensional array\nuint x[][5]; // arr with 5 dynamic array elements (opp order of most languages)\n\n// Dictionaries (any type to any other type)\nmapping (string => uint) public balances;\nbalances[\"charles\"] = 1;\n// balances[\"ada\"] result is 0, all non-set key values return zeroes\n// 'public' allows following from another contract\ncontractName.balances(\"charles\"); // returns 1\n// 'public' created a getter (but not setter) like the following:\nfunction balances(string _account) returns (uint balance) {\n    return balances[_account];\n}\n\n// Nested mappings\nmapping (address => mapping (address => uint)) public custodians;\n\n// To delete\ndelete balances[\"John\"];\ndelete balances; // sets all elements to 0\n\n// Unlike other languages, CANNOT iterate through all elements in\n// mapping, without knowing source keys - can build data structure\n// on top to do this\n\n// Structs\nstruct Bank {\n    address owner;\n    uint balance;\n}\nBank b = Bank({\n    owner: msg.sender,\n    balance: 5\n});\n// or\nBank c = Bank(msg.sender, 5);\n\nc.balance = 5; // set to new value\ndelete b;\n// sets to initial value, set all variables in struct to 0, except mappings\n\n// Enums\nenum State { Created, Locked, Inactive }; // often used for state machine\nState public state; // Declare variable from enum\nstate = State.Created;\n// enums can be explicitly converted to ints\nuint createdState = uint(State.Created); //  0\n\n// Data locations: Memory vs. storage vs. calldata - all complex types (arrays,\n// structs) have a data location\n// 'memory' does not persist, 'storage' does\n// Default is 'storage' for local and state variables; 'memory' for func params\n// stack holds small local variables\n\n// for most types, can explicitly set which data location to use\n\n\n// 3. Simple operators\n// Comparisons, bit operators and arithmetic operators are provided\n// exponentiation: **\n// exclusive or: ^\n// bitwise negation: ~\n\n\n// 4. Global Variables of note\n// ** this **\nthis; // address of contract\n// often used at end of contract life to transfer remaining balance to party\nthis.balance;\nthis.someFunction(); // calls func externally via call, not via internal jump\n\n// ** msg - Current message received by the contract ** **\nmsg.sender; // address of sender\nmsg.value; // amount of ether provided to this contract in wei, the function should be marked \"payable\"\nmsg.data; // bytes, complete call data\nmsg.gas; // remaining gas\n\n// ** tx - This transaction **\ntx.origin; // address of sender of the transaction\ntx.gasprice; // gas price of the transaction\n\n// ** block - Information about current block **\nnow; // current time (approximately), alias for block.timestamp (uses Unix time)\n// Note that this can be manipulated by miners, so use carefully\n\nblock.number; // current block number\nblock.difficulty; // current block difficulty\nblock.blockhash(1); // returns bytes32, only works for most recent 256 blocks\nblock.gasLimit();\n\n// ** storage - Persistent storage hash **\nstorage['abc'] = 'def'; // maps 256 bit words to 256 bit words\n\n\n// 4. FUNCTIONS AND MORE\n// A. Functions\n// Simple function\nfunction increment(uint x) returns (uint) {\n    x += 1;\n    return x;\n}\n\n// Functions can return many arguments, and by specifying returned arguments\n// name don't need to explicitly return\nfunction increment(uint x, uint y) returns (uint x, uint y) {\n    x += 1;\n    y += 1;\n}\n// Call previous functon\nuint (a,b) = increment(1,1);\n\n// 'view' (alias for 'constant')\n// indicates that function does not/cannot change persistent vars\n// View function execute locally, not on blockchain\n// Noted: constant keyword will soon be deprecated.\nuint y = 1;\n\nfunction increment(uint x) view returns (uint x) {\n    x += 1;\n    y += 1; // this line would fail\n    // y is a state variable, and can't be changed in a view function\n}\n\n// 'pure' is more strict than 'view' or 'constant', and does not\n// even allow reading of state vars\n// The exact rules are more complicated, so see more about\n// view/pure:\n// http://solidity.readthedocs.io/en/develop/contracts.html#view-functions\n\n// 'Function Visibility specifiers'\n// These can be placed where 'view' is, including:\n// public - visible externally and internally (default for function)\n// external - only visible externally (including a call made with this.)\n// private - only visible in the current contract\n// internal - only visible in current contract, and those deriving from it\n\n// Generally, a good idea to mark each function explicitly\n\n// Functions hoisted - and can assign a function to a variable\nfunction a() {\n    var z = b;\n    b();\n}\n\nfunction b() {\n\n}\n\n// All functions that receive ether must be marked 'payable'\nfunction depositEther() public payable {\n    balances[msg.sender] += msg.value;\n}\n\n\n// Prefer loops to recursion (max call stack depth is 1024)\n// Also, don't setup loops that you haven't bounded,\n// as this can hit the gas limit\n\n// B. Events\n// Events are notify external parties; easy to search and\n// access events from outside blockchain (with lightweight clients)\n// typically declare after contract parameters\n\n// Typically, capitalized - and add Log in front to be explicit and prevent confusion\n// with a function call\n\n// Declare\nevent LogSent(address indexed from, address indexed to, uint amount); // note capital first letter\n\n// Call\nLogSent(from, to, amount);\n\n/**\n\nFor an external party (a contract or external entity), to watch using\nthe Web3 Javascript library:\n\n// The following is Javascript code, not Solidity code\nCoin.LogSent().watch({}, '', function(error, result) {\n    if (!error) {\n        console.log(\"Coin transfer: \" + result.args.amount +\n            \" coins were sent from \" + result.args.from +\n            \" to \" + result.args.to + \".\");\n        console.log(\"Balances now:\\n\" +\n            \"Sender: \" + Coin.balances.call(result.args.from) +\n            \"Receiver: \" + Coin.balances.call(result.args.to));\n    }\n}\n**/\n\n// Common paradigm for one contract to depend on another (e.g., a\n// contract that depends on current exchange rate provided by another)\n\n// C. Modifiers\n// Modifiers validate inputs to functions such as minimal balance or user auth;\n// similar to guard clause in other languages\n\n// '_' (underscore) often included as last line in body, and indicates\n// function being called should be placed there\nmodifier onlyAfter(uint _time) { require (now >= _time); _; }\nmodifier onlyOwner { require(msg.sender == owner) _; }\n// commonly used with state machines\nmodifier onlyIfStateA (State currState) { require(currState == State.A) _; }\n\n// Append right after function declaration\nfunction changeOwner(newOwner)\nonlyAfter(someTime)\nonlyOwner()\nonlyIfState(State.A)\n{\n    owner = newOwner;\n}\n\n// underscore can be included before end of body,\n// but explicitly returning will skip, so use carefully\nmodifier checkValue(uint amount) {\n    _;\n    if (msg.value > amount) {\n        uint amountToRefund = amount - msg.value;\n        msg.sender.transfer(amountToRefund);\n    }\n}\n\n\n// 6. BRANCHING AND LOOPS\n\n// All basic logic blocks work - including if/else, for, while, break, continue\n// return - but no switch\n\n// Syntax same as javascript, but no type conversion from non-boolean\n// to boolean (comparison operators must be used to get the boolean val)\n\n// For loops that are determined by user behavior, be careful - as contracts have a maximal\n// amount of gas for a block of code - and will fail if that is exceeded\n// For example:\nfor(uint x = 0; x < refundAddressList.length; x++) {\n    refundAddressList[x].transfer(SOME_AMOUNT);\n}\n\n// Two errors above:\n// 1. A failure on transfer stops the loop from completing, tying up money\n// 2. This loop could be arbitrarily long (based on the amount of users who need refunds), and\n// therefore may always fail as it exceeds the max gas for a block\n// Instead, you should let people withdraw individually from their subaccount, and mark withdrawn\n// e.g., favor pull payments over push payments\n\n\n// 7. OBJECTS/CONTRACTS\n\n// A. Calling external contract\ncontract InfoFeed {\n    function info() payable returns (uint ret)  { return 42; }\n}\n\ncontract Consumer {\n    InfoFeed feed; // points to contract on blockchain\n\n    // Set feed to existing contract instance\n    function setFeed(address addr) {\n        // automatically cast, be careful; constructor is not called\n        feed = InfoFeed(addr);\n    }\n\n    // Set feed to new instance of contract\n    function createNewFeed() {\n        feed = new InfoFeed(); // new instance created; constructor called\n    }\n\n    function callFeed() {\n        // final parentheses call contract, can optionally add\n        // custom ether value or gas\n        feed.info.value(10).gas(800)();\n    }\n}\n\n// B. Inheritance\n\n// Order matters, last inherited contract (i.e., 'def') can override parts of\n// previously inherited contracts\ncontract MyContract is abc, def(\"a custom argument to def\") {\n\n// Override function\n    function z() {\n        if (msg.sender == owner) {\n            def.z(); // call overridden function from def\n            super.z(); // call immediate parent overridden function\n        }\n    }\n}\n\n// abstract function\nfunction someAbstractFunction(uint x);\n// cannot be compiled, so used in base/abstract contracts\n// that are then implemented\n\n// C. Import\n\nimport \"filename\";\nimport \"github.com/ethereum/dapp-bin/library/iterable_mapping.sol\";\n\n\n// 8. OTHER KEYWORDS\n\n// A. Selfdestruct\n// selfdestruct current contract, sending funds to address (often creator)\nselfdestruct(SOME_ADDRESS);\n\n// removes storage/code from current/future blocks\n// helps thin clients, but previous data persists in blockchain\n\n// Common pattern, lets owner end the contract and receive remaining funds\nfunction remove() {\n    if(msg.sender == creator) { // Only let the contract creator do this\n        selfdestruct(creator); // Makes contract inactive, returns funds\n    }\n}\n\n// May want to deactivate contract manually, rather than selfdestruct\n// (ether sent to selfdestructed contract is lost)\n\n\n// 9. CONTRACT DESIGN NOTES\n\n// A. Obfuscation\n// All variables are publicly viewable on blockchain, so anything\n// that is private needs to be obfuscated (e.g., hashed w/secret)\n\n// Steps: 1. Commit to something, 2. Reveal commitment\nkeccak256(\"some_bid_amount\", \"some secret\"); // commit\n\n// call contract's reveal function in the future\n// showing bid plus secret that hashes to SHA3\nreveal(100, \"mySecret\");\n\n// B. Storage optimization\n// Writing to blockchain can be expensive, as data stored forever; encourages\n// smart ways to use memory (eventually, compilation will be better, but for now\n// benefits to planning data structures - and storing min amount in blockchain)\n\n// Cost can often be high for items like multidimensional arrays\n// (cost is for storing data - not declaring unfilled variables)\n\n// C. Data access in blockchain\n// Cannot restrict human or computer from reading contents of\n// transaction or transaction's state\n\n// While 'private' prevents other *contracts* from reading data\n// directly - any other party can still read data in blockchain\n\n// All data to start of time is stored in blockchain, so\n// anyone can observe all previous data and changes\n\n// D. Cron Job\n// Contracts must be manually called to handle time-based scheduling; can create external\n// code to regularly ping, or provide incentives (ether) for others to\n\n// E. Observer Pattern\n// An Observer Pattern lets you register as a subscriber and\n// register a function which is called by the oracle (note, the oracle pays\n// for this action to be run)\n// Some similarities to subscription in Pub/sub\n\n// This is an abstract contract, both client and server classes import\n// the client should implement\ncontract SomeOracleCallback {\n    function oracleCallback(int _value, uint _time, bytes32 info) external;\n}\n\ncontract SomeOracle {\n    SomeOracleCallback[] callbacks; // array of all subscribers\n\n    // Register subscriber\n    function addSubscriber(SomeOracleCallback a) {\n        callbacks.push(a);\n    }\n\n    function notify(value, time, info) private {\n        for(uint i = 0;i < callbacks.length; i++) {\n            // all called subscribers must implement the oracleCallback\n            callbacks[i].oracleCallback(value, time, info);\n        }\n    }\n\n    function doSomething() public {\n        // Code to do something\n\n        // Notify all subscribers\n        notify(_value, _time, _info);\n    }\n}\n\n// Now, your client contract can addSubscriber by importing SomeOracleCallback\n// and registering with Some Oracle\n\n// F. State machines\n// see example below for State enum and inState modifier\n\n\n// *** EXAMPLE: A crowdfunding example (broadly similar to Kickstarter) ***\n// ** START EXAMPLE **\n\n// CrowdFunder.sol\npragma solidity ^0.4.19;\n\n/// @title CrowdFunder\n/// @author nemild\ncontract CrowdFunder {\n    // Variables set on create by creator\n    address public creator;\n    address public fundRecipient; // creator may be different than recipient\n    uint public minimumToRaise; // required to tip, else everyone gets refund\n    string campaignUrl;\n    byte constant version = 1;\n\n    // Data structures\n    enum State {\n        Fundraising,\n        ExpiredRefund,\n        Successful\n    }\n    struct Contribution {\n        uint amount;\n        address contributor;\n    }\n\n    // State variables\n    State public state = State.Fundraising; // initialize on create\n    uint public totalRaised;\n    uint public raiseBy;\n    uint public completeAt;\n    Contribution[] contributions;\n\n    event LogFundingReceived(address addr, uint amount, uint currentTotal);\n    event LogWinnerPaid(address winnerAddress);\n\n    modifier inState(State _state) {\n        require(state == _state);\n        _;\n    }\n\n    modifier isCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n\n    // Wait 24 weeks after final contract state before allowing contract destruction\n    modifier atEndOfLifecycle() {\n    require(((state == State.ExpiredRefund || state == State.Successful) &&\n        completeAt + 24 weeks < now));\n        _;\n    }\n\n    function CrowdFunder(\n        uint timeInHoursForFundraising,\n        string _campaignUrl,\n        address _fundRecipient,\n        uint _minimumToRaise)\n        public\n    {\n        creator = msg.sender;\n        fundRecipient = _fundRecipient;\n        campaignUrl = _campaignUrl;\n        minimumToRaise = _minimumToRaise;\n        raiseBy = now + (timeInHoursForFundraising * 1 hours);\n    }\n\n    function contribute()\n    public\n    payable\n    inState(State.Fundraising)\n    returns(uint256 id)\n    {\n        contributions.push(\n            Contribution({\n                amount: msg.value,\n                contributor: msg.sender\n            }) // use array, so can iterate\n        );\n        totalRaised += msg.value;\n\n        LogFundingReceived(msg.sender, msg.value, totalRaised);\n\n        checkIfFundingCompleteOrExpired();\n        return contributions.length - 1; // return id\n    }\n\n    function checkIfFundingCompleteOrExpired()\n    public\n    {\n        if (totalRaised > minimumToRaise) {\n            state = State.Successful;\n            payOut();\n\n            // could incentivize sender who initiated state change here\n        } else if ( now > raiseBy )  {\n            state = State.ExpiredRefund; // backers can now collect refunds by calling getRefund(id)\n        }\n        completeAt = now;\n    }\n\n    function payOut()\n    public\n    inState(State.Successful)\n    {\n        fundRecipient.transfer(this.balance);\n        LogWinnerPaid(fundRecipient);\n    }\n\n    function getRefund(uint256 id)\n    inState(State.ExpiredRefund)\n    public\n    returns(bool)\n    {\n        require(contributions.length > id && id >= 0 && contributions[id].amount != 0 );\n\n        uint256 amountToRefund = contributions[id].amount;\n        contributions[id].amount = 0;\n\n        contributions[id].contributor.transfer(amountToRefund);\n\n        return true;\n    }\n\n    function removeContract()\n    public\n    isCreator()\n    atEndOfLifecycle()\n    {\n        selfdestruct(msg.sender);\n        // creator gets all money that hasn't be claimed\n    }\n}\n// ** END EXAMPLE **\n\n// 10. OTHER NATIVE FUNCTIONS\n\n// Currency units\n// Currency is defined using wei, smallest unit of Ether\nuint minAmount = 1 wei;\nuint a = 1 finney; // 1 ether == 1000 finney\n// Other units, see: http://ether.fund/tool/converter\n\n// Time units\n1 == 1 second\n1 minutes == 60 seconds\n\n// Can multiply a variable times unit, as units are not stored in a variable\nuint x = 5;\n(x * 1 days); // 5 days\n\n// Careful about leap seconds/years with equality statements for time\n// (instead, prefer greater than/less than)\n\n// Cryptography\n// All strings passed are concatenated before hash action\nsha3(\"ab\", \"cd\");\nripemd160(\"abc\");\nsha256(\"def\");\n\n// 11. SECURITY\n\n// Bugs can be disastrous in Ethereum contracts - and even popular patterns in Solidity,\n// may be found to be antipatterns\n\n// See security links at the end of this doc\n\n// 12. LOW LEVEL FUNCTIONS\n// call - low level, not often used, does not provide type safety\nsuccessBoolean = someContractAddress.call('function_name', 'arg1', 'arg2');\n\n// callcode - Code at target address executed in *context* of calling contract\n// provides library functionality\nsomeContractAddress.callcode('function_name');\n\n\n// 13. STYLE NOTES\n// Based on Python's PEP8 style guide\n// Full Style guide: http://solidity.readthedocs.io/en/develop/style-guide.html\n\n// Quick summary:\n// 4 spaces for indentation\n// Two lines separate contract declarations (and other top level declarations)\n// Avoid extraneous spaces in parentheses\n// Can omit curly braces for one line statement (if, for, etc)\n// else should be placed on own line\n\n\n// 14. NATSPEC COMMENTS\n// used for documentation, commenting, and external UIs\n\n// Contract natspec - always above contract definition\n/// @title Contract title\n/// @author Author name\n\n// Function natspec\n/// @notice information about what function does; shown when function to execute\n/// @dev Function documentation for developer\n\n// Function parameter/return value natspec\n/// @param someParam Some description of what the param does\n/// @return Description of the return value\n```\n\n## Additional resources\n- [Solidity Docs](https://solidity.readthedocs.org/en/latest/)\n- [Smart Contract Best Practices](https://github.com/ConsenSys/smart-contract-best-practices)\n- [Superblocks Lab - Browser based IDE for Solidity](https://lab.superblocks.com/)\n- [EthFiddle - The JsFiddle for Solidity](https://ethfiddle.com/)\n- [Browser-based Solidity Editor](https://remix.ethereum.org/)\n- [Gitter Solidity Chat room](https://gitter.im/ethereum/solidity)\n- [Modular design strategies for Ethereum Contracts](https://docs.erisindustries.com/tutorials/solidity/)\n\n## Important libraries\n- [Zeppelin](https://github.com/OpenZeppelin/zeppelin-solidity/): Libraries that provide common contract patterns (crowdfuding, safemath, etc)\n\n## Sample contracts\n- [Dapp Bin](https://github.com/ethereum/dapp-bin)\n- [Solidity Baby Step Contracts](https://github.com/fivedogit/solidity-baby-steps/tree/master/contracts)\n- [ConsenSys Contracts](https://github.com/ConsenSys/dapp-store-contracts)\n- [State of Dapps](http://dapps.ethercasts.com/)\n\n## Security\n- [Thinking About Smart Contract Security](https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/)\n- [Smart Contract Security](https://blog.ethereum.org/2016/06/10/smart-contract-security/)\n- [Hacking Distributed Blog](http://hackingdistributed.com/)\n\n## Style\n- [Solidity Style Guide](http://solidity.readthedocs.io/en/latest/style-guide.html): Ethereum's style guide is heavily derived from Python's [PEP 8](https://www.python.org/dev/peps/pep-0008/) style guide.\n\n## Editors\n- [Emacs Solidity Mode](https://github.com/ethereum/emacs-solidity)\n- [Vim Solidity](https://github.com/tomlion/vim-solidity)\n- Editor Snippets ([Ultisnips format](https://gist.github.com/nemild/98343ce6b16b747788bc))\n\n## Future To Dos\n- New keywords: protected, inheritable\n- List of common design patterns (throttling, RNG, version upgrade)\n- Common security anti patterns\n\nFeel free to send a pull request with any edits - or email nemild -/at-/ gmail"
