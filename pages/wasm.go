
package pages

const Wasm = "```\n;; learn-wasm.wast\n\n(module\n  ;; In WebAssembly, everything is included in a module. Moreover, everything\n  ;; can be expressed as an s-expression. Alternatively, there is the\n  ;; \"stack machine\" syntax, but that is not compatible with Binaryen\n  ;; intermediate representation (IR) syntax.\n\n  ;; The Binaryen IR format is *mostly* compatible with WebAssembly text format.\n  ;; There are some small differences:\n  ;; local_set -> local.set\n  ;; local_get -> local.get\n\n  ;; We have to enclose code in functions\n\n  ;; Data Types\n  (func $data_types\n    ;; WebAssembly has only four types:\n    ;; i32 - 32 bit integer\n    ;; i64 - 64 bit integer (not supported in JavaScript)\n    ;; f32 - 32 bit floating point\n    ;; f64 - 64 bit floating point\n\n    ;; We can declare local variables with the \"local\" keyword\n    ;; We have to declare all variables before we start doing anything\n    ;; inside the function\n\n    (local $int_32 i32)\n    (local $int_64 i64)\n    (local $float_32 f32)\n    (local $float_64 f64)\n\n    ;; These values remain uninitialized.\n    ;; To set them to a value, we can use <type>.const:\n\n    (local.set $int_32 (i32.const 16))\n    (local.set $int_32 (i64.const 128))\n    (local.set $float_32 (f32.const 3.14))\n    (local.set $float_64 (f64.const 1.28))\n  )\n\n  ;; Basic operations\n  (func $basic_operations\n\n    ;; In WebAssembly, everything is an s-expression, including\n    ;; doing math, or getting the value of some variable\n\n    (local $add_result i32)\n    (local $mult_result f64)\n\n    (local.set $add_result (i32.add (i32.const 2) (i32.const 4)))\n    ;; the value of add_result is now 6!\n\n    ;; We have to use the right data type for each operation:\n    ;; (local.set $mult_result (f32.mul (f32.const 2.0) (f32.const 4.0))) ;; WRONG! mult_result is f64!\n    (local.set $mult_result (f64.mul (f64.const 2.0) (f64.const 4.0)))\n\n    ;; WebAssembly has some builtin operations, like basic math and bitshifting.\n    ;; Notably, it does not have built in trigonometric functions.\n    ;; In order to get access to these functions, we have to either\n    ;; - implement them ourselves (not recommended)\n    ;; - import them from elsewhere (later on)\n  )\n\n  ;; Functions\n  ;; We specify arguments with the `param` keyword, and specify return values\n  ;; with the `result` keyword\n  ;; The current value on the stack is the return value of a function\n\n  ;; We can call other functions we've defined with the `call` keyword\n\n  (func $get_16 (result i32)\n    (i32.const 16)\n  )\n\n  (func $add (param $param0 i32) (param $param1 i32) (result i32)\n    (i32.add\n      (local.get $param0)\n      (local.get $param1)\n    )\n  )\n\n  (func $double_16 (result i32)\n    (i32.mul\n      (i32.const 2)\n      (call $get_16))\n  )\n\n  ;; Up until now, we haven't be able to print anything out, nor do we have\n  ;; access to higher level math functions (pow, exp, or trig functions).\n  ;; Moreover, we haven't been able to use any of the WASM functions in Javascript!\n  ;; The way we get those functions into WebAssembly\n  ;; looks different whether we're in a Node.js or browser environment.\n\n  ;; If we're in Node.js we have to do two steps. First we have to convert the\n  ;; WASM text representation into actual webassembly. If we're using Binyaren,\n  ;; we can do that with a command like the following:\n\n  ;; wasm-as learn-wasm.wast -o learn-wasm.wasm\n\n  ;; We can apply Binaryen optimizations to that file with a command like the\n  ;; following:\n\n  ;; wasm-opt learn-wasm.wasm -o learn-wasm.opt.wasm -O3 --rse\n\n  ;; With our compiled WebAssembly, we can now load it into Node.js:\n  ;; const fs = require('fs')\n  ;; const instantiate = async function (inFilePath, _importObject) {\n  ;;  var importObject = {\n  ;;     console: {\n  ;;       log: (x) => console.log(x),\n  ;;     },\n  ;;     math: {\n  ;;       cos: (x) => Math.cos(x),\n  ;;     }\n  ;;   }\n  ;;  importObject = Object.assign(importObject, _importObject)\n  ;;\n  ;;  var buffer = fs.readFileSync(inFilePath)\n  ;;  var module = await WebAssembly.compile(buffer)\n  ;;  var instance = await WebAssembly.instantiate(module, importObject)\n  ;;  return instance.exports\n  ;; }\n  ;;\n  ;; const main = function () {\n  ;;   var wasmExports = await instantiate('learn-wasm.wasm')\n  ;;   wasmExports.print_args(1, 0)\n  ;; }\n\n  ;; The following snippet gets the functions from the importObject we defined\n  ;; in the JavaScript instantiate async function, and then exports a function\n  ;; \"print_args\" that we can call from Node.js\n\n  (import \"console\" \"log\" (func $print_i32 (param i32)))\n  (import \"math\" \"cos\" (func $cos (param f64) (result f64)))\n\n  (func $print_args (param $arg0 i32) (param $arg1 i32)\n    (call $print_i32 (local.get $arg0))\n    (call $print_i32 (local.get $arg1))\n  )\n  (export \"print_args\" (func $print_args))\n\n  ;; Loading in data from WebAssembly memory.\n  ;; Say that we want to apply the cosine function to a Javascript array.\n  ;; We need to be able to access the allocated array, and iterate through it.\n  ;; This example will modify the input array inplace.\n  ;; f64.load and f64.store expect the location of a number in memory *in bytes*.\n  ;; If we want to access the 3rd element of an array, we have to pass something\n  ;; like (i32.mul (i32.const 8) (i32.const 2)) to the f64.store function.\n\n  ;; In JavaScript, we would call `apply_cos64` as follows\n  ;; (using the instantiate function from earlier):\n  ;;\n  ;; const main = function () {\n  ;;   var wasm = await instantiate('learn-wasm.wasm')\n  ;;   var n = 100\n  ;;   const memory = new Float64Array(wasm.memory.buffer, 0, n)\n  ;;   for (var i=0; i<n; i++) {\n  ;;     memory[i] = i;\n  ;;   }\n  ;;   wasm.apply_cos64(n)\n  ;; }\n  ;;\n  ;; This function will not work if we allocate a Float32Array on the JavaScript\n  ;; side.\n\n  (memory (export \"memory\") 100)\n\n  (func $apply_cos64 (param $array_length i32)\n    ;; declare the loop counter\n    (local $idx i32)\n    ;; declare the counter that will allow us to access memory\n    (local $idx_bytes i32)\n    ;; constant expressing the number of bytes in a f64 number.\n    (local $bytes_per_double i32)\n\n    ;; declare a variable for storing the value loaded from memory\n    (local $temp_f64 f64)\n\n    (local.set $idx (i32.const 0))\n    (local.set $idx_bytes (i32.const 0)) ;; not entirely necessary\n    (local.set $bytes_per_double (i32.const 8))\n\n    (block\n      (loop\n        ;; this sets idx_bytes to bytes offset of the value we're interested in.\n        (local.set $idx_bytes (i32.mul (local.get $idx) (local.get $bytes_per_double)))\n\n        ;; get the value of the array from memory:\n        (local.set $temp_f64 (f64.load (local.get $idx_bytes)))\n\n        ;; now apply the cosine function:\n        (local.set $temp_64 (call $cos (local.get $temp_64)))\n\n        ;; now store the result at the same location in memory:\n        (f64.store\n          (local.get $idx_bytes)\n          (local.get $temp_64))\n\n        ;; do it all in one step instead\n        (f64.store\n          (local.get $idx_bytes)\n          (call $cos\n            (f64.load\n              (local.get $idx_bytes))))\n\n        ;; increment the loop counter\n        (local.set $idx (i32.add (local.get $idx) (i32.const 1)))\n\n        ;; stop the loop if the loop counter is equal the array length\n        (br_if 1 (i32.eq (local.get $idx) (local.get $array_length)))\n        (br 0)\n      )\n    )\n  )\n  (export \"apply_cos64\" (func $apply_cos64))\n\n  ;; Wasm is a stack-based language, but for returning values more complicated\n  ;; than an int/float, a separate memory stack has to be manually managed. One\n  ;; approach is to use a mutable global to store the stack_ptr. We give\n  ;; ourselves 1MiB of memstack and grow it downwards.\n  ;;\n  ;; Below is a demonstration of how this C code **might** be written by hand\n  ;;\n  ;;   typedef struct {\n  ;;       int a;\n  ;;       int b;\n  ;;   } sum_struct_t;\n  ;;\n  ;;   sum_struct_t sum_struct_create(int a, int b) {\n  ;;     return (sum_struct_t){a, b};\n  ;;   }\n  ;;\n  ;;   int sum_local() {\n  ;;     sum_struct_t s = sum_struct_create(40, 2);\n  ;;     return s.a + s.b;\n  ;;   }\n\n  ;; Unlike C, we must manage our own memory stack. We reserve 1MiB\n  (global $memstack_ptr (mut i32) (i32.const 65536))\n\n  ;; Structs can only be returned by reference\n  (func $sum_struct_create \n        (param $sum_struct_ptr i32) \n        (param $var$a i32) \n        (param $var$b i32)\n    ;; c// sum_struct_ptr->a = a;\n    (i32.store\n      (get_local $sum_struct_ptr)\n      (get_local $var$a)\n    )\n\n    ;; c// sum_struct_ptr->b = b;\n    (i32.store offset=4\n      (get_local $sum_struct_ptr)\n      (get_local $var$b)\n    )\n  )\n\n  (func $sum_local (result i32)\n    (local $var$sum_struct$a i32)\n    (local $var$sum_struct$b i32)\n    (local $local_memstack_ptr i32)\n\n    ;; reserve memstack space\n    (i32.sub\n      (get_global $memstack_ptr)\n      (i32.const 8)\n    )\n    tee_local $local_memstack_ptr ;; tee both stores and returns given value\n    set_global $memstack_ptr\n\n    ;; call the function, storing the result in the memstack\n    (call $sum_struct_create\n      ((;$sum_struct_ptr=;) get_local $local_memstack_ptr)\n      ((;$var$a=;) i32.const 40)\n      ((;$var$b=;) i32.const 2)\n    )\n\n    ;; retrieve values from struct\n    (set_local $var$sum_struct$a\n      (i32.load offset=0 (get_local $local_memstack_ptr))\n    )\n    (set_local $var$sum_struct$b\n      (i32.load offset=4 (get_local $local_memstack_ptr))\n    )\n\n    ;; unreserve memstack space\n    (set_global $memstack_ptr\n        (i32.add\n          (get_local $local_memstack_ptr)\n          (i32.const 8)\n        )\n    )\n\n    (i32.add\n      (get_local $var$sum_struct$a)\n      (get_local $var$sum_struct$b)\n    )\n  )\n  (export \"sum_local\" (func $sum_local))\n)\n\n```"
