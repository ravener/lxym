
package pages

const Ruby = "```ruby\n# This is a comment\n\n=begin\nThis is a multi-line comment.\nThe beginning line must start with \"=begin\"\nand the ending line must start with \"=end\".\n\nYou can do this, or start each line in\na multi-line comment with the # character.\n=end\n\n# In Ruby, (almost) everything is an object.\n# This includes numbers...\n3.class #=> Integer\n\n# ...and strings...\n\"Hello\".class #=> String\n\n# ...and even methods!\n\"Hello\".method(:class).class #=> Method\n\n# Some basic arithmetic\n1 + 1 #=> 2\n8 - 1 #=> 7\n10 * 2 #=> 20\n35 / 5 #=> 7\n2 ** 5 #=> 32\n5 % 3 #=> 2\n\n# Bitwise operators\n3 & 5 #=> 1\n3 | 5 #=> 7\n3 ^ 5 #=> 6\n\n# Arithmetic is just syntactic sugar\n# for calling a method on an object\n1.+(3) #=> 4\n10.* 5 #=> 50\n100.methods.include?(:/) #=> true\n\n# Special values are objects\nnil # equivalent to null in other languages\ntrue # truth\nfalse # falsehood\n\nnil.class #=> NilClass\ntrue.class #=> TrueClass\nfalse.class #=> FalseClass\n\n# Equality\n1 == 1 #=> true\n2 == 1 #=> false\n\n# Inequality\n1 != 1 #=> false\n2 != 1 #=> true\n\n# Apart from false itself, nil is the only other 'falsey' value\n\n!!nil   #=> false\n!!false #=> false\n!!0     #=> true\n!!\"\"    #=> true\n\n# More comparisons\n1 < 10 #=> true\n1 > 10 #=> false\n2 <= 2 #=> true\n2 >= 2 #=> true\n\n# Combined comparison operator (returns `1` when the first argument is greater, \n# `-1` when the second argument is greater, and `0` otherwise)\n1 <=> 10 #=> -1 (1 < 10)\n10 <=> 1 #=> 1 (10 > 1)\n1 <=> 1 #=> 0 (1 == 1)\n\n# Logical operators\ntrue && false #=> false\ntrue || false #=> true\n\n# There are alternate versions of the logical operators with much lower\n# precedence. These are meant to be used as flow-control constructs to chain\n# statements together until one of them returns true or false.\n\n# `do_something_else` only called if `do_something` succeeds.\ndo_something() and do_something_else()\n# `log_error` only called if `do_something` fails.\ndo_something() or log_error()\n\n# String interpolation\n\nplaceholder = 'use string interpolation'\n\"I can #{placeholder} when using double quoted strings\"\n#=> \"I can use string interpolation when using double quoted strings\"\n\n# You can combine strings using `+`, but not with other types\n'hello ' + 'world'  #=> \"hello world\"\n'hello ' + 3 #=> TypeError: can't convert Fixnum into String\n'hello ' + 3.to_s #=> \"hello 3\"\n\"hello #{3}\" #=> \"hello 3\"\n\n# ...or combine strings and operators\n'hello ' * 3 #=> \"hello hello hello \"\n\n# ...or append to string\n'hello' << ' world' #=> \"hello world\"\n\n# You can print to the output with a newline at the end\nputs \"I'm printing!\"\n#=> I'm printing!\n#=> nil\n\n# ...or print to the output without a newline\nprint \"I'm printing!\"\n#=> \"I'm printing!\" => nil\n\n# Variables\nx = 25 #=> 25\nx #=> 25\n\n# Note that assignment returns the value assigned.\n# This means you can do multiple assignment.\n\nx = y = 10 #=> 10\nx #=> 10\ny #=> 10\n\n# By convention, use snake_case for variable names.\nsnake_case = true\n\n# Use descriptive variable names\npath_to_project_root = '/good/name/'\nm = '/bad/name/'\n\n# Symbols are immutable, reusable constants represented internally by an\n# integer value. They're often used instead of strings to efficiently convey\n# specific, meaningful values.\n\n:pending.class #=> Symbol\n\nstatus = :pending\n\nstatus == :pending #=> true\n\nstatus == 'pending' #=> false\n\nstatus == :approved #=> false\n\n# Strings can be converted into symbols and vice versa.\nstatus.to_s #=> \"pending\"\n\"argon\".to_sym #=> :argon\n\n# Arrays\n\n# This is an array.\narray = [1, 2, 3, 4, 5] #=> [1, 2, 3, 4, 5]\n\n# Arrays can contain different types of items.\n[1, 'hello', false] #=> [1, \"hello\", false]\n\n# You might prefer %w instead of quotes\n%w[foo bar baz] #=> [\"foo\", \"bar\", \"baz\"]\n\n# Arrays can be indexed.\n# From the front...\narray[0] #=> 1\narray.first #=> 1\narray[12] #=> nil\n\n# ...or from the back...\narray[-1] #=> 5\narray.last #=> 5\n\n# ...or with a start index and length...\narray[2, 3] #=> [3, 4, 5]\n\n# ...or with a range...\narray[1..3] #=> [2, 3, 4]\n\n# You can reverse an Array.\n# Return a new array with reversed values\n[1,2,3].reverse #=> [3,2,1]\n# Reverse an array in place to update variable with reversed values\na = [1,2,3]\na.reverse! #=> a==[3,2,1] because of the bang ('!') call to reverse\n\n# Like arithmetic, [var] access is just syntactic sugar\n# for calling a method '[]' on an object.\narray.[] 0 #=> 1\narray.[] 12 #=> nil\n\n# You can add to an array...\narray << 6 #=> [1, 2, 3, 4, 5, 6]\n# Or like this\narray.push(6) #=> [1, 2, 3, 4, 5, 6]\n\n# ...and check if an item exists in an array\narray.include?(1) #=> true\n\n# Hashes are Ruby's primary dictionary with key/value pairs.\n# Hashes are denoted with curly braces.\nhash = { 'color' => 'green', 'number' => 5 }\n\nhash.keys #=> ['color', 'number']\n\n# Hashes can be quickly looked up by key.\nhash['color'] #=> \"green\"\nhash['number'] #=> 5\n\n# Asking a hash for a key that doesn't exist returns nil.\nhash['nothing here'] #=> nil\n\n# When using symbols for keys in a hash, you can use an alternate syntax.\n\nhash = { :defcon => 3, :action => true }\nhash.keys #=> [:defcon, :action]\n\nhash = { defcon: 3, action: true }\nhash.keys #=> [:defcon, :action]\n\n# Check existence of keys and values in hash\nhash.key?(:defcon) #=> true\nhash.value?(3) #=> true\n\n# Tip: Both Arrays and Hashes are Enumerable!\n# They share a lot of useful methods such as each, map, count, and more.\n\n# Control structures\n\n# Conditionals\nif true\n  'if statement'\nelsif false\n  'else if, optional'\nelse\n  'else, also optional'\nend\n\n# If a condition controls invocation of a single statement rather than a block of code\n# you can use postfix-if notation\nwarnings = ['Patronimic is missing', 'Address too short']\nputs(\"Some warnings occurred:\\n\" + warnings.join(\"\\n\"))  if !warnings.empty?\n\n# Rephrase condition if `unless` sounds better than `if`\nputs(\"Some warnings occurred:\\n\" + warnings.join(\"\\n\"))  unless warnings.empty?\n\n# Loops\n# In Ruby, traditional `for` loops aren't very common. Instead, these \n# basic loops are implemented using enumerable, which hinges on `each`.\n(1..5).each do |counter|\n  puts \"iteration #{counter}\"\nend\n\n# Which is roughly equivalent to the following, which is unusual to see in Ruby.\nfor counter in 1..5\n  puts \"iteration #{counter}\"\nend\n\n# The `do |variable| ... end` construct above is called a 'block'. Blocks are similar\n# to lambdas, anonymous functions or closures in other programming languages. They can\n# be passed around as objects, called, or attached as methods.\n#\n# The 'each' method of a range runs the block once for each element of the range.\n# The block is passed a counter as a parameter.\n\n# You can also surround blocks in curly brackets.\n(1..5).each { |counter| puts \"iteration #{counter}\" }\n\n# The contents of data structures can also be iterated using each.\narray.each do |element|\n  puts \"#{element} is part of the array\"\nend\nhash.each do |key, value|\n  puts \"#{key} is #{value}\"\nend\n\n# If you still need an index you can use 'each_with_index' and define an index\n# variable.\narray.each_with_index do |element, index|\n  puts \"#{element} is number #{index} in the array\"\nend\n\ncounter = 1\nwhile counter <= 5 do\n  puts \"iteration #{counter}\"\n  counter += 1\nend\n#=> iteration 1\n#=> iteration 2\n#=> iteration 3\n#=> iteration 4\n#=> iteration 5\n\n# There are a bunch of other helpful looping functions in Ruby.\n# For example: 'map', 'reduce', 'inject', the list goes on.\n# Map, for instance, takes the array it's looping over, does something\n# to it as defined in your block, and returns an entirely new array.\narray = [1,2,3,4,5]\ndoubled = array.map do |element|\n  element * 2\nend\nputs doubled\n#=> [2,4,6,8,10]\nputs array\n#=> [1,2,3,4,5]\n\n# another useful syntax is .map(&:method)\na = [\"FOO\", \"BAR\", \"BAZ\"]\na.map { |s| s.downcase } #=> [\"foo\", \"bar\", \"baz\"]\na.map(&:downcase) #=> [\"foo\", \"bar\", \"baz\"]\n\n# Case construct\ngrade = 'B'\n\ncase grade\nwhen 'A'\n  puts 'Way to go kiddo'\nwhen 'B'\n  puts 'Better luck next time'\nwhen 'C'\n  puts 'You can do better'\nwhen 'D'\n  puts 'Scraping through'\nwhen 'F'\n  puts 'You failed!'\nelse\n  puts 'Alternative grading system, eh?'\nend\n#=> \"Better luck next time\"\n\n# Cases can also use ranges\ngrade = 82\ncase grade\nwhen 90..100\n  puts 'Hooray!'\nwhen 80...90\n  puts 'OK job'\nelse\n  puts 'You failed!'\nend\n#=> \"OK job\"\n\n# Exception handling\nbegin\n  # Code here that might raise an exception\n  raise NoMemoryError, 'You ran out of memory.'\nrescue NoMemoryError => exception_variable\n  puts 'NoMemoryError was raised', exception_variable\nrescue RuntimeError => other_exception_variable\n  puts 'RuntimeError was raised now'\nelse\n  puts 'This runs if no exceptions were thrown at all'\nensure\n  puts 'This code always runs no matter what'\nend\n\n# Methods\n\ndef double(x)\n  x * 2\nend\n\n# Methods (and blocks) implicitly return the value of the last statement.\ndouble(2) #=> 4\n\n# Parentheses are optional where the interpretation is unambiguous.\ndouble 3 #=> 6\n\ndouble double 3 #=> 12\n\ndef sum(x, y)\n  x + y\nend\n\n# Method arguments are separated by a comma.\nsum 3, 4 #=> 7\n\nsum sum(3, 4), 5 #=> 12\n\n# yield\n# All methods have an implicit, optional block parameter.\n# It can be called with the 'yield' keyword.\ndef surround\n  puts '{'\n  yield\n  puts '}'\nend\n\nsurround { puts 'hello world' }\n\n#=> {\n#=> hello world\n#=> }\n\n# Blocks can be converted into a 'proc' object, which wraps the block \n# and allows it to be passed to another method, bound to a different scope,\n# or manipulated otherwise. This is most common in method parameter lists,\n# where you frequently see a trailing '&block' parameter that will accept \n# the block, if one is given, and convert it to a 'Proc'. The naming here is\n# convention; it would work just as well with '&pineapple'.\ndef guests(&block)\n  block.class #=> Proc\n  block.call(4)\nend\n\n# The 'call' method on the Proc is similar to calling 'yield' when a block is \n# present. The arguments passed to 'call' will be forwarded to the block as arguments.\n\nguests { |n| \"You have #{n} guests.\" }\n# => \"You have 4 guests.\"\n\n# You can pass a list of arguments, which will be converted into an array.\n# That's what splat operator (\"*\") is for.\ndef guests(*array)\n  array.each { |guest| puts guest }\nend\n\n# There is also the shorthand block syntax. It's most useful when you need\n# to call a simple method on all array items.\nupcased = ['Watch', 'these', 'words', 'get', 'upcased'].map(&:upcase)\nputs upcased\n#=> [\"WATCH\", \"THESE\", \"WORDS\", \"GET\", \"UPCASED\"]\n \nsum = [1, 2, 3, 4, 5].reduce(&:+)\nputs sum\n#=> 15\n\n# Destructuring\n\n# Ruby will automatically destructure arrays on assignment to multiple variables.\na, b, c = [1, 2, 3]\na #=> 1\nb #=> 2\nc #=> 3\n\n# In some cases, you will want to use the splat operator: `*` to prompt destructuring\n# of an array into a list.\nranked_competitors = [\"John\", \"Sally\", \"Dingus\", \"Moe\", \"Marcy\"]\n\ndef best(first, second, third)\n  puts \"Winners are #{first}, #{second}, and #{third}.\"\nend\n\nbest *ranked_competitors.first(3) #=> Winners are John, Sally, and Dingus.\n\n# The splat operator can also be used in parameters.\ndef best(first, second, third, *others)\n  puts \"Winners are #{first}, #{second}, and #{third}.\"\n  puts \"There were #{others.count} other participants.\"\nend\n\nbest *ranked_competitors \n#=> Winners are John, Sally, and Dingus.\n#=> There were 2 other participants.\n\n# By convention, all methods that return booleans end with a question mark.\n5.even? #=> false\n5.odd? #=> true\n\n# By convention, if a method name ends with an exclamation mark, it does something destructive\n# like mutate the receiver. Many methods have a ! version to make a change, and\n# a non-! version to just return a new changed version.\ncompany_name = \"Dunder Mifflin\"\ncompany_name.upcase #=> \"DUNDER MIFFLIN\"\ncompany_name #=> \"Dunder Mifflin\"\n# We're mutating company_name this time.\ncompany_name.upcase! #=> \"DUNDER MIFFLIN\"\ncompany_name #=> \"DUNDER MIFFLIN\"\n\n# Classes\n\n# You can define a class with the 'class' keyword.\nclass Human\n\n  # A class variable. It is shared by all instances of this class.\n  @@species = 'H. sapiens'\n\n  # Basic initializer\n  def initialize(name, age = 0)\n    # Assign the argument to the 'name' instance variable for the instance.\n    @name = name\n    # If no age given, we will fall back to the default in the arguments list.\n    @age = age\n  end\n\n  # Basic setter method\n  def name=(name)\n    @name = name\n  end\n\n  # Basic getter method\n  def name\n    @name\n  end\n\n  # The above functionality can be encapsulated using the attr_accessor method as follows.\n  attr_accessor :name\n\n  # Getter/setter methods can also be created individually like this.\n  attr_reader :name\n  attr_writer :name\n\n  # A class method uses self to distinguish from instance methods.\n  # It can only be called on the class, not an instance.\n  def self.say(msg)\n    puts msg\n  end\n\n  def species\n    @@species\n  end\nend\n\n# Instantiating of a class\njim = Human.new('Jim Halpert')\ndwight = Human.new('Dwight K. Schrute')\n\n# You can call the methods of the generated object.\njim.species #=> \"H. sapiens\"\njim.name #=> \"Jim Halpert\"\njim.name = \"Jim Halpert II\" #=> \"Jim Halpert II\"\njim.name #=> \"Jim Halpert II\"\ndwight.species #=> \"H. sapiens\"\ndwight.name #=> \"Dwight K. Schrute\"\n\n# Calling of a class method\nHuman.say('Hi') #=> \"Hi\"\n\n# Variable's scopes are defined by the way we name them.\n# Variables that start with $ have global scope.\n$var = \"I'm a global var\"\ndefined? $var #=> \"global-variable\"\n\n# Variables that start with @ have instance scope.\n@var = \"I'm an instance var\"\ndefined? @var #=> \"instance-variable\"\n\n# Variables that start with @@ have class scope.\n@@var = \"I'm a class var\"\ndefined? @@var #=> \"class variable\"\n\n# Variables that start with a capital letter are constants.\nVar = \"I'm a constant\"\ndefined? Var #=> \"constant\"\n\n# Class is also an object in ruby. So a class can have instance variables.\n# A class variable is shared among the class and all of its descendants.\n\n# Base class\nclass Human\n  @@foo = 0\n\n  def self.foo\n    @@foo\n  end\n\n  def self.foo=(value)\n    @@foo = value\n  end\nend\n\n# Derived class\nclass Worker < Human\nend\n\nHuman.foo #=> 0\nWorker.foo #=> 0\n\nHuman.foo = 2\nWorker.foo #=> 2\n\n# A class instance variable is not shared by the class's descendants.\nclass Human\n  @bar = 0\n\n  def self.bar\n    @bar\n  end\n\n  def self.bar=(value)\n    @bar = value\n  end\nend\n\nclass Doctor < Human\nend\n\nHuman.bar #=> 0\nDoctor.bar #=> nil\n\nmodule ModuleExample\n  def foo\n    'foo'\n  end\nend\n\n# Including modules binds their methods to the class instances.\n# Extending modules binds their methods to the class itself.\nclass Person\n  include ModuleExample\nend\n\nclass Book\n  extend ModuleExample\nend\n\nPerson.foo     #=> NoMethodError: undefined method `foo' for Person:Class\nPerson.new.foo #=> \"foo\"\nBook.foo       #=> \"foo\"\nBook.new.foo   #=> NoMethodError: undefined method `foo'\n\n# Callbacks are executed when including and extending a module\nmodule ConcernExample\n  def self.included(base)\n    base.extend(ClassMethods)\n    base.send(:include, InstanceMethods)\n  end\n\n  module ClassMethods\n    def bar\n      'bar'\n    end\n  end\n\n  module InstanceMethods\n    def qux\n      'qux'\n    end\n  end\nend\n\nclass Something\n  include ConcernExample\nend\n\nSomething.bar     #=> \"bar\"\nSomething.qux     #=> NoMethodError: undefined method `qux'\nSomething.new.bar #=> NoMethodError: undefined method `bar'\nSomething.new.qux #=> \"qux\"\n```\n\n## Additional resources\n\n- [Learn Ruby by Example with Challenges](http://www.learneroo.com/modules/61/nodes/338) - A variant of this reference with in-browser challenges.\n- [An Interactive Tutorial for Ruby](https://rubymonk.com/) - Learn Ruby through a series of interactive tutorials.\n- [Official Documentation](http://ruby-doc.org/core)\n- [Ruby from other languages](https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/)\n- [Programming Ruby](http://www.amazon.com/Programming-Ruby-1-9-2-0-Programmers/dp/1937785491/) - An older [free edition](http://ruby-doc.com/docs/ProgrammingRuby/) is available online.\n- [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide) - A community-driven Ruby coding style guide.\n- [Try Ruby](http://tryruby.org) - Learn the basic of Ruby programming language, interactive in the browser."
