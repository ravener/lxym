
package pages

const Processing = "## Introduction\n\nProcessing is a programming language for creation of digital arts and\nmultimedia content, allowing non-programmers to learn fundamentals of computer\nprogramming in a visual context.\n\nWhile the language is based on Java language, its syntax has been largely\ninfluenced by both Java and Javascript syntaxes. [See more here](https://processing.org/reference/)\n\nThe language is statically typed, and also comes with its official IDE to\ncompile and run the scripts.\n\n```\n/* ---------\n   Comments\n   ---------\n*/\n\n// Single-line comment starts with //\n\n/*\n   Since Processing is based on Java,\n   the syntax for its comments are the same as Java (as you may have noticed above)!\n   Multi-line comments are wrapped as seen here.\n*/\n\n/* ---------------------------------------\n   Writing and Running Processing Programs\n   ---------------------------------------\n*/\n\n// In Processing, the program entry point is a function named setup() with a\n// void return type.\n// Note! The syntax looks strikingly similar to that of C++.\nvoid setup() {\n  // This prints out the classic output \"Hello World!\" to the console when run.\n  println(\"Hello World!\"); // Another language with a semi-column trap, aint it?\n}\n\n// Normally, we put all the static codes inside the setup() method as the name\n// suggest since it only runs once.\n// It can range from setting the background colours, setting the canvas size.\nbackground(color); // setting the background colour\nsize(width,height,[renderer]); // setting the canvas size with optional\n// parameter defining renderer\n// You will see more of them throughout this document.\n\n// If you want to run the codes indefinitely, it has to be placed in draw()\n// method.\n// draw() must exist if you want the code to run continuously and obviously,\n// there can only be one draw() method.\nint i = 0;\nvoid draw() {\n  // This block of code loops forever until stopped\n  print(i);\n  i++; // Increment Operator!\n}\n\n// Now that we know how to write the working script and how to run it,\n// we will proceed to explore what data types and collections are supported in\n// Processing.\n\n/* ------------------------\n   Datatypes & collections\n   ------------------------\n*/\n\n// According to Processing References, Processing supports 8 primitive\n// datatypes as follows.\n\nboolean booleanValue = true; // Boolean\nbyte byteValueOfA = 23; // Byte\nchar charValueOfA = 'A'; // Char\ncolor colourValueOfWhiteM = color(255, 255, 255); // Colour (Specified using\n// color() method)\ncolor colourValueOfWhiteH = #FFFFFF; // Colour (Specified using hash value)\nint intValue = 5; // Integer (Number without decimals)\nlong longValue = 2147483648L; // \"L\" is added to number to mark it as a long\nfloat floatValue = 1.12345; // Float (32-bit floating-point numbers)\ndouble doubleValue = 1.12345D; // Double (64-bit floating-point numbers)\n\n// NOTE!\n// Although datatypes \"long\" and \"double\" work in the language,\n// processing functions do not use these datatypes, therefore\n// they need to be converted into \"int\" and \"float\" datatypes respectively,\n// using (int) and (float) syntax before passing into a function.\n\n// There is a whole bunch of default composite datatypes available for use in\n// Processing.\n// Primarily, I will brief through the most commonly used ones to save time.\n\n// String\n// While char datatype uses '', String datatype uses \"\" - double quotes.\nString sampleString = \"Hello, Processing!\";\n// String can be constructed from an array of char datatypes as well. We will\n// discuss array very soon.\nchar source = {'H', 'E', 'L', 'L', 'O'};\nString stringFromSource = new String(source); // HELLO\n// As in Java, strings can be concatenated using the \"+\" operator.\nprint(\"Hello \" + \"World!\"); // Hello World!\n\n// Array\n// Arrays in Processing can hold any datatypes including Objects themselves.\n// Since arrays are similar to objects, they must be created with the keyword\n// \"new\".\nint[] intArray = new int[5];\nint[] intArrayWithValues = {1, 2, 3}; // You can also populate with data.\n\n// ArrayList\n// Functions are similar to those of array; arraylists can hold any datatypes.\n// The only difference is arraylists resize dynamically, as it is a form of\n// resizable-array implementation of the Java \"List\" interface.\nArrayList<Integer> intArrayList = new ArrayList<Integer>();\n\n// Object\n// Since it is based on Java, Processing supports object-oriented programming.\n// That means you can basically define any datatypes of your own and manipulate\n// them to your needs.\n// Of course, a class has to be defined before for the object you want.\n// Format --> ClassName InstanceName\nSomeRandomClass myObject // then instantiate later\n//or\nSomeRandomClass myObjectInstantiated = new SomeRandomClass();\n\n// Processing comes up with more collections (eg. - Dictionaries and Lists) by\n// default, for the simplicity sake, I will leave them out of discussion here.\n\n/* ------------\n   Maths\n   ------------\n*/\n\n// Arithmetic\n1 + 1 // 2\n2 - 1 // 1\n2 * 3 // 6\n3 / 2 // 1\n3.0 / 2 // 1.5\n3.0 % 2 // 1.0\n\n// Processing also comes with a set of functions that simplify mathematical\n// operations.\nfloat f = sq(3); // f = 9.0\nfloat p = pow(3, 3); // p = 27.0\nint a = abs(-13); // a = 13\nint r1 = round(3.1); // r1 = 3\nint r2 = round(3.7); // r2 = 4\nfloat sr = sqrt(25); // sr = 5.0\n\n// Vectors\n// Processing provides an easy way to implement vectors in its environment\n// using PVector class. It can describe a two or three dimensional vector and\n// comes with a set of methods which are useful for matrices operations.\n// You can find more information on PVector class and its functions here.\n// (https://processing.org/reference/PVector.html)\n\n// Trigonometry\n// Processing also supports trigonometric operations by supplying a set of\n// functions. sin(), cos(), tan(), asin(), acos(), atan() and also degrees()\n// and radians() for convenient conversion.\n// However, those functions take angle in radians as the parameter so it has\n// to be converted beforehand.\nfloat one = sin(PI/2); // one = 1.0\n// As you may have noticed, there exists a set of constants for trigonometric\n// uses;\n// PI, HALF_PI, QUARTER_PI and so on...\n\n/* -------------\n   Control Flow\n   -------------\n*/\n\n// Conditional Statements\n// If Statements - The same syntax as if statements in Java.\nif (author.getAppearance().equals(\"hot\")) {\n  print(\"Narcissism at its best!\");\n} else {\n  // You can check for other conditions here.\n  print(\"Something is really wrong here!\");\n}\n// A shortcut for if-else statements can also be used.\nint i = 3;\nString value = (i > 5) ? \"Big\" : \"Small\"; // \"Small\"\n\n// Switch-case structure can be used to check multiple conditions concisely.\n// It is important to use the break statement. If the `break`-statement does \n// not exist the program executes all the following cases after a case was true.\nint value = 2;\nswitch(value) {\n  case 0:\n    print(\"Nought!\"); // This does not get executed.\n    break; // Jumps to the next statement\n  case 1:\n    print(\"Getting there...\"); // This again does not get executed.\n    break;\n  case 2:\n    print(\"Bravo!\"); // This line gets executed.\n    break;\n  default:\n    print(\"Not found!\"); // This line gets executed if our value was some other value.\n    break;\n}\n\n// Iterative statements\n// For Statements - Again, the same syntax as in Java\nfor(int i = 0; i < 5; i++){\n  print(i); // prints from 0 to 4\n}\n\n// While Statements - Again, nothing new if you are familiar with Java syntax.\nint j = 3;\nwhile(j > 0) {\n  print(j);\n  j--; // This is important to prevent from the code running indefinitely.\n}\n\n// loop()| noLoop() | redraw() | exit()\n// These are more of Processing-specific functions to configure program flow.\nloop(); // allows the draw() method to run forever while\nnoLoop(); // only allows it to run once.\nredraw(); // runs the draw() method once more.\nexit(); // This stops the program. It is useful for programs with draw()\n// running continuously.\n```\n\n## Drawing with Processing\n\nSince you will have understood the basics of the language by now, we will now\nlook into the best part of Processing - DRAWING.\n\n```\n/* ------\n   Shapes\n   ------\n*/\n\n// 2D Shapes\n\n// Point\npoint(x, y); // In 2D space\npoint(x, y, z); // In 3D space\n// Draws a point in the coordinate space.\n\n// Line\nline(x1, y1, x2, y2); // In 2D space\nline(x1, y1, z1, x2, y2, z2); // In 3D space\n// Draws a line connecting two points defined by (x1, y1) and (x2, y2).\n\n// Triangle\ntriangle(x1, y1, x2, y2, x3, y3);\n// Draws a triangle connecting three points defined by coordinate paramters.\n\n// Rectangle\nrect(a, b, c, d, [r]); // With optional parameter defining the radius of all corners\nrect(a, b, c, d, [tl, tr, br, bl]); // With optional set of parameters defining\n// radius of each corner\n// Draws a rectangle with {a, b} as a top left coordinate and c and d as width\n// and height respectively.\n\n// Quad\nquad(x, y, x2, y2, x3, y3, x4, y4);\n// Draws a quadrilateral with parameters defining coordinates of each corner\n// point.\n\n// Ellipse\nellipse(x, y, width, height);\n// Draws an eclipse at point {x, y} with width and height specified.\n\n// Arc\narc(x, y, width, height, start, stop, [mode]);\n// While the first four parameters are self-explanatory,\n// start and end defined the angles the arc starts and ends (in radians).\n// Optional parameter [mode] defines the filling;\n// PIE gives pie-like outline, CHORD gives the chord-like outline and OPEN is\n// CHORD without strokes\n\n// Curves\n// Processing provides two implementation of curves; using curve() and bezier().\n// Since I plan to keep this simple I wont be discussing any further details.\n// However, if you want to implement it in your sketch, here are the references:\n// (https://processing.org/reference/curve_.html)\n// (https://processing.org/reference/bezier_.html)\n\n// 3D Shapes\n\n// 3D space can be configured by setting \"P3D\" to the renderer parameter in\n// size() method.\nsize(width, height, P3D);\n// In 3D space, you will have to translate to the particular coordinate to\n// render the 3D shapes.\n\n// Box\nbox(size);  // Cube with same length defined by size\nbox(w, h, d); // Box with width, height and depth separately defined\n\n// Sphere\nsphere(radius); // Its size is defined using the radius parameter\n// Mechanism behind rendering spheres is implemented by tessellating triangles.\n// That said, how much detail being rendered is controlled by function\n// sphereDetail(res)\n// More information here: (https://processing.org/reference/sphereDetail_.html)\n\n// Irregular Shapes\n// What if you wanted to draw something thats not made available by Processing\n// functions?\n// You can use beginShape(), endShape(), vertex(x,y) to define shapes by\n// specifying each point. More information here:\n// (https://processing.org/reference/beginShape_.html)\n// You can also use custom made shapes using PShape class:\n// (https://processing.org/reference/PShape.html)\n\n/* ---------------\n   Transformations\n   ---------------\n*/\n\n// Transformations are particularly useful to keep track of the coordinate\n// space and the vertices of the shapes you have drawn. Particularly;\n// matrix stack methods; pushMatrix(), popMatrix() and translate(x,y)\npushMatrix(); // Saves the current coordinate system to the stack\n// ... apply all the transformations here ...\npopMatrix(); // Restores the saved coordinate system\n// Using them, the coordinate system can be preserved and visualized without\n// causing any conflicts.\n\n// Translate\ntranslate(x, y); // Translates to point{x, y} i.e. - setting origin to that point\ntranslate(x, y, z); // 3D counterpart of the function\n\n// Rotate\nrotate(angle); // Rotate the amount specified by the angle parameter\n// It has 3 3D counterparts to perform rotation, each for every dimension,\n// namely: rotateX(angle), rotateY(angle), rotateZ(angle)\n\n// Scale\nscale(s); // Scale the coordinate system by either expanding or contracting it.\n\n/* --------------------\n   Styling and Textures\n   --------------------\n*/\n\n// Colours\n// As I have discussed earlier, the background colour can be configured using\n// background() function. You can define a color object beforehand and then\n// pass it to the function as an argument.\ncolor c = color(255, 255, 255); // WHITE!\n// By default, Processing uses RGB colour scheme but it can be configured to\n// HSB using colorMode(). Read more here:\n// (https://processing.org/reference/colorMode_.html)\nbackground(c); // By now, the background colour should be white.\n// You can use fill() function to select the colour for filling the shapes.\n// It has to be configured before you start drawing shapes so the colours gets\n// applied.\nfill(color(0, 0, 0));\n// If you just want to colour the outlines of the shapes then you can use\n// stroke() function.\nstroke(255, 255, 0, 200); // stroke colour set to yellow with transparency\n// set to a lower value.\n\n// Images\n// Processing can render images and use them in several ways. Mostly stored as\n// PImage datatype.\nfilter(shader); // Processing supports several filter functions for image manipulation.\ntexture(image); // PImage can be passed into arguments for texture-mapping the shapes.\n```\n\nIf you want to take things further, there are more things Processing is powered\nfor. Rendering models, shaders and whatnot. There's too much to cover in a\nshort documentation, so I will leave them out here. Shoud you be interested,\nplease check out the references.\n\n```\n// Before we move on, I will touch a little bit more on how to import libraries\n// so you can extend Processing functionality to another horizon.\n\n/* -------\n   Imports\n   -------\n*/\n\n// The power of Processing can be further visualized when we import libraries\n// and packages into our sketches.\n// Import statement can be written as below at the top of the source code.\nimport processing.something.*;\n```\n\n## DTC?\n\nDown To Code? Let's get our hands dirty!\n\nLet us see an example from openprocessing to visualize how much Processing is\ncapable of within few lines of code.\n\nCopy the code below into your Processing IDE and see the magic.\n\n```\n// Disclaimer: I did not write this program since I currently am occupied with\n// internship and this sketch is adapted from openprocessing since it shows\n// something cool with simple codes.\n// Retrieved from: (https://www.openprocessing.org/sketch/559769)\n\nfloat theta;\nfloat a;\nfloat col;\nfloat num;\n\nvoid setup() {\n  size(600,600);\n}\n\nvoid draw() {\n  background(#F2F2F2);\n  translate(width/2, height/2);\n  theta = map(sin(millis()/1000.0), -1, 1, 0, PI/6);\n\n  float num=6;\n  for (int i=0; i<num; i++) {\n    a =350;\n    rotate(TWO_PI/num);\n    branch(a);\n  }\n\n}\n\nvoid branch(float len) {\n  col=map(len, 0, 90, 150, 255);\n  fill(col, 0, 74);\n  stroke (col, 0, 74);\n  line(0, 0, 0, -len);\n  ellipse(0, -len, 3, 3);\n  len *= 0.7;\n\n  if (len>30) {\n    pushMatrix();\n    translate(0, -30);\n    rotate(theta);\n    branch(len);\n    popMatrix();\n\n    pushMatrix();\n    translate(0, -30);\n    rotate(-theta);\n    branch(len);\n    popMatrix();\n\n  }\n}\n```\n\nProcessing is easy to learn and is particularly useful to create multimedia\ncontents (even in 3D) without having to type a lot of codes. It is so simple\nthat you can read through the code and get a rough idea of the program flow.\n\nHowever, that does not apply when you introduce external libraries, packages\nand even your own classes. (Trust me! Processing projects can get real humongous...)\n\n## Some useful resources\n\n - [Processing Website](http://processing.org)\n - [Processing Sketches](http://openprocessing.org)"
