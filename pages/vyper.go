
package pages

const Vyper = "> The content of this document is largely inspired by [\"Learn Solidity in Y Minutes\"](https:#github.com/adambard/learnxinyminutes-docs/blob/master/solidity.html.markdown)\n\nVyper lets you program on [Ethereum](https:#www.ethereum.org/), a\nblockchain-based virtual machine that allows the creation and\nexecution of smart contracts, without requiring centralized or trusted parties. It was\ndesigned to improve upon Solidity, another smart contract language for Ethereum, by\nlimiting unsafe practices and enhancing readability; Vyper seeks to optimize the\nsecurity and auditability of smart contracts.\n\nVyper is an experimental, statically typed, contract programming language meant to\nresemble Python. Like objects in OOP, each contract contains state variables, functions,\nand common data types. Contract-specific features include event notifiers for listeners,\nand custom global variables, global constants.\n\nSome Ethereum contract examples include crowdfunding, voting, and blind auctions.\n\n---\n\n## Table of Contents\n\n- Intro\n- Example\n1. Data types and associated methods\n2. Data structures\n3. Simple operators\n4. Global variables of note\n5. Functions and more\n    a. functions\n    b. events\n6. Branching and loops\n7. Objects/contracts\n    a. calling external contracts\n    b. ERC20 built-in\n    c. following an interface\n8. Other keywords\n    a. selfdestruct\n9. Contract design notes\n    a. obfuscation\n    b. storage optimization\n    c. data access in blockchain\n    d. cron job\n    e. observer pattern\n10. Security\n11. Style notes\n12. Natspec comments\n- Other documents\n\n---\n\n## Intro\n\nFrom [the docs](https://media.readthedocs.org/pdf/vyper/latest/vyper.pdf)\nthe foundational tenants of Vyper are:\n\n1. *Security*\n2. *Language and compiler simplicity*\n3. *Auditability*\n\nThis allows for the following features:\n\n1. *Bounds and overflow checking*\n   - On the arithmetic and array level\n   - There are no dynamic arrays in Vyper\n2. *Support for signed integers and decimal fixed point numbers*\n3. *Decidability* - You can always compute precise upper bound on gas cost\n4. *Strong typing* - for built-in and custom types\n5. *Small and understandable compiler code*\n6. *Limited support for pure functions*\n    - Anything marked `@constant` is not allowed to change the state\n\nFollowing the principles and goals, Vyper does not provide the following features:\n\n1. *Modifiers* (defining parts of functions elsewhere)\n2. *Class inheritance*\n3. *Inline assembly*\n4. *Function overloading*\n5. *Operator overloading*\n6. *Recursive calling*\n7. *Infinite-length loops*\n8. *Binary fixed point* (decimal fixed point is used for its exactness)\n\nWITH THE RAPID CHANGES IN ETHEREUM, THIS DOCUMENT IS UNLIKELY TO STAY UP TO\nDATE, SO YOU SHOULD FOLLOW THE LATEST VYPER DOCS AND ETHEREUM BLOG FOR THE LATEST.\nALL CODE HERE IS PROVIDED AS IS, WITH SUBSTANTIAL RISK OF ERRORS OR DEPRECATED CODE\nPATTERNS.\n\nThis document primarily discusses syntax, and so excludes many\npopular design patterns.\n\nAs Vyper and Ethereum are under active development, experimental or beta\nfeatures are typically marked, and subject to change. Pull requests welcome.\n\nThis document describes Vyper version `0.1.0-beta.8`.\n\n*All of the following code exists for educational purposes only!*\n*None of the following code should be used in production as-is!*\n\n## Example\n\n```python\n# First, a simple todo list contract\n# Implements CRUD operations for tasks\n\n# todo.vy (note .vy extension)\n### **** START EXAMPLE **** ###\n\n# Start with Natspec comment\n# used for documentation\n\n# @title SimpleBank v1\n# @author kennyp\n# @notice This is a simple bank.\n\n# Vyper contracts must obey a particular order:\n#   struct -> interface -> events -> globals and constants -> functions\n# Additionally, like Python, Vyper functions must be defined in the file\n#    before they're called.\n\n# Structs\n\nstruct Task:\n    done: bool\n    deleted: bool\n    task: string[100]\n    metadata: bytes32\n\n# Interfaces\n\ncontract AnotherContract():\n    def fetch() -> bytes32: constant\n    def inform(_taskId: uint256, _status: uint256) -> bool: modifying\n\n# Events\n\n# Events - publicize actions to external listeners\n# `indexed` means that it's easier to search/filter on this field\nTaskStatus: event({_taskId: indexed(uint256), _status: uint256})\n\n# Global Variables\n\n# State variables are values which are permanently stored in contract storage\n# State vars consist of any value persisting beyond any function's scope\n#   and are permanently stored in contract storage\n\n# You can define your own, custom, unmutable constants\nCREATED: constant(uint256) = 0\nCOMPLETED: constant(uint256) = 1\nDELETED: constant(uint256) = 2\n\n# The `public` built-in allows for this address to be read externally\n#   without defining a `get()` constant function\nowner: public(address)\nother: public(address)\n\n# uint256 means \"unsigned positive integer between 0 and 2^256 - 1\"\n# Overflow protection is built-in to Vyper\ntaskCount: uint256\ntasks: map(uint256, Task) # dictionary: key=uint256, value: Task struct\n\n# Private Functions\n\n# Start each function with Pythonic decorators\n# These decorators resemble Natspec but are actually enforced by Vyper's compiler\n# These decorators are:\n# @public XOR @private (either one or the other)\n#   @public (if any contract/user can call it)\n#   @private (if only internal functions can call it)\n# @payable (if the function is payable i.e. accepting ETH)\n# @constant (if the function is not modifying anything on-chain)\n@private\ndef _changeTaskStatus( \\\n        _sender: address, \\\n        _taskId: uint256, \\\n        _status: uint256, \\\n    ):\n    # backslashes (\\) allow for multi-line code\n    # Natspec comments are particularly helpful for documentation and readibility\n    # Natspec can be included using familiar Pythonic docstring syntax\n    \"\"\"\n    @notice\n    @dev `_sender` MUST be `self.owner`\n    @param _sender Who is triggering this function\n    @param _task The description of the task (only useful when task added)\n    \"\"\"\n    # NOTE: Private functions do not have access to `msg.sender`\n    # SIDE NOTE: `msg.sender` refers to whoever immediately called the function of\n    #   immediate scope. In other words, if I call a function that calls another\n    #   in-contract, public function, then `msg.sender` turns from my address to\n    #   the address of the current contract.\n    assert _sender == self.owner # failed assertions cause calls/transactions to fail\n    # Note that unlike Solidity, `self.` is required to query the contract's state\n    # Control flow is Pythonic, as is much of Vyper:\n    _task: string[100] # initialized to default value\n    _data: bytes32 = sha3(convert(_sender, bytes32)) # owner is obfuscated (but still visible in logs)\n    if _status == CREATED: # control flow mimics python\n        # How a new struct is instantiated:\n        self.tasks[_taskId] = Task({ \\\n            done: False, deleted: False, task: _task, metadata: _data \\\n        })\n    elif _status == COMPLETED:\n        # Modifying an existing struct:\n        self.tasks[_taskId].done = True\n    elif _status == DELETED:\n        self.tasks[_taskId].deleted = True\n    AnotherContract(self.other).inform(_taskId, _status) # modifying external call\n    log.TaskStatus(_taskId, _status) # emit an event\n\n# Public Functions\n\n# Pythonic constructor - can receive none or many arguments\n@public\ndef __init__(_owner: address, _other_contract: address):\n    \"\"\"\n    @dev Called once and only upon contract depoyment\n    \"\"\"\n    self.owner = _owner\n    self.other = _other_contract\n\n# NOTE: Pythonic whitespace rules are mandated in Vyper\n\n@public\ndef addTask(_task: string[100]) -> uint256:\n    \"\"\"\n    @notice Adds a task to contract\n    @param _task Description of task\n    @return Id of newly minted task\n    \"\"\"\n    # msg.sender gives the address of who/what contract is calling this function\n    self._changeTaskStatus(msg.sender, self.taskCount, CREATED)\n    self.tasks[self.taskCount].task = _task\n    self.taskCount += 1\n    return self.taskCount - 1\n\n@public\ndef addSpecialTask(_task: string[100]) -> uint256:\n    \"\"\"\n    @notice Adds a task with metadata pulled from elsewhere\n    @param _task Description of task\n    @return Id of newly minted task\n    \"\"\"\n    self._changeTaskStatus(msg.sender, self.taskCount, CREATED)\n    self.tasks[self.taskCount].task = _task\n    self.tasks[self.taskCount].metadata = AnotherContract(self.other).fetch()\n    self.taskCount += 1\n    return self.taskCount - 1\n\n@public\ndef completeTask(_taskId: uint256):\n    \"\"\"\n    @notice Marks a task as \"completed\"\n    @param _taskId Id of task to complete\n    \"\"\"\n    self._changeTaskStatus(msg.sender, _taskId, COMPLETED)\n\n@public\ndef deleteTask(_taskId: uint256):\n    \"\"\"\n    @notice Adds a task to contract\n    @param _taskId Id of task to delete\n    \"\"\"\n    self._changeTaskStatus(msg.sender, _taskId, DELETED)\n\n@public\n@constant # allows function to run locally/off blockchain\ndef getTask(_taskId: uint256) -> string[100]:\n    \"\"\"\n    @notice Getter for a task's description\n    @param _taskId Id of task with desired description\n    @return Description of task\n    \"\"\"\n    return self.tasks[_taskId].task\n\n### **** END EXAMPLE **** ###\n\n\n# Now, the basics of Vyper\n\n\n# ---\n\n\n# 1. DATA TYPES AND ASSOCIATED METHODS\n# uint256 used for currency amount and for dates (in unix time)\nx: uint256\n\n# int of 128 bits, cannot be changed after contract deployment\n# with 'constant', compiler replaces each occurrence with actual value\na: constant(int128) = 5\n\n# All state variables (those outside a function)\n#   are by default 'internal' and accessible inside contract\n# Need to explicitly set to 'public' to allow external contracts to access\n#   A getter is automatically created, but NOT a setter\n# Can only be called in the contract's scope (not within functions)\n# Add 'public' field to indicate publicly/externally accessible\na: public(int128)\n\n# No random functions built in, use other contracts for randomness\n\n# Type casting is limited but exists\nb: int128 = 5\nx: uint256 = convert(b, uint256)\n\n# Types of accounts:\n# Contract Account: f(creator_addr, num_transactions)=address set on contract creation\n# External Account: (person/external entity): f(public_key)=address\n\n# Addresses - An address type can hold an Ethereum address which\n#   equates to 20 bytes or 160 bits. It returns in hexadecimal notation\n#   with a leading 0x. No arithmetic allowed\nowner: public(address)\n\n# Members can be invoked on all addresses:\nowner.balance # returns balance of address as `wei_value`\nowner.codesize # returns code size of address as `int128`\nowner.is_contract # `True` if Contract Account\n\n# All addresses can be sent ether via `send()` built-in\n@public\n@payable\ndef sendWei(any_addr: address):\n    send(any_addr, msg.value)\n\n# Bytes available\na: bytes[2]\nb: bytes[32]\nc: bytes32\n# `b` and `c` are 2 different types\n\n# Bytes are preferable to strings since Vyper currently offers better\n#   support for bytes i.e. more built-ins to deal with `bytes32`, `bytes32`\n#   can be returned from functions and strings[] can't be, UTF8 (string encoding)\n#   uses more storage, etc.\n\n# There are no dynamically sized bytes, similar to how there are no\n#   dynamic arrays\n\n# Fixed-size byte arrays (Strings)\na: string[100]\nb: string[8]\nc: string[108] = concat(a, b) # check the latest docs for more built-ins\n\n# Time\nt1: timedelta\nt2: timestamp\n# Both types are built-in \"custom type\" variants of `uint256`\n# `timedelta` values can be added but not `timestamp` values\n\n# Money\nm: wei_value\n# Also has the base type `uint256` like `timestamp` and `timedelta`\n# 1 unit of WEI (a small amount of ETH i.e. ether)\n\n# Custom types\n# specify units used in the contract:\nunits: {\n    cm: \"centimeter\",\n    km: \"kilometer\"\n}\n# usage:\na: int128(cm)\nb: uint256(km)\n\n# BY DEFAULT: all values are set to 0 on instantiation\n\n# `clear()` can be called on most types\n#   Does NOT destroy value, but sets value to 0, the initial value\n\n\n# ---\n\n\n# 2. DATA STRUCTURES\n# Arrays\nbytes32[5] nicknames; # static array\nbytes32[] names; # dynamic array\nuint newLength = names.push(\"John\"); # adding returns new length of the array\n# Length\nnames.length; # get length\nnames.length = 1; # lengths can be set (for dynamic arrays in storage only)\n\n# Multidimensional Arrays\n# At initialization, array dimensions must be hard-coded or constants\n# Initialize a 10-column by 3-row, multidimensional fixed array\nls: (uint256[10])[3] # parentheses are optional\n@public\ndef setToThree():\n    # Multidimensional Array Access and Write\n    # access indices are reversed\n    # set element in row 2 (3rd row) column 5 (6th column) to 3\n    self.ls[2][5] = 3\n\n# Dictionaries (any simple type to any other type including structs)\ntheMap: map(uint256, bytes32)\ntheMap[5] = sha3(\"charles\")\n# theMap[255] result is 0, all non-set key values return zeroes\n# To make read public, make a getter that accesses the mapping\n@public\ndef getMap(_idx: uint256) -> bytes32:\n    \"\"\"\n    @notice Get the value of `theMap` at `_idx`\n    \"\"\"\n    return self.theMap[_idx]\n\nself.getMap(5) # returns sha3(\"charles\") in bytes32\n\n# Nested mappings\naMap: map(address, map(address, uint256))\n# NOTE: Mappings are only allowed as state variables\n# NOTE: Mappings are not iterable; can only be accessed\n\n# To delete (reset the mapping's value to default at a key)\nclear(balances[\"John\"])\nclear(balances); # sets all elements to 0\n\n# Unlike other languages, CANNOT iterate through all elements in\n#   mapping, without knowing source keys - can build data structure\n#   on top to do this\n\n# Structs\nstruct Struct:\n    owner: address\n    _balance: uint256 # balance is a reserved keyword, is a member for addresses\n\nexampleStuct: Struct\n\n@public\ndef foo() -> uint256:\n    self.exampleStuct = Struct({owner: msg.sender, _balance: 5})\n    self.exampleStuct._balance = 10\n    self.exampleStuct._balance = 5 # set to new value\n    clear(self.exampleStuct._balance)\n    clear(self.exampleStuct)\n    return self.exampleStuct._balance\n\n\n# Data locations: Memory vs. storage vs. calldata - all complex types (arrays,\n# structs) have a data location\n# 'memory' does not persist, 'storage' does\n# Default is 'storage' for local and state variables; 'memory' for func params\n# stack holds small local variables\n\n# for most types, can explicitly set which data location to use\n\n\n# ---\n\n\n# 3. SIMPLE OPERATORS\n# Comparisons, bit operators and arithmetic operators are provided\n# exponentiation: **\n# modulo: %\n# maximum: max(x, y)\n# AND: bitwise_and(x, y)\n# bitwise shift: shift(x, _shift)\n#   where x,y are uint256\n#         _shift is int128\n\n# 4. GLOBAL VARIABLES OF NOTE\n# ** self **\nself # address of contract\n# often used at end of contract life to transfer remaining balance to party:\nself.balance # balance of current contract\nself.someFunction() # calls func externally via call, not via internal jump\n\n# ** msg - Current message received by the contract **\n# Ethereum programmers take NOTE: this `msg` object is smaller than elsewhere\nmsg.sender # address of sender\nmsg.value # amount of ether provided to this contract in wei, the function should be marked `@payable`\nmsg.gas # remaining gas\n\n# ** tx - This transaction **\n# Ethereum programmers take NOTE: this `tx` object is smaller than elsewhere\ntx.origin # address of sender of the transaction\n\n# ** block - Information about current block **\nblock.timestamp # time at current block (uses Unix time)\n# Note that `block.timestamp` can be manipulated by miners, so be careful\nblock.number # current block number\nblock.difficulty # current block difficulty\n\n# ** storage - Persistent storage hash **\nstorage['abc'] = 'def'; # maps 256 bit words to 256 bit words\n\n\n# ---\n\n\n# 5. FUNCTIONS AND MORE\n\n# A. FUNCTIONS\n# Simple function\nfunction increment(uint x) returns (uint) {\n    x += 1;\n    return x;\n}\n\n# Functions can return many arguments\n@public\n@constant\ndef increment(x: uint256, y: uint256) -> (uint256, uint256):\n    x += 1\n    y += 1\n    return  (x, y)\n\n# Call previous functon\n@public\n@constant\ndef willCall() -> (uint256, uint256):\n    return  self.increment(1,1)\n\n# One should never have to call a function / hold any logic outside\n#   outside the scope of a function in Vyper\n\n# '@constant'\n# indicates that function does not/cannot change persistent vars\n# Constant function execute locally, not on blockchain\ny: uint256\n@public\n@constant\ndef increment(x: uint256) -> uint256:\n    x += 1\n    y += 1 # this line would fail\n    # y is a state variable => can't be changed in a constant function\n\n\n# 'Function Decorators'\n# Used like python decorators but are REQUIRED by Vyper\n# @public - visible externally and internally (default for function)\n# @private - only visible in the current contract\n# @constant - doesn't change state\n# @payable - receive ether/ETH\n# @nonrentant(<unique_key>) - Function can only be called once, both externally\n#                             and internally. Used to prevent reentrancy attacks\n\n# Functions hare not hoisted\n# Functions cannot be assigned to a variable\n# Functions cannot be recursive\n\n# All functions that receive ether must be marked 'payable'\n@public\n@payable\ndef depositEther():\n    self.balances[msg.sender] += msg.value\n\n\n# B. EVENTS\n# Events are notify external parties; easy to search and\n#   access events from outside blockchain (with lightweight clients)\n#   typically declare after contract parameters\n\n# Declare\nLogSent: event({_from: indexed(address), address: indexed(_to), _amount: uint256})\n# Call\nlog.LogSent(from, to, amount)\n\n/**\nFor an external party (a contract or external entity), to watch using\nthe Web3 Javascript library:\n\n# The following is Javascript code, not Vyper code\nCoin.LogSent().watch({}, '', function(error, result) {\n    if (!error) {\n        console.log(\"Coin transfer: \" + result.args.amount +\n            \" coins were sent from \" + result.args.from +\n            \" to \" + result.args.to + \".\");\n        console.log(\"Balances now:\\n\" +\n            \"Sender: \" + Coin.balances.call(result.args.from) +\n            \"Receiver: \" + Coin.balances.call(result.args.to));\n    }\n}\n**/\n\n# Common paradigm for one contract to depend on another (e.g., a\n#   contract that depends on current exchange rate provided by another)\n\n\n# ---\n\n\n# 6. BRANCHING AND LOOPS\n\n# All basic logic blocks from Python work - including if/elif/else, for,\n#   while, break, continue, return - but no switch\n\n# Syntax same as Python, but no type conversion from non-boolean\n# to boolean (comparison operators must be used to get the boolean val)\n\n# REMEMBER: Vyper does not allow resursive calls or infinite loops\n\n\n# ---\n\n\n# 7. OBJECTS/CONTRACTS\n# REMEMBER: Vyper does not allow for inheritance or imports\n\n# A. CALLING EXTERNAL CONTRACTS\n# You must define an interface to an external contract in the current contract\n\ncontract InfoFeed():\n    def getInfo() -> uint256: constant\n\ninfo: uint256\n\n@public\ndef __init__(_source: address):\n    self.info = InfoFeed(_source).getInfo()\n\n\n# B. ERC20 BUILT-IN\n# Using the `ERC20` keyword implies that the contract at the address\n#   follows the ERC20 token standard, allowing you to safely call\n#   functions like `transfer()`, etc.\n\ntokenAddress: address(ERC20)\n\n@public\ndef transferIt(_to: address, _amt: uint256(wei)):\n    self.tokenAddress.transfer(_to, _amt)\n\n\n# C. FOLLOWING AN INTERFACE\n# Vyper is experimenting with using the following syntax at the top of\n#   a `.vy` file to specify what interfaces are followed by the contract\n# This allows interfaces to be better organized, registered, and recognized\n\nimport interfaces.some_interface as SomeInterface\nimplements: SomeInterface\n# <rest of contract>\n\n\n# ---\n\n\n# 8. OTHER KEYWORDS\n\n# A. selfdestruct()\n# selfdestruct current contract, sending funds to address (often creator)\nselfdestruct(SOME_ADDRESS);\n\n# removes storage/code from current/future blocks\n# helps thin clients, but previous data persists in blockchain\n\n# Common pattern, lets owner end the contract and receive remaining funds\n@public\ndef endItAll() {\n    assert msg.sender == self.creator # Only let the contract creator do this\n    selfdestruct(self.creator) # Makes contract inactive, returns funds\n\n# May want to deactivate contract manually, rather than selfdestruct\n#   (ether sent to selfdestructed contract is lost)\n\n\n# B. sha3()\n# Encrypts strings and other data\n# Very important on the blockchain\n# Takes 1 argument, `concat()` can be called beforehand\n# All strings passed are concatenated before hash action\nsha3(concat(\"ab\", \"cd\")) # returns bytes32\n\n\n# ---\n\n\n# 9. CONTRACT DESIGN NOTES\n\n# A. Obfuscation\n# All variables are publicly viewable on blockchain, so anything\n#   that is private needs to be obfuscated (e.g., hashed w/secret)\n# Oftentimes, a \"commit-reveal\" scheme is employed\n\n# Step 1. Commit\n# Place a commitment by sending output of `sha3()`\nsha3(\"a secret\"); # btyes32 commit\nsha3(concat(\"secret\", \"other secret\", \"salt\")); # commit multiple things\n# The `sha3()` calculation should occur off-chain, only the bytes32\n#   output should be inputted into some `commit()` function\ncommits: map(address, bytes32)\n@public\ndef commit(commitment: bytes32):\n    self.commits[msg.sender] = commitment\n\n# Step 2. Reveal\n# Send your previously committed data so the contract can check\n#   if your commitment was honest\n@public\ndef reveal(_secret: string[100], _salt: string[100]) -> bool:\n    return sha3(concat(_secret, _salt)) == self.commits[msg.sender]\n\n\n# B. Storage optimization\n# Writing to blockchain can be expensive, as data stored forever; encourages\n#   smart ways to use memory (eventually, compilation will be better, but for now\n#   benefits to planning data structures - and storing min amount in blockchain)\n\n# Cost can often be high for items like multidimensional arrays\n#   (cost is for storing data - not declaring unfilled variables)\n\n\n# C. Data access in blockchain\n# Cannot restrict human or computer from reading contents of\n#   transaction or transaction's state\n\n# While 'private' prevents other *contracts* from reading data\n#   directly - any other party can still read data in blockchain\n\n# All data to start of time is stored in blockchain, so\n#   anyone can observe all previous data and changes\n\n\n# D. Cron Job\n# Contracts must be manually called to handle time-based scheduling;\n#   can create external code to regularly ping or provide incentives\n#   (ether) for others to ping\n\n\n# E. Observer Pattern\n# An Observer Pattern lets you register as a subscriber and\n#   register a function which is called by the oracle (note, the oracle\n#   pays for this action to be run)\n# Some similarities to subscription in Pub/sub\n\n# This is an abstract contract, both client and server classes import,\n#   the client should implement\n\n### **** START EXAMPLE **** ###\n\ncontract SomeOracleCallback():\n    def oracleCallback(_value: uint256, _time: timestamp, _info: bytes32): modifying\n\nMAX_SUBS: constant(uint256) = 100\nnumSubs: public(uint256) # number of subscribers\nsubs: map(uint256, address) # enumerates subscribers\n\n@public\ndef addSub(_sub: address) -> uint256:\n    \"\"\"\n    @notice Add subscriber\n    @param _sub Address to add\n    @return Id of newly added subscriber\n    \"\"\"\n    self.subs[self.numSubs] = _sub\n    self.numSubs += 1\n    return self.numSubs - 1\n\n@private\ndef notify(_value: uint256, _time: timestamp, _info: bytes32) -> bool:\n    \"\"\"\n    @notice Notify all subscribers\n    @dev Check `numSubs` first; Watch out for gas costs!\n    @param _value whatever\n    @param _time what have you\n    @param _info what else\n    @return True upon successful completion\n    \"\"\"\n    j: uint256\n    for i in range(MAX_SUBS):\n        j = convert(i, uint256) # `i` is int128 by default\n        if j == self.numSubs:\n            return True\n        SomeOracleCallback(self.subs[j]).oracleCallback(_value, _time, _info)\n\n@public\ndef doSomething():\n    \"\"\"\n    @notice Do something and notify subscribers\n    \"\"\"\n    # ...something...\n    whatever: uint256 = 6\n    what_have_you: timestamp\n    what_else: bytes32 = sha3(\"6\")\n    self.notify(whatever, what_have_you, what_else)\n\n# Now, your client contract can addSubscriber by importing SomeOracleCallback\n# and registering with Some Oracle\n\n### **** END EXAMPLE **** ###\n\n\n# ---\n\n\n# 10. SECURITY\n# Bugs can be disastrous in Ethereum contracts - and even popular patterns in\n#   Vyper may be found to be antipatterns\n\n# See security links at the end of this doc\n\n\n# ---\n\n\n# 11. STYLE NOTES\n# Based on Python's PEP8 style guide\n# Full Style guide: http:#solidity.readthedocs.io/en/develop/style-guide.html\n\n# Quick summary:\n# 4 spaces for indentation\n# Two lines separate contract declarations (and other top level declarations)\n# Avoid extraneous spaces in parentheses\n# Can omit curly braces for one line statement (if, for, etc)\n# else should be placed on own line\n\n# Specific to Vyper:\n# arguments: snake_case\n# events, interfaces, structs: PascalCase\n# public functions: camelCase\n# private functions: _prefaceWithUnderscore\n\n\n# ---\n\n\n# 12. NATSPEC COMMENTS\n# used for documentation, commenting, and external UIs\n\n# Contract natspec - always above contract definition\n# @title Contract title\n# @author Author name\n\n# Function natspec\n# Should include in docstring of functions in typical Pythonic fashion\n# @notice Information about what function does; shown when function to execute\n# @dev Function documentation for developer\n\n# Function parameter/return value natspec\n# @param someParam Some description of what the param does\n# @return Description of the return value\n\n```\n\n## Additional resources\n- [Installation](https://vyper.readthedocs.io/en/latest/installing-vyper.html)\n- [Vyper Docs](https://media.readthedocs.org/pdf/vyper/latest/vyper.pdf)\n- [Vyper GitHub (under active dev)](https://github.com/ethereum/vyper)\n- [Tools and Resources](https://github.com/ethereum/vyper/wiki/Vyper-tools-and-resources)\n- [Online Compiler](https://vyper.online/)\n\n## Sample contracts\n- [Uniswap](https://github.com/Uniswap/contracts-vyper)\n- [Generalized Governance](https://github.com/kpeluso/gdg)\n- [Dynamic Arrays](https://github.com/kpeluso/vyper-dynamic-array)\n\n## Security\nVyper is secure by design, but it may be helpful to understand what Vyper is\nprotecting you from.\n- [Thinking About Smart Contract Security](https:#blog.ethereum.org/2016/06/19/thinking-smart-contract-security/)\n- [Smart Contract Security](https:#blog.ethereum.org/2016/06/10/smart-contract-security/)\n- [Hacking Distributed Blog](http:#hackingdistributed.com/)\n\n## Style\n- [Vyper Style Guide WIP](https://github.com/ethereum/vyper/issues/905)\n  - Heavily derived from [Solidity's style guide](http:#solidity.readthedocs.io/en/latest/style-guide.html) ...\n  - ... which, in turn, is heavily derived from Python's [PEP 8](https:#www.python.org/dev/peps/pep-0008/) style guide.\n\n## Editors\n- [Vyper for VS Code (alpha)](https://github.com/p-/vscode-vyper)\n\n## Future To Dos\n- Update to current Vyper release\n- List of common design patterns\n\n*Feel free to send a pull request with any edits - or email* `pelusoken -/at-/ gmail`"
