
package pages

const Lambda_Calculus = "# Lambda Calculus\n\nLambda calculus (λ-calculus), originally created by \n[Alonzo Church](https://en.wikipedia.org/wiki/Alonzo_Church),\nis the world's smallest programming language.\nDespite not having numbers, strings, booleans, or any non-function datatype,\nlambda calculus can be used to represent any Turing Machine!\n\nLambda calculus is composed of 3 elements: **variables**, **functions**, and\n**applications**.\n\n\n| Name        | Syntax                             | Example   | Explanation                                   |\n|-------------|------------------------------------|-----------|-----------------------------------------------|\n| Variable    | `<name>`                           | `x`       | a variable named \"x\"                          |\n| Function    | `λ<parameters>.<body>`             | `λx.x`    | a function with parameter \"x\" and body \"x\"    |\n| Application | `<function><variable or function>` | `(λx.x)a` | calling the function \"λx.x\" with argument \"a\" |\n\nThe most basic function is the identity function: `λx.x` which is equivalent to\n`f(x) = x`. The first \"x\" is the function's argument, and the second is the\nbody of the function.\n\n## Free vs. Bound Variables:\n\n- In the function `λx.x`, \"x\" is called a bound variable because it is both in\nthe body of the function and a parameter.\n- In `λx.y`, \"y\" is called a free variable because it is never declared before hand.\n\n## Evaluation:\n\nEvaluation is done via \n[β-Reduction](https://en.wikipedia.org/wiki/Lambda_calculus#Beta_reduction),\nwhich is essentially lexically-scoped substitution.\n\nWhen evaluating the\nexpression `(λx.x)a`, we replace all occurences of \"x\" in the function's body\nwith \"a\".\n\n- `(λx.x)a` evaluates to: `a`\n- `(λx.y)a` evaluates to: `y`\n\nYou can even create higher-order functions:\n\n- `(λx.(λy.x))a` evaluates to: `λy.a`\n\nAlthough lambda calculus traditionally supports only single parameter \nfunctions, we can create multi-parameter functions using a technique called \n[currying](https://en.wikipedia.org/wiki/Currying).\n\n- `(λx.λy.λz.xyz)` is equivalent to `f(x, y, z) = ((x y) z)`\n\nSometimes `λxy.<body>` is used interchangeably with: `λx.λy.<body>`\n\n----\n\nIt's important to recognize that traditional **lambda calculus doesn't have\nnumbers, characters, or any non-function datatype!**\n\n## Boolean Logic:\n\nThere is no \"True\" or \"False\" in lambda calculus. There isn't even a 1 or 0.\n\nInstead:\n\n`T` is represented by: `λx.λy.x`\n\n`F` is represented by: `λx.λy.y`\n\nFirst, we can define an \"if\" function `λbtf` that\nreturns `t` if `b` is True and `f` if `b` is False\n\n`IF` is equivalent to: `λb.λt.λf.b t f`\n\nUsing `IF`, we can define the basic boolean logic operators:\n\n`a AND b` is equivalent to: `λab.IF a b F`\n\n`a OR b` is equivalent to: `λab.IF a T b`\n\n`NOT a` is equivalent to: `λa.IF a F T`\n\n*Note: `IF a b c` is essentially saying: `IF((a b) c)`*\n\n## Numbers:\n\nAlthough there are no numbers in lambda calculus, we can encode numbers using\n[Church numerals](https://en.wikipedia.org/wiki/Church_encoding).\n\nFor any number n: <code>n = λf.f<sup>n</sup></code> so:\n\n`0 = λf.λx.x`\n\n`1 = λf.λx.f x`\n\n`2 = λf.λx.f(f x)`\n\n`3 = λf.λx.f(f(f x))`\n\nTo increment a Church numeral,\nwe use the successor function `S(n) = n + 1` which is:\n\n`S = λn.λf.λx.f((n f) x)`\n\nUsing successor, we can define add:\n\n`ADD = λab.(a S)b`\n\n**Challenge:** try defining your own multiplication function!\n\n## Get even smaller: SKI, SK and Iota\n\n### SKI Combinator Calculus\n\nLet S, K, I be the following functions:\n\n`I x = x`\n\n`K x y =  x`\n\n`S x y z = x z (y z)`\n\nWe can convert an expression in the lambda calculus to an expression\nin the SKI combinator calculus:\n\n1. `λx.x = I`\n2. `λx.c = Kc`\n3. `λx.(y z) = S (λx.y) (λx.z)`\n\nTake the church number 2 for example:\n\n`2 = λf.λx.f(f x)`\n\nFor the inner part `λx.f(f x)`:\n\n```\n  λx.f(f x)\n= S (λx.f) (λx.(f x))          (case 3)\n= S (K f)  (S (λx.f) (λx.x))   (case 2, 3)\n= S (K f)  (S (K f) I)         (case 2, 1)\n```\n\nSo:\n\n```\n  2\n= λf.λx.f(f x)\n= λf.(S (K f) (S (K f) I))\n= λf.((S (K f)) (S (K f) I))\n= S (λf.(S (K f))) (λf.(S (K f) I)) (case 3)\n```\n\nFor the first argument `λf.(S (K f))`:\n\n```\n  λf.(S (K f))\n= S (λf.S) (λf.(K f))       (case 3)\n= S (K S) (S (λf.K) (λf.f)) (case 2, 3)\n= S (K S) (S (K K) I)       (case 2, 3)\n```\n\nFor the second argument `λf.(S (K f) I)`:\n\n```\n  λf.(S (K f) I)\n= λf.((S (K f)) I)\n= S (λf.(S (K f))) (λf.I)             (case 3)\n= S (S (λf.S) (λf.(K f))) (K I)       (case 2, 3)\n= S (S (K S) (S (λf.K) (λf.f))) (K I) (case 1, 3)\n= S (S (K S) (S (K K) I)) (K I)       (case 1, 2)\n```\n\nMerging them up:\n\n```\n  2\n= S (λf.(S (K f))) (λf.(S (K f) I))\n= S (S (K S) (S (K K) I)) (S (S (K S) (S (K K) I)) (K I))\n```\n\nExpanding this, we would end up with the same expression for the\nchurch number 2 again.\n\n### SK Combinator Calculus\n\nThe SKI combinator calculus can still be reduced further. We can\nremove the I combinator by noting that `I = SKK`. We can substitute\nall `I`'s with `SKK`.\n\n### Iota Combinator\n\nThe SK combinator calculus is still not minimal. Defining:\n\n```\nι = λf.((f S) K)\n```\n\nWe have:\n\n```\nI = ιι\nK = ι(ιI) = ι(ι(ιι))\nS = ι(K) = ι(ι(ι(ιι)))\n```\n\n## For more advanced reading:\n\n1. [A Tutorial Introduction to the Lambda Calculus](http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf)\n2. [Cornell CS 312 Recitation 26: The Lambda Calculus](http://www.cs.cornell.edu/courses/cs3110/2008fa/recitations/rec26.html)\n3. [Wikipedia - Lambda Calculus](https://en.wikipedia.org/wiki/Lambda_calculus)\n4. [Wikipedia - SKI combinator calculus](https://en.wikipedia.org/wiki/SKI_combinator_calculus)\n5. [Wikipedia - Iota and Jot](https://en.wikipedia.org/wiki/Iota_and_Jot)"
