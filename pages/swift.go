
package pages

const Swift = "Swift is a programming language for iOS and OS X development created by Apple. Designed to coexist with Objective-C and to be more resilient against erroneous code, Swift was introduced in 2014 at Apple's developer conference WWDC. It is built with the LLVM compiler included in Xcode 6+.\n\nThe official _[Swift Programming Language](https://itunes.apple.com/us/book/swift-programming-language/id881256329)_ book from Apple is now available via iBooks. It goes into much more detail than this guide, and if you have the time and patience to read it, it's recommended. Some of these examples are from that book.\n\nAnother great reference is _About Swift_ on Swift's [website](https://docs.swift.org/swift-book/).\n\n```swift\n// import a module\nimport Foundation\n\n// Single-line comments are prefixed with //\n// Multi-line comments start with /* and end with */\n/* Nested multiline comments\n /* ARE */\n allowed\n */\n\n// Xcode supports landmarks to annotate your code and lists them in the jump bar\n// MARK: Section mark\n// MARK: - Section mark with a separator line\n// TODO: Do something soon\n// FIXME: Fix this code\n\n//MARK: Hello, World\n// From Swift 3 on, to print, just use the `print` method.\n// It automatically appends a new line.\nprint(\"Hello, world\")\n\n//\n// MARK: - Variables\n//\n\n\n//Use `let` to declare a constant and `var` to declare a variable.\nlet theAnswer = 42\nvar theQuestion = \"What is the Answer?\"\ntheQuestion = \"How many roads must a man walk down?\"\ntheQuestion = \"What is six by nine?\"\n// Atttempting to reassign a constant throws a compile-time error\n//theAnswer = 54\n\n// Both variables and constants can be declared before they are given a value,\n//   but must be given a value before they are used\nlet someConstant: Int\nvar someVariable: String\n// These lines will throw errors:\n//print(someConstant)\n//print(someVariable)\nsomeConstant = 0\nsomeVariable = \"0\"\n// These lines are now valid:\nprint(someConstant)\nprint(someVariable)\n\n// As you can see above, variable types are automatically inferred.\n//   To explicitly declare the type, write it after the variable name,\n//   separated by a colon.\nlet aString: String = \"A string\"\nlet aDouble: Double = 0\n\n// Values are never implicitly converted to another type.\n// Explicitly make instances of the desired type.\nlet stringWithDouble = aString + String(aDouble)\nlet intFromDouble = Int(aDouble)\n\n// For strings, use string interpolation\nlet descriptionString = \"The value of aDouble is \\(aDouble)\"\n// You can put any expression inside string interpolation.\nlet equation = \"Six by nine is \\(6 * 9), not 42!\"\n// To avoid escaping double quotes and backslashes, change the string delimiter\nlet explanationString = #\"The string I used was \"The value of aDouble is \\(aDouble)\" and the result was \\#(descriptionString)\"#\n// You can put as many number signs as you want before the opening quote,\n//   just match them at the ending quote. They also change the escape character\n//   to a backslash followed by the same number of number signs.\n\nlet multiLineString = \"\"\"\n    This is a multi-line string.\n    It's called that because it takes up multiple lines (wow!)\n        Any indentation beyond the closing quotation marks is kept, the rest is discarded.\n    You can include \" or \"\" in multi-line strings because the delimiter is three \"s.\n    \"\"\"\n\n// Arrays\nlet shoppingList = [\"catfish\", \"water\", \"tulips\",] //commas are allowed after the last element\nlet secondElement = shoppingList[1] // Arrays are 0-indexed\n\n// Arrays declared with let are immutable; the following line throws a compile-time error\n//shoppingList[2] = \"mango\"\n\n// Arrays are structs (more on that later), so this creates a copy instead of referencing the same object\nvar mutableShoppingList = shoppingList\nmutableShoppingList[2] = \"mango\"\n\n// == is equality\nshoppingList == mutableShoppingList // false\n\n// Dictionaries declared with let are also immutable\nvar occupations = [\n    \"Malcolm\": \"Captain\",\n    \"Kaylee\": \"Mechanic\"\n]\noccupations[\"Jayne\"] = \"Public Relations\"\n// Dictionaries are also structs, so this also creates a copy\nlet immutableOccupations = occupations\n\nimmutableOccupations == occupations // true\n\n// Arrays and dictionaries both automatically grow as you add elements\nmutableShoppingList.append(\"blue paint\")\noccupations[\"Tim\"] = \"CEO\"\n\n// They can both be set to empty\nmutableShoppingList = []\noccupations = [:]\n\nlet emptyArray = [String]()\nlet emptyArray2 = Array<String>() // same as above\n// [T] is shorthand for Array<T>\nlet emptyArray3: [String] = [] // Declaring the type explicitly allows you to set it to an empty array\nlet emptyArray4: Array<String> = [] // same as above\n\n// [Key: Value] is shorthand for Dictionary<Key, Value>\nlet emptyDictionary = [String: Double]()\nlet emptyDictionary2 = Dictionary<String, Double>() // same as above\nvar emptyMutableDictionary: [String: Double] = [:]\nvar explicitEmptyMutableDictionary: Dictionary<String, Double> = [:] // same as above\n\n// MARK: Other variables\nlet Ã¸Ï€Î© = \"value\" // unicode variable names\nlet ðŸ¤¯ = \"wow\" // emoji variable names\n\n// Keywords can be used as variable names\n// These are contextual keywords that wouldn't be used now, so are allowed\nlet convenience = \"keyword\"\nlet weak = \"another keyword\"\nlet override = \"another keyword\"\n\n// Using backticks allows keywords to be used as variable names even if they wouldn't be allowed normally\nlet `class` = \"keyword\"\n\n// MARK: - Optionals\n\n/*\n Optionals are a Swift language feature that either contains a value,\n or contains nil (no value) to indicate that a value is missing.\n Nil is roughly equivalent to `null` in other languages.\n A question mark (?) after the type marks the value as optional of that type.\n\n If a type is not optional, it is guaranteed to have a value.\n\n Because Swift requires every property to have a type, even nil must be\n explicitly stored as an Optional value.\n\n Optional<T> is an enum, with the cases .none (nil) and .some(T) (the value)\n */\n\nvar someOptionalString: String? = \"optional\" // Can be nil\n// T? is shorthand for Optional<T> â€” ? is a postfix operator (syntax candy)\nlet someOptionalString2: Optional<String> = nil\nlet someOptionalString3 = String?.some(\"optional\") // same as the first one\nlet someOptionalString4 = String?.none //nil\n\n/*\n To access the value of an optional that has a value, use the postfix\n operator !, which force-unwraps it. Force-unwrapping is like saying, \"I\n know that this optional definitely has a value, please give it to me.\"\n\n Trying to use ! to access a non-existent optional value triggers a\n runtime error. Always make sure that an optional contains a non-nil\n value before using ! to force-unwrap its value.\n */\n\nif someOptionalString != nil {\n    // I am not nil\n    if someOptionalString!.hasPrefix(\"opt\") {\n        print(\"has the prefix\")\n    }\n}\n\n// Swift supports \"optional chaining,\" which means that you can call functions\n//   or get properties of optional values and they are optionals of the appropriate type.\n// You can even do this multiple times, hence the name \"chaining.\"\n\nlet empty = someOptionalString?.isEmpty // Bool?\n\n// if-let structure -\n// if-let is a special structure in Swift that allows you to check\n//   if an Optional rhs holds a value, and if it does unwrap\n//   and assign it to the lhs.\nif let someNonOptionalStringConstant = someOptionalString {\n    // has `Some` value, non-nil\n    // someOptionalStringConstant is of type String, not type String?\n    if !someNonOptionalStringConstant.hasPrefix(\"ok\") {\n        // does not have the prefix\n    }\n}\n\n//if-var is allowed too!\nif var someNonOptionalString = someOptionalString {\n    someNonOptionalString = \"Non optional AND mutable\"\n    print(someNonOptionalString)\n}\n\n// You can bind multiple optional values in one if-let statement.\n//   If any of the bound values are nil, the if statement does not execute.\nif let first = someOptionalString, let second = someOptionalString2,\n    let third = someOptionalString3, let fourth = someOptionalString4 {\n    print(\"\\(first), \\(second), \\(third), and \\(fourth) are all not nil\")\n}\n\n//if-let supports \",\" (comma) clauses, which can be used to\n//   enforce conditions on newly-bound optional values.\n// Both the assignment and the \",\" clause must pass.\nlet someNumber: Int? = 7\nif let num = someNumber, num > 3 {\n    print(\"num is not nil and is greater than 3\")\n}\n\n// Implicitly unwrapped optional â€” An optional value that doesn't need to be unwrapped\nlet unwrappedString: String! = \"Value is expected.\"\n\n// Here's the difference:\nlet forcedString = someOptionalString! // requires an exclamation mark\nlet implicitString = unwrappedString // doesn't require an exclamation mark\n\n/*\n You can think of an implicitly unwrapped optional as giving permission\n for the optional to be unwrapped automatically whenever it's used.\n Rather than placing an exclamation mark after the optional's name each time you use it,\n you place an exclamation mark after the optional's type when you declare it.\n */\n\n// Otherwise, you can treat an implicitly unwrapped optional the same way the you treat a normal optional\n//   (i.e., if-let, != nil, etc.)\n\n// Pre-Swift 5, T! was shorthand for ImplicitlyUnwrappedOptional<T>\n// Swift 5 and later, using ImplicitlyUnwrappedOptional throws a compile-time error.\n//var unwrappedString2: ImplicitlyUnwrappedOptional<String> = \"Value is expected.\" //error\n\n// The nil-coalescing operator ?? unwraps an optional if it contains a non-nil value, or returns a default value.\nsomeOptionalString = nil\nlet someString = someOptionalString ?? \"abc\"\nprint(someString) // abc\n// a ?? b is shorthand for a != nil ? a! : b\n\n// MARK: - Control Flow\n\nlet condition = true\nif condition { print(\"condition is true\") } // can't omit the braces\n\nif theAnswer > 50 {\n    print(\"theAnswer > 50\")\n} else if condition {\n    print(\"condition is true\")\n} else {\n    print(\"Neither are true\")\n}\n\n// The condition in an `if` statement must be a `Bool`, so the following code is an error, not an implicit comparison to zero\n//if 5 {\n//    print(\"5 is not zero\")\n//}\n\n// Switch\n// Must be exhaustive\n// Does not implicitly fall through, use the fallthrough keyword\n// Very powerful, think `if` statements with syntax candy\n// They support String, object instances, and primitives (Int, Double, etc)\nlet vegetable = \"red pepper\"\nlet vegetableComment: String\nswitch vegetable {\ncase \"celery\":\n    vegetableComment = \"Add some raisins and make ants on a log.\"\ncase \"cucumber\", \"watercress\": // match multiple values\n    vegetableComment = \"That would make a good tea sandwich.\"\ncase let localScopeValue where localScopeValue.hasSuffix(\"pepper\"):\n    vegetableComment = \"Is it a spicy \\(localScopeValue)?\"\ndefault: // required (in order to cover all possible input)\n    vegetableComment = \"Everything tastes good in soup.\"\n}\nprint(vegetableComment)\n\n// You use the `for-in` loop to iterate over a sequence, such as an array, dictionary, range, etc.\nfor element in shoppingList {\n    print(element) // shoppingList is of type `[String]`, so element is of type `String`\n}\n//Iterating through a dictionary does not guarantee any specific order\nfor (person, job) in immutableOccupations {\n    print(\"\\(person)'s job is \\(job)\")\n}\nfor i in 1...5 {\n    print(i, terminator: \" \") // Prints \"1 2 3 4 5\"\n}\nfor i in 0..<5 {\n    print(i, terminator: \" \") // Prints \"0 1 2 3 4\"\n}\n//for index in range can replace a C-style for loop:\n//    for (int i = 0; i < 10; i++) {\n//        //code\n//    }\n//becomes:\n//    for i in 0..<10 {\n//        //code\n//    }\n//To step by more than one, use the stride(from:to:by:) or stride(from:through:by) functions\n//`for i in stride(from: 0, to: 10, by: 2)` is the same as `for (int i = 0; i < 10; i += 2)`\n//`for i in stride(from: 0, through: 10, by: 2)` is the same as `for (int i = 0; i <= 10; i += 2)\n\n// while loops are just like most languages\nvar i = 0\nwhile i < 5 {\n    i += Bool.random() ? 1 : 0\n    print(i)\n}\n\n// This is like a do-while loop in other languages â€” the body of the loop executes a minimum of once\nrepeat {\n    i -= 1\n    i += Int.random(in: 0...3)\n} while i < 5\n\n// The continue statement continues executing a loop at the next iteration\n// The break statement ends a swift or loop immediately\n\n// MARK: - Functions\n\n// Functions are a first-class type, meaning they can be nested in functions and can be passed around.\n\n// Function with Swift header docs (format as Swift-modified Markdown syntax)\n\n/// A greet operation.\n///\n/// - Parameters:\n///   - name: A name.\n///   - day: A day.\n/// - Returns: A string containing the name and day value.\nfunc greet(name: String, day: String) -> String {\n    return \"Hello \\(name), today is \\(day).\"\n}\ngreet(name: \"Bob\", day: \"Tuesday\")\n\n// Ideally, function names and parameter labels combine to make function calls similar to sentences.\nfunc sayHello(to name: String, onDay day: String) -> String {\n    return \"Hello \\(name), the day is \\(day)\"\n}\nsayHello(to: \"John\", onDay: \"Sunday\")\n\n//Functions that don't return anything can omit the return arrow; they don't need to say that they return Void (although they can).\nfunc helloWorld() {\n    print(\"Hello, World!\")\n}\n\n// Argument labels can be blank\nfunc say(_ message: String) {\n    print(#\"I say \"\\#(message)\"\"#)\n}\nsay(\"Hello\")\n\n// Default parameters can be omitted when calling the function.\nfunc printParameters(requiredParameter r: Int, optionalParameter o: Int = 10) {\n    print(\"The required parameter was \\(r) and the optional parameter was \\(o)\")\n}\nprintParameters(requiredParameter: 3)\nprintParameters(requiredParameter: 3, optionalParameter: 6)\n\n// Variadic args â€” only one set per function.\nfunc setup(numbers: Int...) {\n    // it's an array\n    let _ = numbers[0]\n    let _ = numbers.count\n}\n\n// pass by ref\nfunc swapTwoInts(a: inout Int, b: inout Int) {\n    let tempA = a\n    a = b\n    b = tempA\n}\nvar someIntA = 7\nvar someIntB = 3\nswapTwoInts(a: &someIntA, b: &someIntB) //must be called with an & before the variable name.\nprint(someIntB) // 7\n\ntype(of: greet) // (String, String) -> String\ntype(of: helloWorld) // () -> Void\n\n// Passing and returning functions\nfunc makeIncrementer() -> ((Int) -> Int) {\n    func addOne(number: Int) -> Int {\n        return 1 + number\n    }\n    return addOne\n}\nvar increment = makeIncrementer()\nincrement(7)\n\nfunc performFunction(_ function: (String, String) -> String, on string1: String, and string2: String) {\n    let result = function(string1, string2)\n    print(\"The result of calling the function on \\(string1) and \\(string2) was \\(result)\")\n}\n\n// Function that returns multiple items in a tuple\nfunc getGasPrices() -> (Double, Double, Double) {\n    return (3.59, 3.69, 3.79)\n}\nlet pricesTuple = getGasPrices()\nlet price = pricesTuple.2 // 3.79\n// Ignore Tuple (or other) values by using _ (underscore)\nlet (_, price1, _) = pricesTuple // price1 == 3.69\nprint(price1 == pricesTuple.1) // true\nprint(\"Gas price: \\(price)\")\n\n// Labeled/named tuple params\nfunc getGasPrices2() -> (lowestPrice: Double, highestPrice: Double, midPrice: Double) {\n    return (1.77, 37.70, 7.37)\n}\nlet pricesTuple2 = getGasPrices2()\nlet price2 = pricesTuple2.lowestPrice\nlet (_, price3, _) = pricesTuple2\nprint(pricesTuple2.highestPrice == pricesTuple2.1) // true\nprint(\"Highest gas price: \\(pricesTuple2.highestPrice)\")\n\n// guard statements\nfunc testGuard() {\n    // guards provide early exits or breaks, placing the error handler code near the conditions.\n    // it places variables it declares in the same scope as the guard statement.\n    // They make it easier to avoid the \"pyramid of doom\"\n    guard let aNumber = Optional<Int>(7) else {\n        return // guard statements MUST exit the scope that they are in.\n        // They generally use `return` or `throw`.\n    }\n\n    print(\"number is \\(aNumber)\")\n}\ntestGuard()\n\n// Note that the print function is declared like so:\n//     func print(_ input: Any..., separator: String = \" \", terminator: String = \"\\n\")\n// To print without a newline:\nprint(\"No newline\", terminator: \"\")\nprint(\"!\")\n\n// MARK: - Closures\n\nvar numbers = [1, 2, 6]\n\n// Functions are special case closures ({})\n\n// Closure example.\n// `->` separates the arguments and return type\n// `in` separates the closure header from the closure body\nnumbers.map({\n    (number: Int) -> Int in\n    let result = 3 * number\n    return result\n})\n\n// When the type is known, like above, we can do this\nnumbers = numbers.map({ number in 3 * number })\n// Or even this\n//numbers = numbers.map({ $0 * 3 })\n\nprint(numbers) // [3, 6, 18]\n\n// Trailing closure\nnumbers = numbers.sorted { $0 > $1 }\n\nprint(numbers) // [18, 6, 3]\n\n// MARK: - Enums\n\n// Enums can optionally be of a specific type or on their own.\n// They can contain methods like classes.\n\nenum Suit {\n    case spades, hearts, diamonds, clubs\n    var icon: Character {\n        switch self {\n        case .spades:\n            return \"â™¤\"\n        case .hearts:\n            return \"â™¡\"\n        case .diamonds:\n            return \"â™¢\"\n        case .clubs:\n            return \"â™§\"\n        }\n    }\n}\n\n// Enum values allow short hand syntax, no need to type the enum type\n// when the variable is explicitly declared\nvar suitValue: Suit = .hearts\n\n// Conforming to the CaseIterable protocol automatically synthesizes the allCases property,\n//   which contains all the values. It works on enums without associated values or @available attributes.\nenum Rank: CaseIterable {\n    case ace\n    case two, three, four, five, six, seven, eight, nine, ten\n    case jack, queen, king\n    var icon: String {\n        switch self {\n        case .ace:\n            return \"A\"\n        case .two:\n            return \"2\"\n        case .three:\n            return \"3\"\n        case .four:\n            return \"4\"\n        case .five:\n            return \"5\"\n        case .six:\n            return \"6\"\n        case .seven:\n            return \"7\"\n        case .eight:\n            return \"8\"\n        case .nine:\n            return \"9\"\n        case .ten:\n            return \"10\"\n        case .jack:\n            return \"J\"\n        case .queen:\n            return \"Q\"\n        case .king:\n            return \"K\"\n        }\n    }\n}\n\nfor suit in [Suit.clubs, .diamonds, .hearts, .spades] {\n    for rank in Rank.allCases {\n        print(\"\\(rank.icon)\\(suit.icon)\")\n    }\n}\n\n// String enums can have direct raw value assignments\n// or their raw values will be derived from the Enum field\nenum BookName: String {\n    case john\n    case luke = \"Luke\"\n}\nprint(\"Name: \\(BookName.john.rawValue)\")\n\n// Enum with associated Values\nenum Furniture {\n    // Associate with Int\n    case desk(height: Int)\n    // Associate with String and Int\n    case chair(String, Int)\n\n    func description() -> String {\n        //either placement of let is acceptable\n        switch self {\n        case .desk(let height):\n            return \"Desk with \\(height) cm\"\n        case let .chair(brand, height):\n            return \"Chair of \\(brand) with \\(height) cm\"\n        }\n    }\n}\n\nvar desk: Furniture = .desk(height: 80)\nprint(desk.description())     // \"Desk with 80 cm\"\nvar chair = Furniture.chair(\"Foo\", 40)\nprint(chair.description())    // \"Chair of Foo with 40 cm\"\n\n// MARK: - Structures & Classes\n\n/*\n Structures and classes in Swift have many things in common. Both can:\n - Define properties to store values\n - Define methods to provide functionality\n - Define subscripts to provide access to their values using subscript syntax\n - Define initializers to set up their initial state\n - Be extended to expand their functionality beyond a default implementation\n - Conform to protocols to provide standard functionality of a certain kind\n\n Classes have additional capabilities that structures don't have:\n - Inheritance enables one class to inherit the characteristics of another.\n - Type casting enables you to check and interpret the type of a class instance at runtime.\n - Deinitializers enable an instance of a class to free up any resources it has assigned.\n - Reference counting allows more than one reference to a class instance.\n\n Unless you need to use a class for one of these reasons, use a struct.\n\n Structures are value types, while classes are reference types.\n */\n\n// MARK: Structures\n\nstruct NamesTable {\n    let names: [String]\n\n    // Custom subscript\n    subscript(index: Int) -> String {\n        return names[index]\n    }\n}\n\n// Structures have an auto-generated (implicit) designated \"memberwise\" initializer\nlet namesTable = NamesTable(names: [\"Me\", \"Them\"])\nlet name = namesTable[1]\nprint(\"Name is \\(name)\") // Name is Them\n\n// MARK: Classes\n\nclass Shape {\n    func getArea() -> Int {\n        return 0\n    }\n}\n\nclass Rect: Shape {\n    var sideLength: Int = 1\n\n    // Custom getter and setter property\n    var perimeter: Int {\n        get {\n            return 4 * sideLength\n        }\n        set {\n            // `newValue` is an implicit variable available to setters\n            sideLength = newValue / 4\n        }\n    }\n\n    // Computed properties must be declared as `var`, you know, cause' they can change\n    var smallestSideLength: Int {\n        return self.sideLength - 1\n    }\n\n    // Lazily load a property\n    // subShape remains nil (uninitialized) until getter called\n    lazy var subShape = Rect(sideLength: 4)\n\n    // If you don't need a custom getter and setter,\n    // but still want to run code before and after getting or setting\n    // a property, you can use `willSet` and `didSet`\n    var identifier: String = \"defaultID\" {\n        // the `willSet` arg will be the variable name for the new value\n        willSet(someIdentifier) {\n            print(someIdentifier)\n        }\n    }\n\n    init(sideLength: Int) {\n        self.sideLength = sideLength\n        // always super.init last when init custom properties\n        super.init()\n    }\n\n    func shrink() {\n        if sideLength > 0 {\n            sideLength -= 1\n        }\n    }\n\n    override func getArea() -> Int {\n        return sideLength * sideLength\n    }\n}\n\n// A simple class `Square` extends `Rect`\nclass Square: Rect {\n    convenience init() {\n        self.init(sideLength: 5)\n    }\n}\n\nvar mySquare = Square()\nprint(mySquare.getArea()) // 25\nmySquare.shrink()\nprint(mySquare.sideLength) // 4\n\n// cast instance\nlet aShape = mySquare as Shape\n\n// downcast instance: \n// Because downcasting can fail, the result can be an optional (as?) or an implicitly unwrpped optional (as!).  \nlet anOptionalSquare = aShape as? Square // This will return nil if aShape is not a Square\nlet aSquare = aShape as! Square // This will throw a runtime error if aShape is not a Square\n\n// compare instances, not the same as == which compares objects (equal to)\nif mySquare === mySquare {\n    print(\"Yep, it's mySquare\")\n}\n\n// Optional init\nclass Circle: Shape {\n    var radius: Int\n    override func getArea() -> Int {\n        return 3 * radius * radius\n    }\n\n    // Place a question mark postfix after `init` is an optional init\n    // which can return nil\n    init?(radius: Int) {\n        self.radius = radius\n        super.init()\n\n        if radius <= 0 {\n            return nil\n        }\n    }\n}\n\nvar myCircle = Circle(radius: 1)\nprint(myCircle?.getArea())    // Optional(3)\nprint(myCircle!.getArea())    // 3\nvar myEmptyCircle = Circle(radius: -1)\nprint(myEmptyCircle?.getArea())    // \"nil\"\nif let circle = myEmptyCircle {\n    // will not execute since myEmptyCircle is nil\n    print(\"circle is not nil\")\n}\n\n// MARK: - Protocols\n\n// protocols are also known as interfaces in some other languages\n\n// `protocol`s can require that conforming types have specific\n// instance properties, instance methods, type methods,\n// operators, and subscripts.\n\nprotocol ShapeGenerator {\n    var enabled: Bool { get set }\n    func buildShape() -> Shape\n}\n\n// MARK: - Other\n\n// MARK: Typealiases\n\n// Typealiases allow one type (or composition of types) to be referred to by another name\ntypealias Integer = Int\nlet myInteger: Integer = 0\n\n// MARK: = Operator\n\n// Assignment does not return a value. This means it can't be used in conditional statements,\n//   and the following statement is also illegal\n//    let multipleAssignment = theQuestion = \"No questions asked\"\n//But you can do this:\nlet multipleAssignment = \"No questions asked\", secondConstant = \"No answers given\"\n\n// MARK: Ranges\n\n// The ..< and ... operators create ranges.\n\n// ... is inclusive on both ends (a \"closed range\") â€” mathematically, [0, 10]\nlet _0to10 = 0...10\n// ..< is inclusive on the left, exclusive on the right (a \"range\") â€” mathematically, [0, 10)\nlet singleDigitNumbers = 0..<10\n// You can omit one end (a \"PartialRangeFrom\") â€” mathematically, [0, âˆž)\nlet toInfinityAndBeyond = 0...\n// Or the other end (a \"PartialRangeTo\") â€” mathematically, (-âˆž, 0)\nlet negativeInfinityToZero = ..<0\n// (a \"PartialRangeThrough\") â€” mathematically, (-âˆž, 0]\nlet negativeInfinityThroughZero = ...0\n\n// MARK: Wildcard operator\n\n// In Swift, _ (underscore) is the wildcard operator, which allows values to be ignored\n\n// It allows functions to be declared without argument labels:\nfunc function(_ labelLessParameter: Int, label labeledParameter: Int, labelAndParameterName: Int) {\n    print(labelLessParameter, labeledParameter, labelAndParameterName)\n}\nfunction(0, label: 0, labelAndParameterName: 0)\n\n// You can ignore the return values of functions\nfunc printAndReturn(_ str: String) -> String {\n    print(str)\n    return str\n}\nlet _ = printAndReturn(\"Some String\")\n\n// You can ignore part of a tuple and keep part of it\nfunc returnsTuple() -> (Int, Int) {\n    return (1, 2)\n}\nlet (_, two) = returnsTuple()\n\n// You can ignore closure parameters\nlet closure: (Int, Int) -> String = { someInt, _ in\n    return \"\\(someInt)\"\n}\nclosure(1, 2) // returns 1\n\n// You can ignore the value in a for loop\nfor _ in 0..<10 {\n    // Code to execute 10 times\n}\n\n// MARK: Access Control\n\n/*\n Swift has five levels of access control:\n - Open: Accessible *and subclassible* in any module that imports it.\n - Public: Accessible in any module that imports it, subclassible in the module it is declared in.\n - Internal: Accessible and subclassible in the module it is declared in.\n - Fileprivate: Accessible and subclassible in the file it is declared in.\n - Private: Accessible and subclassible in the enclosing declaration (think inner classes/structs/enums)\n\n See more here: https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html\n */\n\n// MARK: Preventing Overrides\n\n// You can add keyword `final` before a class or instance method, or a property to prevent it from being overridden\nclass Shape {\n    final var finalInteger = 10\n}\n\n// Prevent a class from being subclassed\nfinal class ViewManager {\n}\n\n// MARK: Conditional Compilation, Compile-Time Diagnostics, & Availability Conditions\n\n// Conditional Compilation\n#if false\nprint(\"This code will not be compiled\")\n#else\nprint(\"This code will be compiled\")\n#endif\n/*\n Options are:\n os()                   macOS, iOS, watchOS, tvOS, Linux\n arch()                 i386, x86_64, arm, arm64\n swift()                >= or < followed by a version number\n compiler()             >= or < followed by a version number\n canImport()            A module name\n targetEnvironment()    simulator\n */\n#if swift(<3)\nprintln()\n#endif\n\n// Compile-Time Diagnostics\n// You can use #warning(message) and #error(message) to have the compiler emit warnings and/or errors\n#warning(\"This will be a compile-time warning\")\n//  #error(\"This would be a compile-time error\")\n\n//Availability Conditions\nif #available(iOSMac 10.15, *) {\n    // macOS 10.15 is available, you can use it here\n} else {\n    // macOS 10.15 is not available, use alternate APIs\n}\n\n// MARK: Any and AnyObject\n\n// Swift has support for storing a value of any type.\n// For that purpose there are two keywords: `Any` and `AnyObject`\n// `AnyObject` == `id` from Objective-C\n// `Any` works with any values (class, Int, struct, etc.)\nvar anyVar: Any = 7\nanyVar = \"Changed value to a string, not good practice, but possible.\"\nlet anyObjectVar: AnyObject = Int(1) as NSNumber\n\n// MARK: Extensions\n\n// Extensions allow you to add extra functionality to an already-declared type, even one that you don't have the source code for.\n\n// Square now \"conforms\" to the `CustomStringConvertible` protocol\nextension Square: CustomStringConvertible {\n    var description: String {\n        return \"Area: \\(self.getArea()) - ID: \\(self.identifier)\"\n    }\n}\n\nprint(\"Square: \\(mySquare)\")\n\n// You can also extend built-in types\nextension Int {\n    var doubled: Int {\n        return self * 2\n    }\n\n    func multipliedBy(num: Int) -> Int {\n        return num * self\n    }\n\n    mutating func multiplyBy(num: Int) {\n        self *= num\n    }\n}\n\nprint(7.doubled) // 14\nprint(7.doubled.multipliedBy(num: 3)) // 42\n\n// MARK: Generics\n\n// Generics: Similar to Java and C#. Use the `where` keyword to specify the\n//   requirements of the generics.\n\nfunc findIndex<T: Equatable>(array: [T], valueToFind: T) -> Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\nfindIndex(array: [1, 2, 3, 4], valueToFind: 3) // Optional(2)\n\n// You can extend types with generics as well\nextension Array where Array.Element == Int {\n    var sum: Int {\n        var total = 0\n        for el in self {\n            total += el\n        }\n        return total\n    }\n}\n\n// MARK: Operators\n\n// Custom operators can start with the characters:\n//      / = - + * % < > ! & | ^ . ~\n// or\n// Unicode math, symbol, arrow, dingbat, and line/box drawing characters.\nprefix operator !!!\n\n// A prefix operator that triples the side length when used\nprefix func !!! (shape: inout Square) -> Square {\n    shape.sideLength *= 3\n    return shape\n}\n\n// current value\nprint(mySquare.sideLength) // 4\n\n// change side length using custom !!! operator, increases size by 3\n!!!mySquare\nprint(mySquare.sideLength) // 12\n\n// Operators can also be generics\ninfix operator <->\nfunc <-><T: Equatable> (a: inout T, b: inout T) {\n    let c = a\n    a = b\n    b = c\n}\n\nvar foo: Float = 10\nvar bar: Float = 20\n\nfoo <-> bar\nprint(\"foo is \\(foo), bar is \\(bar)\") // \"foo is 20.0, bar is 10.0\"\n\n// MARK: - Error Handling\n\n// The `Error` protocol is used when throwing errors to catch\nenum MyError: Error {\n    case badValue(msg: String)\n    case reallyBadValue(msg: String)\n}\n\n// functions marked with `throws` must be called using `try`\nfunc fakeFetch(value: Int) throws -> String {\n    guard 7 == value else {\n        throw MyError.reallyBadValue(msg: \"Some really bad value\")\n    }\n\n    return \"test\"\n}\n\nfunc testTryStuff() {\n    // assumes there will be no error thrown, otherwise a runtime exception is raised\n    let _ = try! fakeFetch(value: 7)\n\n    // if an error is thrown, then it proceeds, but if the value is nil\n    // it also wraps every return value in an optional, even if its already optional\n    let _ = try? fakeFetch(value: 7)\n\n    do {\n        // normal try operation that provides error handling via `catch` block\n        try fakeFetch(value: 1)\n    } catch MyError.badValue(let msg) {\n        print(\"Error message: \\(msg)\")\n    } catch {\n        // must be exhaustive\n    }\n}\ntestTryStuff()\n```"
