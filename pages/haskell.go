
package pages

const Haskell = "Haskell was designed as a practical, purely functional programming\nlanguage. It's famous for its monads and its type system, but I keep coming back\nto it because of its elegance. Haskell makes coding a real joy for me.\n\n```haskell\n-- Single line comments start with two dashes.\n{- Multiline comments can be enclosed\nin a block like this.\n-}\n\n----------------------------------------------------\n-- 1. Primitive Datatypes and Operators\n----------------------------------------------------\n\n-- You have numbers\n3 -- 3\n\n-- Math is what you would expect\n1 + 1 -- 2\n8 - 1 -- 7\n10 * 2 -- 20\n35 / 5 -- 7.0\n\n-- Division is not integer division by default\n35 / 4 -- 8.75\n\n-- integer division\n35 `div` 4 -- 8\n\n-- Boolean values are primitives\nTrue\nFalse\n\n-- Boolean operations\nnot True -- False\nnot False -- True\n1 == 1 -- True\n1 /= 1 -- False\n1 < 10 -- True\n\n-- In the above examples, `not` is a function that takes one value.\n-- Haskell doesn't need parentheses for function calls...all the arguments\n-- are just listed after the function. So the general pattern is:\n-- func arg1 arg2 arg3...\n-- See the section on functions for information on how to write your own.\n\n-- Strings and characters\n\"This is a string.\"\n'a' -- character\n'You cant use single quotes for strings.' -- error!\n\n-- Strings can be concatenated\n\"Hello \" ++ \"world!\" -- \"Hello world!\"\n\n-- A string is a list of characters\n['H', 'e', 'l', 'l', 'o'] -- \"Hello\"\n\n-- Lists can be indexed with the `!!` operator followed by an index\n\"This is a string\" !! 0 -- 'T'\n\n\n----------------------------------------------------\n-- 2. Lists and Tuples\n----------------------------------------------------\n\n-- Every element in a list must have the same type.\n-- These two lists are equal:\n[1, 2, 3, 4, 5]\n[1..5]\n\n-- Ranges are versatile.\n['A'..'F'] -- \"ABCDEF\"\n\n-- You can create a step in a range.\n[0,2..10] -- [0, 2, 4, 6, 8, 10]\n[5..1] -- [] (Haskell defaults to incrementing)\n[5,4..1] -- [5, 4, 3, 2, 1]\n\n-- indexing into a list\n[1..10] !! 3 -- 4 (zero-based indexing)\n\n-- You can also have infinite lists in Haskell!\n[1..] -- a list of all the natural numbers\n\n-- Infinite lists work because Haskell has \"lazy evaluation\". This means\n-- that Haskell only evaluates things when it needs to. So you can ask for\n-- the 1000th element of your list and Haskell will give it to you:\n\n[1..] !! 999 -- 1000\n\n-- And now Haskell has evaluated elements 1 - 1000 of this list...but the\n-- rest of the elements of this \"infinite\" list don't exist yet! Haskell won't\n-- actually evaluate them until it needs to.\n\n-- joining two lists\n[1..5] ++ [6..10]\n\n-- adding to the head of a list\n0:[1..5] -- [0, 1, 2, 3, 4, 5]\n\n-- more list operations\nhead [1..5] -- 1\ntail [1..5] -- [2, 3, 4, 5]\ninit [1..5] -- [1, 2, 3, 4]\nlast [1..5] -- 5\n\n-- list comprehensions\n[x*2 | x <- [1..5]] -- [2, 4, 6, 8, 10]\n\n-- with a conditional\n[x*2 | x <- [1..5], x*2 > 4] -- [6, 8, 10]\n\n-- Every element in a tuple can be a different type, but a tuple has a\n-- fixed length.\n-- A tuple:\n(\"haskell\", 1)\n\n-- accessing elements of a pair (i.e. a tuple of length 2)\nfst (\"haskell\", 1) -- \"haskell\"\nsnd (\"haskell\", 1) -- 1\n\n-- pair element accessing does not work on n-tuples (i.e. triple, quadruple, etc)\nsnd (\"snd\", \"can't touch this\", \"da na na na\") -- error! see function below\n\n----------------------------------------------------\n-- 3. Functions\n----------------------------------------------------\n-- A simple function that takes two variables\nadd a b = a + b\n\n-- Note that if you are using ghci (the Haskell interpreter)\n-- You'll need to use `let`, i.e.\n-- let add a b = a + b\n\n-- Using the function\nadd 1 2 -- 3\n\n-- You can also put the function name between the two arguments\n-- with backticks:\n1 `add` 2 -- 3\n\n-- You can also define functions that have no letters! This lets\n-- you define your own operators! Here's an operator that does\n-- integer division\n(//) a b = a `div` b\n35 // 4 -- 8\n\n-- Guards: an easy way to do branching in functions\nfib x\n  | x < 2 = 1\n  | otherwise = fib (x - 1) + fib (x - 2)\n\n-- Pattern matching is similar. Here we have given three different\n-- equations that define fib. Haskell will automatically use the first\n-- equation whose left hand side pattern matches the value.\nfib 1 = 1\nfib 2 = 2\nfib x = fib (x - 1) + fib (x - 2)\n\n-- Pattern matching on tuples\nsndOfTriple (_, y, _) = y -- use a wild card (_) to bypass naming unused value\n\n-- Pattern matching on lists. Here `x` is the first element\n-- in the list, and `xs` is the rest of the list. We can write\n-- our own map function:\nmyMap func [] = []\nmyMap func (x:xs) = func x:(myMap func xs)\n\n-- Anonymous functions are created with a backslash followed by\n-- all the arguments.\nmyMap (\\x -> x + 2) [1..5] -- [3, 4, 5, 6, 7]\n\n-- using fold (called `inject` in some languages) with an anonymous\n-- function. foldl1 means fold left, and use the first value in the\n-- list as the initial value for the accumulator.\nfoldl1 (\\acc x -> acc + x) [1..5] -- 15\n\n----------------------------------------------------\n-- 4. More functions\n----------------------------------------------------\n\n-- partial application: if you don't pass in all the arguments to a function,\n-- it gets \"partially applied\". That means it returns a function that takes the\n-- rest of the arguments.\n\nadd a b = a + b\nfoo = add 10 -- foo is now a function that takes a number and adds 10 to it\nfoo 5 -- 15\n\n-- Another way to write the same thing\nfoo = (10+)\nfoo 5 -- 15\n\n-- function composition\n-- the operator `.` chains functions together.\n-- For example, here foo is a function that takes a value. It adds 10 to it,\n-- multiplies the result of that by 4, and then returns the final value.\nfoo = (4*) . (10+)\n\n-- 4*(10+5) = 60\nfoo 5 -- 60\n\n-- fixing precedence\n-- Haskell has an operator called `$`. This operator applies a function\n-- to a given parameter. In contrast to standard function application, which\n-- has highest possible priority of 10 and is left-associative, the `$` operator\n-- has priority of 0 and is right-associative. Such a low priority means that\n-- the expression on its right is applied as a parameter to the function on its left.\n\n-- before\neven (fib 7) -- false\n\n-- equivalently\neven $ fib 7 -- false\n\n-- composing functions\neven . fib $ 7 -- false\n\n\n----------------------------------------------------\n-- 5. Type signatures\n----------------------------------------------------\n\n-- Haskell has a very strong type system, and every valid expression has a type.\n\n-- Some basic types:\n5 :: Integer\n\"hello\" :: String\nTrue :: Bool\n\n-- Functions have types too.\n-- `not` takes a boolean and returns a boolean:\n-- not :: Bool -> Bool\n\n-- Here's a function that takes two arguments:\n-- add :: Integer -> Integer -> Integer\n\n-- When you define a value, it's good practice to write its type above it:\ndouble :: Integer -> Integer\ndouble x = x * 2\n\n----------------------------------------------------\n-- 6. Control Flow and If Expressions\n----------------------------------------------------\n\n-- if-expressions\nhaskell = if 1 == 1 then \"awesome\" else \"awful\" -- haskell = \"awesome\"\n\n-- if-expressions can be on multiple lines too, indentation is important\nhaskell = if 1 == 1\n            then \"awesome\"\n            else \"awful\"\n\n-- case expressions: Here's how you could parse command line arguments\ncase args of\n  \"help\" -> printHelp\n  \"start\" -> startProgram\n  _ -> putStrLn \"bad args\"\n\n-- Haskell doesn't have loops; it uses recursion instead.\n-- map applies a function over every element in a list\n\nmap (*2) [1..5] -- [2, 4, 6, 8, 10]\n\n-- you can make a for function using map\nfor array func = map func array\n\n-- and then use it\nfor [0..5] $ \\i -> show i\n\n-- we could've written that like this too:\nfor [0..5] show\n\n-- You can use foldl or foldr to reduce a list\n-- foldl <fn> <initial value> <list>\nfoldl (\\x y -> 2*x + y) 4 [1,2,3] -- 43\n\n-- This is the same as\n(2 * (2 * (2 * 4 + 1) + 2) + 3)\n\n-- foldl is left-handed, foldr is right-handed\nfoldr (\\x y -> 2*x + y) 4 [1,2,3] -- 16\n\n-- This is now the same as\n(2 * 1 + (2 * 2 + (2 * 3 + 4)))\n\n----------------------------------------------------\n-- 7. Data Types\n----------------------------------------------------\n\n-- A data type is declared with a 'type constructor' on the left\n-- and one or more 'data constructors' on the right, separated by\n-- the pipe | symbol. This is a sum/union type. Each data constructor\n-- is a (possibly nullary) function that creates an object of the type\n-- named by the type constructor.\n\n-- This is essentially an enum\n\ndata Color = Red | Blue | Green\n\n-- Now you can use it in a function:\n\nsay :: Color -> String\nsay Red   = \"You are Red!\"\nsay Blue  = \"You are Blue!\"\nsay Green = \"You are Green!\"\n\n-- Note that the type constructor is used in the type signature\n-- and the data constructors are used in the body of the function\n-- Data constructors are primarily pattern-matched against\n\n-- This next one is a traditional container type holding two fields\n-- In a type declaration, data constructors take types as parameters\n-- Data constructors can have the same name as type constructors\n-- This is common where the type only has a single data constructor\n\ndata Point = Point Float Float\n\n-- This can be used in a function like:\n\ndistance :: Point -> Point -> Float\ndistance (Point x y) (Point x' y') = sqrt $ dx + dy\n    where dx = (x - x') ** 2\n          dy = (y - y') ** 2\n          \n-- Types can have multiple data constructors with arguments, too\n\ndata Name = Mononym String\n          | FirstLastName String String\n          | FullName String String String\n\n-- To make things clearer we can use record syntax\n\ndata Point2D = CartesianPoint2D { x :: Float, y :: Float } \n             | PolarPoint2D { r :: Float, theta :: Float }\n\nmyPoint = CartesianPoint2D { x = 7.0, y = 10.0 }\n\n-- Using record syntax automatically creates accessor functions\n-- (the name of the field)\n\nxOfMyPoint = x myPoint\n\n-- xOfMyPoint is equal to 7.0\n\n-- Record syntax also allows a simple form of update\n\nmyPoint' = myPoint { x = 9.0 }\n\n-- myPoint' is CartesianPoint2D { x = 9.0, y = 10.0 }\n\n-- Even if a type is defined with record syntax, it can be declared like\n-- a simple data constructor. This is fine:\n\nmyPoint'2 = CartesianPoint2D 3.3 4.0\n\n-- It's also useful to pattern match data constructors in `case` expressions\n\ndistanceFromOrigin x = \n    case x of (CartesianPoint2D x y) -> sqrt $ x ** 2 + y ** 2\n              (PolarPoint2D r _) -> r\n\n-- Your data types can have type parameters too:\n\ndata Maybe a = Nothing | Just a\n\n-- These are all of type Maybe\nJust \"hello\"    -- of type `Maybe String`\nJust 1          -- of type `Maybe Int`\nNothing         -- of type `Maybe a` for any `a`\n\n-- For convenience we can also create type synonyms with the 'type' keyword\n\ntype String = [Char]\n\n-- Unlike `data` types, type synonyms need no constructor, and can be used \n-- anywhere a synonymous data type could be used. Say we have the \n-- following type synonyms and items with the following type signatures\n\ntype Weight = Float\ntype Height = Float\ntype Point = (Float, Float)\ngetMyHeightAndWeight :: Person -> (Height, Weight)\nfindCenter :: Circle -> Point\nsomePerson :: Person\nsomeCircle :: Circle\ndistance :: Point -> Point -> Float\n\n-- The following would compile and run without issue, \n-- even though it does not make sense semantically,\n-- because the type synonyms reduce to the same base types\n\ndistance (getMyHeightAndWeight somePerson) (findCenter someCircle)\n\n----------------------------------------------------\n-- 8. Typeclasses\n----------------------------------------------------\n\n-- Typeclasses are one way Haskell does polymorphism\n-- They are similar to interfaces in other languages\n-- A typeclass defines a set of functions that must \n-- work on any type that is in that typeclass.\n\n-- The Eq typeclass is for types whose instances can \n-- be tested for equality with one another.\n\nclass Eq a where  \n    (==) :: a -> a -> Bool  \n    (/=) :: a -> a -> Bool  \n    x == y = not (x /= y)  \n    x /= y = not (x == y)\n    \n-- This defines a typeclass that requires two functions, (==) and (/=)\n-- It also declares that one function can be declared in terms of another\n-- So it is enough that *either* the (==) function or the (/=) is defined\n-- And the other will be 'filled in' based on the typeclass definition\n\n-- To make a type a member of a type class, the instance keyword is used\n\ninstance Eq TrafficLight where  \n    Red == Red = True  \n    Green == Green = True  \n    Yellow == Yellow = True  \n    _ == _ = False \n    \n-- Now we can use (==) and (/=) with TrafficLight objects\n\ncanProceedThrough :: TrafficLight -> Bool\ncanProceedThrough t = t /= Red\n\n-- You can NOT create an instance definition for a type synonym\n\n-- Functions can be written to take typeclasses with type parameters, \n-- rather than types, assuming that the function only relies on \n-- features of the typeclass\n\nisEqual (Eq a) => a -> a -> Bool\nisEqual x y = x == y\n\n-- Note that x and y MUST be the same type, as they are both defined\n-- as being of type parameter 'a'.\n-- A typeclass does not state that different types in the typeclass can \n-- be mixed together.\n-- So `isEqual Red 2` is invalid, even though 2 is an Int which is an \n-- instance of Eq, and Red is a TrafficLight which is also an instance of Eq\n\n-- Other common typeclasses are:\n-- Ord for types that can be ordered, allowing you to use >, <=, etc.\n-- Read for types that can be created from a string representation\n-- Show for types that can be converted to a string for display\n-- Num, Real, Integral, Fractional for types that can do math\n-- Enum for types that can be stepped through\n-- Bounded for types with a maximum and minimum\n\n-- Haskell can automatically make types part of Eq, Ord, Read, Show, Enum, \n-- and Bounded with the `deriving` keyword at the end of the type declaration\n\ndata Point = Point Float Float deriving (Eq, Read, Show)\n    \n-- In this case it is NOT necessary to create an 'instance' definition\n\n----------------------------------------------------\n-- 9. Haskell IO\n----------------------------------------------------\n\n-- While IO can't be explained fully without explaining monads,\n-- it is not hard to explain enough to get going.\n\n-- When a Haskell program is executed, `main` is\n-- called. It must return a value of type `IO a` for some type `a`. For example:\n\nmain :: IO ()\nmain = putStrLn $ \"Hello, sky! \" ++ (say Blue)\n-- putStrLn has type String -> IO ()\n\n-- It is easiest to do IO if you can implement your program as\n-- a function from String to String. The function\n--    interact :: (String -> String) -> IO ()\n-- inputs some text, runs a function on it, and prints out the\n-- output.\n\ncountLines :: String -> String\ncountLines = show . length . lines\n\nmain' = interact countLines\n\n-- You can think of a value of type `IO ()` as representing a\n-- sequence of actions for the computer to do, much like a\n-- computer program written in an imperative language. We can use\n-- the `do` notation to chain actions together. For example:\n\nsayHello :: IO ()\nsayHello = do\n   putStrLn \"What is your name?\"\n   name <- getLine -- this gets a line and gives it the name \"name\"\n   putStrLn $ \"Hello, \" ++ name\n\n-- Exercise: write your own version of `interact` that only reads\n--           one line of input.\n\n-- The code in `sayHello` will never be executed, however. The only\n-- action that ever gets executed is the value of `main`.\n-- To run `sayHello` comment out the above definition of `main`\n-- and replace it with:\n--   main = sayHello\n\n-- Let's understand better how the function `getLine` we just\n-- used works. Its type is:\n--    getLine :: IO String\n-- You can think of a value of type `IO a` as representing a\n-- computer program that will generate a value of type `a`\n-- when executed (in addition to anything else it does). We can\n-- name and reuse this value using `<-`. We can also\n-- make our own action of type `IO String`:\n\naction :: IO String\naction = do\n   putStrLn \"This is a line. Duh\"\n   input1 <- getLine\n   input2 <- getLine\n   -- The type of the `do` statement is that of its last line.\n   -- `return` is not a keyword, but merely a function\n   return (input1 ++ \"\\n\" ++ input2) -- return :: String -> IO String\n\n-- We can use this just like we used `getLine`:\n\nmain'' = do\n    putStrLn \"I will echo two lines!\"\n    result <- action\n    putStrLn result\n    putStrLn \"This was all, folks!\"\n\n-- The type `IO` is an example of a \"monad\". The way Haskell uses a monad to\n-- do IO allows it to be a purely functional language. Any function that\n-- interacts with the outside world (i.e. does IO) gets marked as `IO` in its\n-- type signature. This lets us reason about which functions are \"pure\" (don't\n-- interact with the outside world or modify state) and which functions aren't.\n\n-- This is a powerful feature, because it's easy to run pure functions\n-- concurrently; so, concurrency in Haskell is very easy.\n\n\n----------------------------------------------------\n-- 10. The Haskell REPL\n----------------------------------------------------\n\n-- Start the repl by typing `ghci`.\n-- Now you can type in Haskell code. Any new values\n-- need to be created with `let`:\n\nlet foo = 5\n\n-- You can see the type of any value or expression with `:t`:\n\n> :t foo\nfoo :: Integer\n\n-- Operators, such as `+`, `:` and `$`, are functions.\n-- Their type can be inspected by putting the operator in parentheses:\n\n> :t (:)\n(:) :: a -> [a] -> [a]\n\n-- You can get additional information on any `name` using `:i`:\n\n> :i (+)\nclass Num a where\n  (+) :: a -> a -> a\n  ...\n    -- Defined in ‘GHC.Num’\ninfixl 6 +\n\n-- You can also run any action of type `IO ()`\n\n> sayHello\nWhat is your name?\nFriend!\nHello, Friend!\n\n```\n\nThere's a lot more to Haskell, including typeclasses and monads. These are the\nbig ideas that make Haskell such fun to code in. I'll leave you with one final\nHaskell example: an implementation of a quicksort variant in Haskell:\n\n```haskell\nqsort [] = []\nqsort (p:xs) = qsort lesser ++ [p] ++ qsort greater\n    where lesser  = filter (< p) xs\n          greater = filter (>= p) xs\n```\n\nThere are two popular ways to install Haskell: The traditional [Cabal-based installation](http://www.haskell.org/platform/), and the newer [Stack-based process](https://www.stackage.org/install).\n\nYou can find a much gentler introduction from the excellent\n[Learn you a Haskell](http://learnyouahaskell.com/),\n[Happy Learn Haskell Tutorial](http://www.happylearnhaskelltutorial.com/) or\n[Real World Haskell](http://book.realworldhaskell.org/)."
