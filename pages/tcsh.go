
package pages

const Tcsh = "tcsh (\"tee-see-shell\") is a Unix shell based on and compatible with the C shell (csh).\nIt is essentially the C shell with programmable command-line completion, command-line editing,\nand a few other features.\nIt is the native root shell for BSD-based systems such as FreeBSD.\n\nAlmost all Linux distros and BSD today use tcsh instead of the original csh. In\nmost cases csh is a symbolic link that points to tcsh.\nThis is because tcsh is backward compatible with csh, and the last\nis not maintained anymore.\n\n- [TCSH Home](http://www.tcsh.org/)\n- [TCSH Wikipedia](https://en.wikipedia.org/wiki/Tcsh)\n- [TCSH manual page](http://www.tcsh.org/tcsh.html/top.html)\n- [“An Introduction to the C shell”, William Joy](https://docs.freebsd.org/44doc/usd/04.csh/paper.html)\n- [TCSH Bug reports and/or features requests](https://bugs.gw.com/)\n\nSome more files:\n[tcsh help command (for 132x35 terminal size)](https://github.com/nereusx/dotfiles/blob/master/csh-help),\n[my ~/.tcshrc](https://github.com/nereusx/dotfiles/blob/master/.tcshrc)\n\n```tcsh\n#!/bin/tcsh\n# First line of the script is shebang which tells the system how to execute the\n# script: http://en.wikipedia.org/wiki/Shebang_(Unix)\n# TCSH emulates the shebang on systems which don't understand it.\n\n# In most cases you'll use `#!/bin/tcsh -f', because `-f' option does not load\n# any resource or start-up files, or perform any command hashing, and thus\n# starts faster.\n\n# --- the echo command --------------------------------------------------------\n# The `echo' writes each word to the shell's standard output, separated by\n# spaces and terminated with a newline. The echo_style shell variable may be\n# set to emulate (or not) the flags and escape sequences.\n\n# Display the value of echo_style\necho $echo_style\n\n# Enable `echo' to support backslashed characters and `-n' option (no new line)\n# This is the default for tcsh, but your distro may change it. Slackware has\n# done so.\nset echo_style = both\n\n# Prints \"Hello world\"\necho Hello world\necho \"Hello world\"\necho 'Hello world'\necho `echo Hello world`\n\n# This prints \"twonlines\" in one line\necho two\\nlines\n\n# Prints the two lines\necho \"two\\nlines\"\necho 'two\\nlines'\n\n# --- Basic Syntax ------------------------------------------------------------\n\n# A special character (including a blank or tab) may be prevented from having\n# its special meaning by preceding it with a backslash `\\'.\n# this will display the last history commands\necho !!\n# this will not\necho \\!\\!\n\n# Single quotes prevents expanding special characters too, but some\n# characters like `!' and backslash have higher priority\n# `$' (variable value) will not expands\necho '$1 tip'\n# `!' (history) will expands\necho '!!'\n\n# Strings enclosed by back-quotes will be executed and replaced by the result.\necho `ls`\n\n# Semi-colon separate commands\necho 'first line'; echo 'second line'\n\n# There is also conditional execution\necho \"Always executed\" || echo \"Only executed if first command fails\"\necho \"Always executed\" && echo \"Only executed if first command does NOT fail\"\n\n# Parenthesised commands are always executed in a subshell,\n\n# example: create a project and then informs you that it finished while\n# it does the installation.\nmake && ( espeak \"BOSS, compilation finished\"; make install )\n\n# prints the home directory but leaving you where you were\n(cd; pwd); pwd\n\n# Read tcsh man-page documentation\nman tcsh\n\n# --- Variables ---------------------------------------------------------------\n# The shell maintains a list of variables, each of which has as value a list of\n# zero or more words. The values of shell variables can be displayed and\n# changed with the `set' and `unset' commands.\n# The system maintains its own list of ``environment'' variables.\n# These can be displayed and changed with `printenv', `setenv' and `unsetenv'.\n# The syntax of setenv is similar to POSIX sh.\n\n# Assign a value or nothing will create a variable\n# Assign nothing\nset var\n# Assign a numeric value\n# the '@' denotes the expression is arithmetic; it works similar to 'set' but\n# the right value can be a numeric expression.\n@ var = 1 + 2\n# Assign a string value\nset var = \"Hello, I am the contents of 'var' variable\"\n# Assign the output of a program\nset var = `ls`\n\n# Remove a variable\nunset var\n# Prints 1 (true) if the variable `var' exists otherwise prints 0 (false)\necho $?var\n# Print all variables and their values\nset\n\n# Prints the contents of 'var'\necho $var;\necho \"$var\";\n# Prints the string `$var'\necho \\$var\necho '$var'\n# braces can be used to separate variable from the rest when its needed\nset num = 12; echo \"There ${num}th element\"\n\n# Prints the number of characters of the value: 6\nset var = '123456'; echo $%var\n\n### LISTs\n# Assign a list of values\nset var = ( one two three four five )\n# Print all the elements: one two three four five\necho $var\necho $var[*]\n# Print the count of elements: 5\necho $#var\n# Print indexed element; prints the second element: two\necho $var[2]\n# Print range of elements; prints 2nd up to 3rd: two, three\necho $var[2-3]\n# Prints all elements starting from the 3rd: three four five\necho $var[3-]\n# Prints print all up to 3rd element: one two three\necho $var[-3]\n\n### Special Variables\n# $argv         list of command-line arguments\n# $argv[0]      this file-name (the file of the script file)\n# $# $0, $n, $* are the same as $#argv, $argv[0], $argv[n], $argv[*]\n# $status, $?   the exit code of the last command that executed\n# $_            the previous command line\n# $!            the PID of the last background process started by this shell\n# $$            script's PID\n\n# $path, $PATH  the list of directories that will search for executable to run\n# $home, $HOME  user's home directory, also the `~' can be used instead\n# $uid          user's login ID\n# $user         user's login name\n# $gid          the user's group ID\n# $group        the user's group-name\n# $cwd, $PWD    the Current/Print Working Directory\n# $owd          the previous working directory\n# $tcsh         tcsh version\n# $tty          the current tty; ttyN for linux console, pts/N for terminal\n#               emulators under X\n# $term         the terminal type\n# $verbose      if set, causes the words of each command to be printed.\n#               can be set by the `-v' command line option too.\n# $loginsh      if set, it is a login shell\n\n# TIP: $?0 is always false in interactive shells\n# TIP: $?prompt is always false in non-interactive shells\n# TIP: if `$?tcsh' is unset; you run the original `csh' or something else;\n#      try `echo $shell'\n# TIP: $verbose this is useful to debugging scripts\n# NOTE: $PWD and $PATH are synchronised with $cwd and $pwd automatically.\n\n# --- Variable modifiers ------------------------------------------------------\n# Syntax: ${var}:m[:mN]\n# Where <m> is:\n# h : the directory  t : the filenane  r : remove extension   e : the extension\n# u : uppercase the first lowercase letter\n# l : lowercase the first uppercase letter\n# p : print but do not execute it (hist)\n# q : quote the substituted words, preventing further substitutions\n# x : like q, but break into words at white spaces\n# g : apply the following modifier once to each word\n# a  : apply the following modifier as many times as possible to single word\n# s/l/r/ : search for `l' and replace with `r', not regex; the `&' in the r is\n# replaced by l\n# & : Repeat the previous substitution\n\n# start with this file\nset f = ~/Documents/Alpha/beta.txt\n# prints ~/Documents/Alpha/beta\necho $f:r\n# prints ~/Documents/Alpha\necho $f:h\n# prints beta.txt\necho $f:t\n# prints txt\necho $f:e\n# prints beta\necho $f:t:r\n# prints Beta\necho $f:t:r:u\n# prints Biota\necho $f:t:r:u:s/eta/iota/\n\n# --- Redirection -------------------------------------------------------------\n\n# Create file.txt and write the standard output to it\necho 'this string' > file.txt\n# Create file.txt and write the standard output and standard error to it\necho 'this string' >& file.txt\n# Append the standard output to file.txt\necho 'this string' >> file.txt\n# Append the standard output and standard error to file.txt\necho 'this string' >>& file.txt\n# Redirect the standard input from file.txt\ncat < file.txt\n# Input from keyboard; this stores the input line to variable `x'\nset x = $<\n# Document here;\ncat << LABEL\n...text here...\nLABEL\n\n# TIP: this is how to get standard error separated:\n(grep 'AGP' /usr/src/linux/Documentation/* > output-file.txt) >& error-file.txt\n\n# example: read a name from standard input and display a greetings message\necho -n \"Enter your name? \"\nset name = $<\necho \"Greetings $name\"\n\n# --- Expressions ------------------------------------------------------------\n\n# Operators:\n# ==  equal         !=  not equal    !  not\n#  >  greater than   <  less than   >=  greater or equal  <= less or equal\n# &&  logical AND   ||  logical OR\n\nif ( $name != $user ) then\n    echo \"Your name isn't your username\"\nelse\n    echo \"Your name is your username\"\nendif\n\n# single-line form\nif ( $name != $user ) echo \"Your name isn't your username\"\n\n# NOTE: if $name is empty, tcsh sees the above condition as:\n# if ( != $user ) ...\n# which is invalid syntax\n# so the \"safe\" way to use potentially empty variables in tcsh is:\n# if ( \"$name\" != $user ) ...\n# which, when $name is empty, is seen by tcsh as:\n# if ( \"\" != $user ) ...\n# which works as expected\n\n# There is also conditional execution\necho \"Always executed\" || echo \"Only executed if first command fails\"\necho \"Always executed\" && echo \"Only executed if first command does NOT fail\"\n\n# To use && and || with if statements, you don't need multiple pairs of\n# square brackets:\nif ( \"$name\" == \"Steve\" && \"$age\" == 15 ) then\n    echo \"This will run if $name is Steve AND $age is 15.\"\nendif\n\nif ( \"$name\" == \"Daniya\" || \"$name\" == \"Zach\" ) then\n    echo \"This will run if $name is Daniya OR Zach.\"\nendif\n\n# String matching operators ( `=~' and `!~' )\n# The ‘==’ ‘!=’ ‘=~’ and ‘!~’ operators compare their arguments as strings;\n# all others operate on numbers. The operators ‘=~’ and ‘!~’ are like ‘!=’\n# and ‘==’ except that the right hand side is a glob-pattern against which\n# the left hand operand is matched.\n\nif ( $user =~ ni[ck]* ) echo \"Greetings Mr. Nicholas.\"\nif ( $user !~ ni[ck]* ) echo \"Hey, get out of Nicholas PC.\"\n\n# Arithmetic expressions are denoted with the following format:\n@ result = 10 + 5\necho $result\n\n# Arithmetic Operators\n# +, -, *, /, %\n#\n# Arithmetic Operators which must be parenthesised\n# !, ~, |, &, ^, ~, <<, >>,\n# Compare and logical operators\n#\n# All operators are same as in C.\n\n# It is non so well documented that numeric expressions require spaces\n# in-between; Also, `@' has its own parser, it seems that work well when the\n# expression is parenthesised otherwise the primary parser seems it is active.\n# Parenthesis require spaces around, this is documented.\n\n# wrong\n@ x = $y+1\n@ x = 0644 & 022;      echo $x\n@ x = (0644 & 022) +1; echo $x\n@ x = (0644 & 022)+ 1; echo $x\n@ x = ( ~077 );        echo $x\n\n# correct\n@ x = $y + 1\n@ x = ( 0644 & 022 ) + 1; echo $x\n@ x = ( ~ 077 );          echo $x\n@ x = ( ~ 077 | 022 );    echo $x\n@ x = ( ! 0 );            echo $x\n\n# C's operators ++ and -- are supported if there is not assignment\n@ result ++\n\n# None shell created to do mathematics;\n# Except for the basic operations, use an external command with backslashes.\n#\n# I suggest the calc as the best option.\n# (http://www.isthe.com/chongo/tech/comp/calc/)\n#\n# The standard Unix's bc as second option\n# (https://www.gnu.org/software/bc/manual/html_mono/bc.html)\n#\n# The standard Unix's AWK as third option\n# (https://www.gnu.org/software/gawk/manual/gawk.html)\n\n# You can also use `perl', `php' or even several BASICs, but prefer the\n# above utilities for faster load-and-run results.\n\n# real example: (that I answer in StackExchange)\n# REQ: x := 1001b OR 0110b\n\n# in `tcsh' expression (by using octal)\n@ x = ( 011 | 06 ); echo $x\n\n# the same by using `calc' (and using binary as the original req)\nset x = `calc '0b1001 | 0b110'`; echo $x\n\n# --- File Inquiry Operators --------------------------------------------------\n# NOTE: The builtin `filetest' command do the same thing.\n\n#### Boolean operators\n# -r  read access    -w  write access    -x  execute access    -e  existence\n# -f  plain file     -d  directory       -l  symbolic link     -p  named pipe\n# -S  socket file\n# -o  ownership      -z  zero size       -s  non-zero size\n# -u  SUID is set    -g  SGID is set     -k  sticky is set\n# -b  block device   -c  char device\n# -t  file (digit) is an open file descriptor for a terminal device\n\n# if the file `README' exists, displays a message\nif ( -e README ) echo \"I have already README file\"\n\n# if the `less' program is installed, use this instead of `more'\nif ( -e `where less` ) then\n\talias more 'less'\nendif\n\n#### Non-boolean operators\n# -Z  returns the file size in bytes\n# -M  returns the modification time (mtime)    -M: returns mtime string\n# -A  returns the lass access time (atime)     -A: returns atime string\n# -U  returns the owners user ID               -U: returns the owners user-name\n# -G  returns the group ID                     -G: returns the group-name\n# -P  returns the permissions as octal number  -Pmode returns perm. AND mode\n\n# this will display the date as Unix-time integer: 1498511486\nfiletest -M README.md\n\n# This will display \"Tue Jun 27 00:11:26 2017\"\nfiletest -M: README.md\n\n# --- Basic Commands ----------------------------------------------------------\n\n# Navigate though file system with `chdir' (cd)\ncd path # change working directory\ncd      # change to home directory\ncd -    # change to previous directory\ncd ..   # go up one directory\n\n# Examples:\ncd ~/Downloads # go to my `Downloads' directory\n\n# Use `mkdir` to create new directories.\nmkdir newdir\n# The `-p` flag causes new intermediate directories to be created as necessary.\nmkdir -p ~/.backup/saves\n\n# which & where\n# find if csh points to tcsh\nls -lha `which csh`\n# find if csh is installed on more than one directory\nwhere csh\n\n# --- Pipe-lines --------------------------------------------------------------\n# A pipeline is a sequence of processes chained together by their standard\n# streams, so that the output of each process (stdout) feeds directly as input\n# (stdin) to the next one. This `pipes' are created with the `|' special\n# character and it is one of the most powerful characteristics of Unix.\n\n# example:\nls -l | grep key | less\n# \"ls -l\" produces a process, the output (stdout) of which is piped to the\n# input (stdin) of the process for \"grep key\"; and likewise for the process\n# for \"less\".\n\n# the `ls', the `grep' and the `less' are programs of Unix and they have their\n# own man-page. The `pipe' mechanism is part of the kernel but the syntax\n# and the control is job of the shell, the tcsh in our case.\n\n# NOTE: `pipe' mechanism has Windows too, but it is buggy and I sign it for all\n# versions until Windows XP SP3 API32 which was the last one that I worked on.\n# Microsoft still denied it but is well known bug since it is a common method\n# for inter-process communication. For small I/O it will work well.\n# tcsh, along with grep, gcc and perl is one of the first Unix programs that\n# ported to DOS (with EMX DOS extender) and later to Windows (1998).\n\n# example: this will convert tcsh to PostScript and will show it with okular\nzcat /usr/man/man1/tcsh.1.gz | groff -Tps -man | okular -\n\n# a better version\nzcat `locate -b -n 1 '\\tcsh.1.gz'` | groff -Tps -man | okular -\n\n# even better\nset page = tcsh; set loc = (locate -b -n 1 \"\\\\\\\\\"${page}\".1.gz\");\n zcat `eval $loc` | groff -Tps -man | okular -\n\n# the same, modified to create man page pdf\nset page = tcsh; set loc = (locate -b -n 1 \"\\\\\\\\\"${page}\".1.gz\");\n zcat `eval $loc` | groff -Tps -man | ps2pdf - ${page}.pdf\n\n# the same, but now shows the ${page}.pdf too\nset page = tcsh; set loc = (locate -b -n 1 \"\\\\\\\\\"${page}\".1.gz\");\n zcat `eval $loc` | groff -Tps -man | ps2pdf - ${page}.pdf && okular tcsh.pdf\n\n# NOTE: `okular' is the default application of KDE environment and it shows\n# postcript and pdf files. You can replace it with your lovely pdf viewer.\n# zcat, locate, groff, are common programs in all Unices. `ps2pdf' program\n# is part of `ghostscript' package that is widely used.\n\n# --- Control Flow ------------------------------------------------------------\n\n#### IF-THEN-ELSE-ENDIF\n# Syntax:\n# if ( expr ) then\n#    ...\n# [else if ( expr2 ) then\n#    ...]\n# [else\n#    ...]\n# endif\n#\n# If the specified expr is true then the commands to the first else are\n# executed; otherwise if expr2 is true then the commands to the second else\n# are executed, etc.\n# Any number of else-if pairs are possible; only one endif is needed.\n#\n# Single-line form:\n#\n# if ( expr ) command\n#\n# If `expr' evaluates true, then command is executed.\n# `command' must be a simple command, not an alias, a pipeline, a command list\n# or a parenthesized command list. With few words, avoid to use it.\n#\n# BUG: Input/output redirection occurs even if expr is false and command is\n# thus not executed.\n#\n\n# check if we are in non-interactive shell and quit if true\nif ( $?USER == 0 || $?prompt == 0 ) exit\n\n# check if we are a login shell\nif ( $?loginsh ) then\n\t# check if you are on linux console (not X's terminal)\n\tif ( $tty =~ tty* ) then\n\t\t# enable keypad application keys (man console_codes)\n\t\techo '\\033='\n\tendif\nendif\n\n#### SWITCH-ENDSW\n# Syntax:\n# switch ( expr )\n# case pattern:\n#     ...\n#     [breaksw]\n# [default:\n#     ...]\n# endsw\n#\n# tcsh uses a case statement that works similarly to switch in C.\n# Each case label is successively matched, against the specified string which\n# is first command and filename  expanded. The file  metacharacters `*', `?'\n# and `[...]' may be used in the case labels. If none of the labels match the\n# execution begins after the default label if its defined.\n# The command `breaksw' causes execution to continue after the endsw. Otherwise\n# control may fall through case labels and default labels as in C.\n\nswitch ( $var )\ncase *.[1-9]:\ncase *.[1-9].gz:\n\techo \"$var is a man-page.\"\n\tbreaksw\ncase *gz:\n\techo \"$var is gzipped\"\n\tbreaksw\ndefault:\n\tfile $var\nendsw\n\n#### FOREACH-END\n# Syntax:\n# foreach name ( wordlist )\n#\t...\n#   [break | continue]\n# end\n#\n# Successively sets the variable `name' to each member of `wordlist' and\n# executes the sequence of commands between this command and the matching\n# `end' keyword. The `continue' keyword jump to the next element back to\n# top; and the `break' keyword terminates the loop.\n#\n# BUG: `foreach' doesn't ignore here documents when looking for its end.\n\n# example: counting 1 to 10\nforeach i ( `seq 1 10` )\n    echo $i\nend\n\n# example: type all files in the list\nforeach f ( a.txt b.txt c.txt )\n\tcat $f\nend\n\n# example: convert wma to ogg\nforeach f ( *.wma )\n\tffmpeg -i \"$f\" \"$f:r\".ogg\nend\n\n#### WHILE-END\n# while ( expr )\n#     ...\n#     [break | continue]\n# end\n#\n# Executes the commands between the `while' and the matching `end' while `expr'\n# evaluates non-zero. `break' and `continue' may be used to terminate or\n# continue the loop prematurely.\n\n# count from 1 to 10\nset num = 1\nwhile ( $num <= 10 )\n\techo $num\n\t@ num ++\nend\n\n# print all directories of CWD\nset lst = ( * )\nwhile ( $#lst )\n\tif ( -d $lst[1] ) echo $lst[1] is directory\n\tshift lst\nend\n\n# separate command-line arguments to options or parameters\nset options\nset params\nset lst = ( $* )\nwhile ( $#lst )\n\tif ( \"$lst[1]\" =~ '-*' ) then\n\t\tset options = ( $options $lst[1] )\n\telse\n\t\tset params = ( $params $lst[1] )\n\tendif\n\tshift lst\nend\necho 'options =' $options\necho 'parameters =' $params\n\n#### REPEAT\n# Syntax: repeat count command\n#\n# The specified command, which is subject to the same restrictions as the\n# command in the one line if statement above, is executed count times.\n# I/O redirections occur exactly once, even if count is 0.\n#\n# TIP: in most cases prefer `while'\n\nrepeat 3 echo \"ding dong\"\n\n# --- Functions ---------------------------------------------------------------\n# tcsh has no functions but its expression syntax is advanced enough to use\n# `alias' as functions. Another method is recursion\n\n# Alias argument selectors; the ability to define an alias to take arguments\n# supplied to it and apply them to the commands that it refers to.\n# Tcsh is the only shell that provides this feature.\n#\n# \\!#   argument selector for all arguments, including the alias/command\n#       itself; arguments need not be supplied.\n# \\!*   argument selector for all arguments, excluding the alias/command;\n#       arguments need not be supplied.\n# \\!$   argument selector for the last argument; argument need not be supplied,\n#       but if none is supplied, the alias name is considered to be the\n#       last argument.\n# \\!^   argument selector for first argument; argument MUST be supplied.\n# \\!:n  argument selector for the nth argument; argument MUST be supplied;\n#       n=0 refers to the alias/command name.\n# \\!:m-n   argument selector for the arguments from the mth to the nth;\n#       arguments MUST be supplied.\n# \\!:n-$   argument selector for the arguments from the nth to the last;\n#       at least argument n MUST be supplied.\n\n# Alias the cd command so that when you change directories, the contents\n# are immediately displayed.\nalias cd 'cd \\!* && ls'\n\n# --- Recursion method --- begin ---\n#!/bin/tcsh -f\nset todo = option1\nif ( $#argv > 0 ) then\n\tset todo = $argv[1]\nendif\n\nswitch ( $todo )\ncase option1:\n#\t...\n\t$0 results\n\tbreaksw\ncase option2:\n#\t...\n\t$0 results\n\tbreaksw\ncase results:\n\techo \"print the results here\"\n#\t...\n\tbreaksw\ndefault:\n\techo \"Unknown option: $todo\"\n#\texit 0\nendsw\n# --- Recursion method --- end ---\n\n# --- examples ----------------------------------------------------------------\n\n# this script prints available power-states if no argument is set;\n# otherwise it set the state of the $argv[1]\n# --- power-state script --- begin --------------------------------------------\n#!/bin/tcsh -f\n# get parameter (\"help\" for none)\nset todo = help\nif ( $#argv > 0 ) then\n\tset todo = $argv[1]\nendif\n# available options\nset opts = `cat /sys/power/state`\n# is known?\nforeach o ( $opts )\n\tif ( $todo == $o ) then\n\t\t# found; execute it\n\t\techo -n $todo > /sys/power/state\n\t\tbreak\n\tendif\nend\n# print help and exit\necho \"usage: $0 [option]\"\necho \"available options on kernel: $opts\"\n# --- power-state script --- end ----------------------------------------------\n\n# Guess the secret number game\n# --- secretnum.csh --- begin -------------------------------------------------\n#!/bin/tcsh -f\nset secret=`shuf -i1-100 -n1`\necho \"I have a secret number from 1 up to 100\"\nwhile ( 1 )\n\techo -n \"Guess: \"\n\tset guess = $<\n\tif ( $secret == $guess ) then\n\t\techo \"You found it\"\n\t\texit 1\n\telse\n\t\tif ( $secret > $guess ) then\n\t\t\techo \"its greater\"\n\t\telse if ( $secret < $guess ) then\n\t\t\t\techo \"its lesser\"\n\t\t\tendif\n\t\tendif\n\tendif\nend\n# --- secretnum.csh --- end ---------------------------------------------------\n\n# -----------------------------------------------------------------------------\n# Appendices\n\n#### About [T]CSH:\n# * CSH is notorious about its bugs;\n# * It was also famous about its advanced interactive mode.\n# * TCSH is famous that have the most advanced completition subsystem.\n# * TCSH is famous that have the most advanced aliases subsystem; aliases\n#   can take parameters and often used as functions!\n# * TCSH is well known that preferred by people  (me too) because of better\n#   syntax. All shells are using Thomson's syntax with exception of [t]csh,\n#   fish and plan9's shells (rc, ex).\n# * It is smaller and consume far less memory than bash, zsh even mksh!\n#   (memusage reports)\n# * TCSH still has bugs; less but have; if you write readable clean code you'll\n#   find none; well almost none... This has to do with the implementation of\n#   csh; that no means the other shells has good implementation.\n# * no one well known shell is capable for regular programming; if your script\n#   getting big, use a programming language, or at least PHP or Perl (good\n#   script languages).\n#\n# Advises:\n# 1. Do not use redirection in single-line if (it is well documented bug)\n#    In most cases avoid to use single-line IFs.\n# 2. Do not mess up with other shells code, c-shell is not compatible with\n#    other shells and has different abilities and priorities.\n# 3. Use spaces as you'll use them to write readable code in any language.\n#    A bug of csh was `set x=1' worked, `set x = 1' worked, `set x =1' did not!\n# 4. It is well documented that numeric expressions require spaces in-between;\n#    also parenthesise all bit-wise and unary operators.\n# 5. Do not write a huge weird expression with several quotes, backslashes etc\n#    It is bad practice for generic programming, it is dangerous in any shell.\n# 6. Help tcsh, report the bug here <https://bugs.gw.com/>\n# 7. Read the man page, `tcsh' has huge number of options, and variables.\n#\n#    I suggest the following options enabled by default\n#    --------------------------------------------------\n# Even in non-interactive shells\n#    set echo_style=both\n#    set backslash_quote\n#    set parseoctal\n#    unset noclobber\n#\n# Whatever...\n#    set inputmode=insert\n#    set autolist\n#    set listjobs\n#    set padhour\n#    set color\n#    set colorcat\n#    set nobeep\n#    set cdtohome\n#\n#    set histdup\n#    set histlit\n#    set nohistclop\n#\n#    unset compat_expr\n#    unset noglob\n#    unset autologout\n#    unset time\n#    unset tperiod\n#\n# NOTE: If the `backslash_quote' is set, it may create compatibility issues\n# with other tcsh scripts which was written without it.\n#\n# NOTE: The same for `parseoctal', but it is better to fix the problematic\n# scripts.\n#\n# NOTE: **for beginners only**\n# This enable automatically rescan `path' directories if need to. (like bash)\n#    set autorehash\n\n#### common aliases\n#    alias hist  'history 20'\n#    alias ll    'ls --color -lha'\n#    alias today \"date '+%d%h%y'\n#    alias ff    'find . -name '\n\n#### a nice prompt\n#    set prompt = \"%B%{\\033[35m%}%t %{\\033[32m%}%n@%m%b %C4 %# \"\n```"
