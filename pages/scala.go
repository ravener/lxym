
package pages

const Scala = "Scala - the scalable language\n\n```scala\n\n/////////////////////////////////////////////////\n// 0. Basics\n/////////////////////////////////////////////////\n/*\n  Setup Scala:\n\n  1) Download Scala - http://www.scala-lang.org/downloads\n  2) Unzip/untar to your favorite location and put the bin subdir in your `PATH` environment variable\n*/\n\n/*\n  Try the REPL\n\n  Scala has a tool called the REPL (Read-Eval-Print Loop) that is analogous to\n  commandline interpreters in many other languages. You may type any Scala\n  expression, and the result will be evaluated and printed.  \n\n  The REPL is a very handy tool to test and verify code.  Use it as you read\n  this tutorial to quickly explore concepts on your own.\n*/\n\n// Start a Scala REPL by running `scala`. You should see the prompt:\n$ scala\nscala>\n\n// By default each expression you type is saved as a new numbered value\nscala> 2 + 2\nres0: Int = 4\n\n// Default values can be reused.  Note the value type displayed in the result..\nscala> res0 + 2\nres1: Int = 6\n\n// Scala is a strongly typed language. You can use the REPL to check the type\n// without evaluating an expression.\nscala> :type (true, 2.0)\n(Boolean, Double)\n\n// REPL sessions can be saved\nscala> :save /sites/repl-test.scala\n\n// Files can be loaded into the REPL\nscala> :load /sites/repl-test.scala\nLoading /sites/repl-test.scala...\nres2: Int = 4\nres3: Int = 6\n\n// You can search your recent history\nscala> :h?\n1 2 + 2\n2 res0 + 2\n3 :save /sites/repl-test.scala\n4 :load /sites/repl-test.scala\n5 :h?\n\n// Now that you know how to play, let's learn a little scala...\n\n/////////////////////////////////////////////////\n// 1. Basics\n/////////////////////////////////////////////////\n\n// Single-line comments start with two forward slashes\n\n/*\n  Multi-line comments, as you can already see from above, look like this.\n*/\n\n// Printing, and forcing a new line on the next print\nprintln(\"Hello world!\")\nprintln(10)\n// Hello world!\n// 10\n\n// Printing, without forcing a new line on next print\nprint(\"Hello world\")\nprint(10)\n// Hello world10\n\n// Declaring values is done using either var or val.\n// val declarations are immutable, whereas vars are mutable. Immutability is\n// a good thing.\nval x = 10 // x is now 10\nx = 20     // error: reassignment to val\nvar y = 10\ny = 20     // y is now 20\n\n/*\n  Scala is a statically typed language, yet note that in the above declarations,\n  we did not specify a type. This is due to a language feature called type\n  inference. In most cases, Scala compiler can guess what the type of a variable\n  is, so you don't have to type it every time. We can explicitly declare the\n  type of a variable like so:\n*/\nval z: Int = 10\nval a: Double = 1.0\n\n// Notice automatic conversion from Int to Double, result is 10.0, not 10\nval b: Double = 10\n\n// Boolean values\ntrue\nfalse\n\n// Boolean operations\n!true         // false\n!false        // true\ntrue == false // false\n10 > 5        // true\n\n// Math is as per usual\n1 + 1   // 2\n2 - 1   // 1\n5 * 3   // 15\n6 / 2   // 3\n6 / 4   // 1\n6.0 / 4 // 1.5\n6 / 4.0 // 1.5\n\n\n// Evaluating an expression in the REPL gives you the type and value of the result\n\n1 + 7\n\n/* The above line results in:\n\n  scala> 1 + 7\n  res29: Int = 8\n\n  This means the result of evaluating 1 + 7 is an object of type Int with a\n  value of 8\n\n  Note that \"res29\" is a sequentially generated variable name to store the\n  results of the expressions you typed, your output may differ.\n*/\n\n\"Scala strings are surrounded by double quotes\"\n'a' // A Scala Char\n// 'Single quote strings don't exist' <= This causes an error\n\n// Strings have the usual Java methods defined on them\n\"hello world\".length\n\"hello world\".substring(2, 6)\n\"hello world\".replace(\"C\", \"3\")\n\n// They also have some extra Scala methods. See also: scala.collection.immutable.StringOps\n\"hello world\".take(5)\n\"hello world\".drop(5)\n\n// String interpolation: notice the prefix \"s\"\nval n = 45\ns\"We have $n apples\" // => \"We have 45 apples\"\n\n// Expressions inside interpolated strings are also possible\nval a = Array(11, 9, 6)\ns\"My second daughter is ${a(0) - a(2)} years old.\"    // => \"My second daughter is 5 years old.\"\ns\"We have double the amount of ${n / 2.0} in apples.\" // => \"We have double the amount of 22.5 in apples.\"\ns\"Power of 2: ${math.pow(2, 2)}\"                      // => \"Power of 2: 4\"\n\n// Formatting with interpolated strings with the prefix \"f\"\nf\"Power of 5: ${math.pow(5, 2)}%1.0f\"         // \"Power of 5: 25\"\nf\"Square root of 122: ${math.sqrt(122)}%1.4f\" // \"Square root of 122: 11.0454\"\n\n// Raw strings, ignoring special characters.\nraw\"New line feed: \\n. Carriage return: \\r.\" // => \"New line feed: \\n. Carriage return: \\r.\"\n\n// Some characters need to be \"escaped\", e.g. a double quote inside a string:\n\"They stood outside the \\\"Rose and Crown\\\"\" // => \"They stood outside the \"Rose and Crown\"\"\n\n// Triple double-quotes let strings span multiple rows and contain quotes\nval html = \"\"\"<form id=\"daform\">\n                <p>Press belo', Joe</p>\n                <input type=\"submit\">\n              </form>\"\"\"\n\n\n/////////////////////////////////////////////////\n// 2. Functions\n/////////////////////////////////////////////////\n\n// Functions are defined like so:\n//\n//   def functionName(args...): ReturnType = { body... }\n//\n// If you come from more traditional languages, notice the omission of the\n// return keyword. In Scala, the last expression in the function block is the\n// return value.\ndef sumOfSquares(x: Int, y: Int): Int = {\n  val x2 = x * x\n  val y2 = y * y\n  x2 + y2\n}\n\n// The { } can be omitted if the function body is a single expression:\ndef sumOfSquaresShort(x: Int, y: Int): Int = x * x + y * y\n\n// Syntax for calling functions is familiar:\nsumOfSquares(3, 4)  // => 25\n\n// You can use parameters names to specify them in different order\ndef subtract(x: Int, y: Int): Int = x - y\n\nsubtract(10, 3)     // => 7\nsubtract(y=10, x=3) // => -7\n\n// In most cases (with recursive functions the most notable exception), function\n// return type can be omitted, and the same type inference we saw with variables\n// will work with function return values:\ndef sq(x: Int) = x * x  // Compiler can guess return type is Int\n\n// Functions can have default parameters:\ndef addWithDefault(x: Int, y: Int = 5) = x + y\naddWithDefault(1, 2) // => 3\naddWithDefault(1)    // => 6\n\n\n// Anonymous functions look like this:\n(x: Int) => x * x\n\n// Unlike defs, even the input type of anonymous functions can be omitted if the\n// context makes it clear. Notice the type \"Int => Int\" which means a function\n// that takes Int and returns Int.\nval sq: Int => Int = x => x * x\n\n// Anonymous functions can be called as usual:\nsq(10)   // => 100\n\n// If each argument in your anonymous function is\n// used only once, Scala gives you an even shorter way to define them. These\n// anonymous functions turn out to be extremely common, as will be obvious in\n// the data structure section.\nval addOne: Int => Int = _ + 1\nval weirdSum: (Int, Int) => Int = (_ * 2 + _ * 3)\n\naddOne(5)      // => 6\nweirdSum(2, 4) // => 16\n\n\n// The return keyword exists in Scala, but it only returns from the inner-most\n// def that surrounds it.\n// WARNING: Using return in Scala is error-prone and should be avoided.\n// It has no effect on anonymous functions. For example here you may expect foo(7) should return 17 but it returns 7:\ndef foo(x: Int): Int = {\n  val anonFunc: Int => Int = { z =>\n    if (z > 5)\n      return z // This line makes z the return value of foo!\n    else\n      z + 2    // This line is the return value of anonFunc\n  }\n  anonFunc(x) + 10  // This line is the return value of foo\n}\n\nfoo(7) // => 7\n\n/////////////////////////////////////////////////\n// 3. Flow Control\n/////////////////////////////////////////////////\n\n1 to 5\nval r = 1 to 5\nr.foreach(println)\n\nr foreach println\n// NB: Scala is quite lenient when it comes to dots and brackets - study the\n// rules separately. This helps write DSLs and APIs that read like English\n\n// Why doesn't `println` need any parameters here?\n// Stay tuned for first-class functions in the Functional Programming section below!\n(5 to 1 by -1) foreach (println)\n\n// A while loop\nvar i = 0\nwhile (i < 10) { println(\"i \" + i); i += 1 }\n\nwhile (i < 10) { println(\"i \" + i); i += 1 }   // Yes, again. What happened? Why?\n\ni    // Show the value of i. Note that while is a loop in the classical sense -\n     // it executes sequentially while changing the loop variable. while is very\n     // fast, but using the combinators and comprehensions above is easier\n     // to understand and parallelize\n\n// A do-while loop\ni = 0\ndo {\n  println(\"i is still less than 10\")\n  i += 1\n} while (i < 10)\n\n// Recursion is the idiomatic way of repeating an action in Scala (as in most\n// other functional languages).\n// Recursive functions need an explicit return type, the compiler can't infer it.\n// Here it's Unit, which is analagous to a `void` return type in Java\ndef showNumbersInRange(a: Int, b: Int): Unit = {\n  print(a)\n  if (a < b)\n    showNumbersInRange(a + 1, b)\n}\nshowNumbersInRange(1, 14)\n\n\n// Conditionals\n\nval x = 10\n\nif (x == 1) println(\"yeah\")\nif (x == 10) println(\"yeah\")\nif (x == 11) println(\"yeah\")\nif (x == 11) println(\"yeah\") else println(\"nay\")\n\nprintln(if (x == 10) \"yeah\" else \"nope\")\nval text = if (x == 10) \"yeah\" else \"nope\"\n\n\n/////////////////////////////////////////////////\n// 4. Data Structures\n/////////////////////////////////////////////////\n\nval a = Array(1, 2, 3, 5, 8, 13)\na(0)     // Int = 1\na(3)     // Int = 5\na(21)    // Throws an exception\n\nval m = Map(\"fork\" -> \"tenedor\", \"spoon\" -> \"cuchara\", \"knife\" -> \"cuchillo\")\nm(\"fork\")         // java.lang.String = tenedor\nm(\"spoon\")        // java.lang.String = cuchara\nm(\"bottle\")       // Throws an exception\n\nval safeM = m.withDefaultValue(\"no lo se\")\nsafeM(\"bottle\")   // java.lang.String = no lo se\n\nval s = Set(1, 3, 7)\ns(0)      // Boolean = false\ns(1)      // Boolean = true\n\n/* Look up the documentation of map here -\n * https://www.scala-lang.org/api/current/scala/collection/immutable/Map.html\n * and make sure you can read it\n */\n\n\n// Tuples\n\n(1, 2)\n\n(4, 3, 2)\n\n(1, 2, \"three\")\n\n(a, 2, \"three\")\n\n// Why have this?\nval divideInts = (x: Int, y: Int) => (x / y, x % y)\n\n// The function divideInts gives you the result and the remainder\ndivideInts(10, 3)    // (Int, Int) = (3,1)\n\n// To access the elements of a tuple, use _._n where n is the 1-based index of\n// the element\nval d = divideInts(10, 3)    // (Int, Int) = (3,1)\n\nd._1    // Int = 3\nd._2    // Int = 1\n\n// Alternatively you can do multiple-variable assignment to tuple, which is more\n// convenient and readable in many cases\nval (div, mod) = divideInts(10, 3)\n\ndiv     // Int = 3\nmod     // Int = 1\n\n\n/////////////////////////////////////////////////\n// 5. Object Oriented Programming\n/////////////////////////////////////////////////\n\n/*\n  Aside: Everything we've done so far in this tutorial has been simple\n  expressions (values, functions, etc). These expressions are fine to type into\n  the command-line interpreter for quick tests, but they cannot exist by\n  themselves in a Scala file. For example, you cannot have just \"val x = 5\" in\n  a Scala file. Instead, the only top-level constructs allowed in Scala are:\n\n  - objects\n  - classes\n  - case classes\n  - traits\n\n  And now we will explain what these are.\n*/\n\n// classes are similar to classes in other languages. Constructor arguments are\n// declared after the class name, and initialization is done in the class body.\nclass Dog(br: String) {\n  // Constructor code here\n  var breed: String = br\n\n  // Define a method called bark, returning a String\n  def bark = \"Woof, woof!\"\n\n  // Values and methods are assumed public. \"protected\" and \"private\" keywords\n  // are also available.\n  private def sleep(hours: Int) =\n    println(s\"I'm sleeping for $hours hours\")\n\n  // Abstract methods are simply methods with no body. If we uncomment the\n  // def line below, class Dog would need to be declared abstract like so:\n  //   abstract class Dog(...) { ... }\n  // def chaseAfter(what: String): String\n}\n\nval mydog = new Dog(\"greyhound\")\nprintln(mydog.breed) // => \"greyhound\"\nprintln(mydog.bark)  // => \"Woof, woof!\"\n\n\n// The \"object\" keyword creates a type AND a singleton instance of it. It is\n// common for Scala classes to have a \"companion object\", where the per-instance\n// behavior is captured in the classes themselves, but behavior related to all\n// instance of that class go in objects. The difference is similar to class\n// methods vs static methods in other languages. Note that objects and classes\n// can have the same name.\nobject Dog {\n  def allKnownBreeds = List(\"pitbull\", \"shepherd\", \"retriever\")\n  def createDog(breed: String) = new Dog(breed)\n}\n\n\n// Case classes are classes that have extra functionality built in. A common\n// question for Scala beginners is when to use classes and when to use case\n// classes. The line is quite fuzzy, but in general, classes tend to focus on\n// encapsulation, polymorphism, and behavior. The values in these classes tend\n// to be private, and only methods are exposed. The primary purpose of case\n// classes is to hold immutable data. They often have few methods, and the\n// methods rarely have side-effects.\ncase class Person(name: String, phoneNumber: String)\n\n// Create a new instance. Note cases classes don't need \"new\"\nval george = Person(\"George\", \"1234\")\nval kate = Person(\"Kate\", \"4567\")\n\n// With case classes, you get a few perks for free, like getters:\ngeorge.phoneNumber  // => \"1234\"\n\n// Per field equality (no need to override .equals)\nPerson(\"George\", \"1234\") == Person(\"Kate\", \"1236\")  // => false\n\n// Easy way to copy\n// otherGeorge == Person(\"George\", \"9876\")\nval otherGeorge = george.copy(phoneNumber = \"9876\")\n\n// And many others. Case classes also get pattern matching for free, see below.\n\n// Traits\n// Similar to Java interfaces, traits define an object type and method\n// signatures. Scala allows partial implementation of those methods.\n// Constructor parameters are not allowed. Traits can inherit from other\n// traits or classes without parameters.\n\ntrait Dog {\n\tdef breed: String\n\tdef color: String\n\tdef bark: Boolean = true\n\tdef bite: Boolean\n}\nclass SaintBernard extends Dog {\n\tval breed = \"Saint Bernard\"\n\tval color = \"brown\"\n\tdef bite = false\n}  \n\nscala> b  \nres0: SaintBernard = SaintBernard@3e57cd70  \nscala> b.breed  \nres1: String = Saint Bernard  \nscala> b.bark  \nres2: Boolean = true  \nscala> b.bite  \nres3: Boolean = false  \n\n// A trait can also be used as Mixin. The class \"extends\" the first trait,\n// but the keyword \"with\" can add additional traits.\n\ntrait Bark {\n\tdef bark: String = \"Woof\"\n}\ntrait Dog {\n\tdef breed: String\n\tdef color: String\n}\nclass SaintBernard extends Dog with Bark {\n\tval breed = \"Saint Bernard\"\n\tval color = \"brown\"\n}\n\nscala> val b = new SaintBernard\nb: SaintBernard = SaintBernard@7b69c6ba\nscala> b.bark\nres0: String = Woof\n\n\n/////////////////////////////////////////////////\n// 6. Pattern Matching\n/////////////////////////////////////////////////\n\n// Pattern matching is a powerful and commonly used feature in Scala. Here's how\n// you pattern match a case class. NB: Unlike other languages, Scala cases do\n// not need breaks, fall-through does not happen.\n\ndef matchPerson(person: Person): String = person match {\n  // Then you specify the patterns:\n  case Person(\"George\", number) => \"We found George! His number is \" + number\n  case Person(\"Kate\", number)   => \"We found Kate! Her number is \" + number\n  case Person(name, number)     => \"We matched someone : \" + name + \", phone : \" + number\n}\n\n// Regular expressions are also built in.\n// Create a regex with the `r` method on a string:\nval email = \"(.*)@(.*)\".r\n\n// Pattern matching might look familiar to the switch statements in the C family\n// of languages, but this is much more powerful. In Scala, you can match much\n// more:\ndef matchEverything(obj: Any): String = obj match {\n  // You can match values:\n  case \"Hello world\" => \"Got the string Hello world\"\n\n  // You can match by type:\n  case x: Double => \"Got a Double: \" + x\n\n  // You can specify conditions:\n  case x: Int if x > 10000 => \"Got a pretty big number!\"\n\n  // You can match case classes as before:\n  case Person(name, number) => s\"Got contact info for $name!\"\n\n  // You can match regular expressions:\n  case email(name, domain) => s\"Got email address $name@$domain\"\n\n  // You can match tuples:\n  case (a: Int, b: Double, c: String) => s\"Got a tuple: $a, $b, $c\"\n\n  // You can match data structures:\n  case List(1, b, c) => s\"Got a list with three elements and starts with 1: 1, $b, $c\"\n\n  // You can nest patterns:\n  case List(List((1, 2, \"YAY\"))) => \"Got a list of list of tuple\"\n\n  // Match any case (default) if all previous haven't matched\n  case _ => \"Got unknown object\"\n}\n\n// In fact, you can pattern match any object with an \"unapply\" method. This\n// feature is so powerful that Scala lets you define whole functions as\n// patterns:\nval patternFunc: Person => String = {\n  case Person(\"George\", number) => s\"George's number: $number\"\n  case Person(name, number) => s\"Random person's number: $number\"\n}\n\n\n/////////////////////////////////////////////////\n// 7. Functional Programming\n/////////////////////////////////////////////////\n\n// Scala allows methods and functions to return, or take as parameters, other\n// functions or methods.\n\nval add10: Int => Int = _ + 10 // A function taking an Int and returning an Int\nList(1, 2, 3) map add10 // List(11, 12, 13) - add10 is applied to each element\n\n// Anonymous functions can be used instead of named functions:\nList(1, 2, 3) map (x => x + 10)\n\n// And the underscore symbol, can be used if there is just one argument to the\n// anonymous function. It gets bound as the variable\nList(1, 2, 3) map (_ + 10)\n\n// If the anonymous block AND the function you are applying both take one\n// argument, you can even omit the underscore\nList(\"Dom\", \"Bob\", \"Natalia\") foreach println\n\n\n// Combinators\n// Using `s` from above:\n// val s = Set(1, 3, 7)\n\ns.map(sq)\n\nval sSquared = s. map(sq)\n\nsSquared.filter(_ < 10)\n\nsSquared.reduce (_+_)\n\n// The filter function takes a predicate (a function from A -> Boolean) and\n// selects all elements which satisfy the predicate\nList(1, 2, 3) filter (_ > 2) // List(3)\ncase class Person(name: String, age: Int)\nList(\n  Person(name = \"Dom\", age = 23),\n  Person(name = \"Bob\", age = 30)\n).filter(_.age > 25) // List(Person(\"Bob\", 30))\n\n\n// Certain collections (such as List) in Scala have a `foreach` method,\n// which takes as an argument a type returning Unit - that is, a void method\nval aListOfNumbers = List(1, 2, 3, 4, 10, 20, 100)\naListOfNumbers foreach (x => println(x))\naListOfNumbers foreach println\n\n// For comprehensions\n\nfor { n <- s } yield sq(n)\n\nval nSquared2 = for { n <- s } yield sq(n)\n\nfor { n <- nSquared2 if n < 10 } yield n\n\nfor { n <- s; nSquared = n * n if nSquared < 10} yield nSquared\n\n/* NB Those were not for loops. The semantics of a for loop is 'repeat', whereas\n   a for-comprehension defines a relationship between two sets of data. */\n\n\n/////////////////////////////////////////////////\n// 8. Implicits\n/////////////////////////////////////////////////\n\n/* WARNING WARNING: Implicits are a set of powerful features of Scala, and\n * therefore it is easy to abuse them. Beginners to Scala should resist the\n * temptation to use them until they understand not only how they work, but also\n * best practices around them. We only include this section in the tutorial\n * because they are so commonplace in Scala libraries that it is impossible to\n * do anything meaningful without using a library that has implicits. This is\n * meant for you to understand and work with implicits, not declare your own.\n */\n\n// Any value (vals, functions, objects, etc) can be declared to be implicit by\n// using the, you guessed it, \"implicit\" keyword. Note we are using the Dog\n// class from section 5 in these examples.\nimplicit val myImplicitInt = 100\nimplicit def myImplicitFunction(breed: String) = new Dog(\"Golden \" + breed)\n\n// By itself, implicit keyword doesn't change the behavior of the value, so\n// above values can be used as usual.\nmyImplicitInt + 2                   // => 102\nmyImplicitFunction(\"Pitbull\").breed // => \"Golden Pitbull\"\n\n// The difference is that these values are now eligible to be used when another\n// piece of code \"needs\" an implicit value. One such situation is implicit\n// function arguments:\ndef sendGreetings(toWhom: String)(implicit howMany: Int) =\n  s\"Hello $toWhom, $howMany blessings to you and yours!\"\n\n// If we supply a value for \"howMany\", the function behaves as usual\nsendGreetings(\"John\")(1000)  // => \"Hello John, 1000 blessings to you and yours!\"\n\n// But if we omit the implicit parameter, an implicit value of the same type is\n// used, in this case, \"myImplicitInt\":\nsendGreetings(\"Jane\")  // => \"Hello Jane, 100 blessings to you and yours!\"\n\n// Implicit function parameters enable us to simulate type classes in other\n// functional languages. It is so often used that it gets its own shorthand. The\n// following two lines mean the same thing:\n// def foo[T](implicit c: C[T]) = ...\n// def foo[T : C] = ...\n\n\n// Another situation in which the compiler looks for an implicit is if you have\n//   obj.method(...)\n// but \"obj\" doesn't have \"method\" as a method. In this case, if there is an\n// implicit conversion of type A => B, where A is the type of obj, and B has a\n// method called \"method\", that conversion is applied. So having\n// myImplicitFunction above in scope, we can say:\n\"Retriever\".breed // => \"Golden Retriever\"\n\"Sheperd\".bark    // => \"Woof, woof!\"\n\n// Here the String is first converted to Dog using our function above, and then\n// the appropriate method is called. This is an extremely powerful feature, but\n// again, it is not to be used lightly. In fact, when you defined the implicit\n// function above, your compiler should have given you a warning, that you\n// shouldn't do this unless you really know what you're doing.\n\n\n/////////////////////////////////////////////////\n// 9. Misc\n/////////////////////////////////////////////////\n\n// Importing things\nimport scala.collection.immutable.List\n\n// Import all \"sub packages\"\nimport scala.collection.immutable._\n\n// Import multiple classes in one statement\nimport scala.collection.immutable.{List, Map}\n\n// Rename an import using '=>'\nimport scala.collection.immutable.{List => ImmutableList}\n\n// Import all classes, except some. The following excludes Map and Set:\nimport scala.collection.immutable.{Map => _, Set => _, _}\n\n// Java classes can also be imported. Scala syntax can be used\nimport java.swing.{JFrame, JWindow}\n\n// Your programs entry point is defined in a scala file using an object, with a\n// single method, main:\nobject Application {\n  def main(args: Array[String]): Unit = {\n    // stuff goes here.\n  }\n}\n\n// Files can contain multiple classes and objects. Compile with scalac\n\n\n\n\n// Input and output\n\n// To read a file line by line\nimport scala.io.Source\nfor(line <- Source.fromFile(\"myfile.txt\").getLines())\n  println(line)\n\n// To write a file use Java's PrintWriter\nval writer = new PrintWriter(\"myfile.txt\")\nwriter.write(\"Writing line for line\" + util.Properties.lineSeparator)\nwriter.write(\"Another line here\" + util.Properties.lineSeparator)\nwriter.close()\n\n```\n\n## Further resources\n\n* [Scala for the impatient](http://horstmann.com/scala/)\n* [Twitter Scala school](http://twitter.github.io/scala_school/)\n* [The scala documentation](http://docs.scala-lang.org/)\n* [Try Scala in your browser](http://scalatutorials.com/tour/)\n* Join the [Scala user group](https://groups.google.com/forum/#!forum/scala-user)"
