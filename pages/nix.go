
package pages

const Nix = "Nix is a simple functional language developed for the\n[Nix package manager](https://nixos.org/nix/) and\n[NixOS](https://nixos.org/).\n\nYou can evaluate Nix expressions using\n[nix-instantiate](https://nixos.org/nix/manual/#sec-nix-instantiate)\nor [`nix repl`](https://nixos.org/nix/manual/#ssec-relnotes-2.0).\n\n```\nwith builtins; [\n\n  #  Comments\n  #=========================================\n\n  # Inline comments look like this.\n\n  /* Multi-line comments\n     look like this. */\n\n\n  #  Booleans\n  #=========================================\n\n  (true && false)               # And\n  #=> false\n\n  (true || false)               # Or\n  #=> true\n\n  (if 3 < 4 then \"a\" else \"b\")  # Conditional\n  #=> \"a\"\n\n\n  #  Integers and Floats\n  #=========================================\n\n  # There are two numeric types: integers and floats\n\n  1 0 42 (-3)       # Some integers\n\n  123.43 .27e13     # A couple of floats\n\n  # Operations will preserve numeric type\n\n  (4 + 6 + 12 - 2)  # Addition\n  #=> 20\n  (4 - 2.5)\n  #=> 1.5\n\n  (7 / 2)           # Division\n  #=> 3\n  (7 / 2.0)\n  #=> 3.5\n\n\n  #  Strings\n  #=========================================\n\n  \"Strings literals are in double quotes.\"\n\n  \"\n    String literals can span\n    multiple lines.\n  \"\n\n  ''\n    This is called an \"indented string\" literal.\n    It intelligently strips leading whitespace.\n  ''\n\n  ''\n    a\n      b\n  ''\n  #=> \"a\\n  b\"\n\n  (\"ab\" + \"cd\")   # String concatenation\n  #=> \"abcd\"\n\n  # Antiquotation lets you embed values into strings.\n  (\"Your home directory is ${getEnv \"HOME\"}\")\n  #=> \"Your home directory is /home/alice\"\n\n\n  #  Paths\n  #=========================================\n\n  # Nix has a primitive data type for paths.\n  /tmp/tutorials/learn.nix\n\n  # A relative path is resolved to an absolute path at parse\n  # time, relative to the file in which it occurs.\n  tutorials/learn.nix\n  #=> /the-base-path/tutorials/learn.nix\n\n  # A path must contain at least one slash, so a relative\n  # path for a file in the same directory needs a ./ prefix,\n  ./learn.nix\n  #=> /the-base-path/learn.nix\n\n  # The / operator must be surrounded by whitespace if\n  # you want it to signify division.\n\n  7/2        # This is a path literal\n  (7 / 2)    # This is integer division\n\n\n  #  Imports\n  #=========================================\n\n  # A nix file contains a single top-level expression with no free\n  # variables. An import expression evaluates to the value of the\n  # file that it imports.\n  (import /tmp/foo.nix)\n\n  # Imports can also be specified by strings.\n  (import \"/tmp/foo.nix\")\n\n  # Import paths must be absolute. Path literals\n  # are automatically resolved, so this is fine.\n  (import ./foo.nix)\n\n  # But this does not happen with strings.\n  (import \"./foo.nix\")\n  #=> error: string ‘foo.nix’ doesn't represent an absolute path\n\n\n  #  Let\n  #=========================================\n\n  # `let` blocks allow us to bind values to variables.\n  (let x = \"a\"; in\n    x + x + x)\n  #=> \"aaa\"\n\n  # Bindings can refer to each other, and their order does not matter.\n  (let y = x + \"b\";\n       x = \"a\"; in\n    y + \"c\")\n  #=> \"abc\"\n\n  # Inner bindings shadow outer bindings.\n  (let a = 1; in\n    let a = 2; in\n      a)\n  #=> 2\n\n\n  #  Functions\n  #=========================================\n\n  (n: n + 1)      # Function that adds 1\n\n  ((n: n + 1) 5)  # That same function, applied to 5\n  #=> 6\n\n  # There is no syntax for named functions, but they\n  # can be bound by `let` blocks like any other value.\n  (let succ = (n: n + 1); in succ 5)\n  #=> 6\n\n  # A function has exactly one argument.\n  # Multiple arguments can be achieved with currying.\n  ((x: y: x + \"-\" + y) \"a\" \"b\")\n  #=> \"a-b\"\n\n  # We can also have named function arguments,\n  # which we'll get to later after we introduce sets.\n\n\n  #  Lists\n  #=========================================\n\n  # Lists are denoted by square brackets.\n\n  (length [1 2 3 \"x\"])\n  #=> 4\n\n  ([1 2 3] ++ [4 5])\n  #=> [1 2 3 4 5]\n\n  (concatLists [[1 2] [3 4] [5]])\n  #=> [1 2 3 4 5]\n\n  (head [1 2 3])\n  #=> 1\n  (tail [1 2 3])\n  #=> [2 3]\n\n  (elemAt [\"a\" \"b\" \"c\" \"d\"] 2)\n  #=> \"c\"\n\n  (elem 2 [1 2 3])\n  #=> true\n  (elem 5 [1 2 3])\n  #=> false\n\n  (filter (n: n < 3) [1 2 3 4])\n  #=> [ 1 2 ]\n\n\n  #  Sets\n  #=========================================\n\n  # A \"set\" is an unordered mapping with string keys.\n  { foo = [1 2]; bar = \"x\"; }\n\n  # The . operator pulls a value out of a set.\n  { a = 1; b = 2; }.a\n  #=> 1\n\n  # The ? operator tests whether a key is present in a set.\n  ({ a = 1; b = 2; } ? a)\n  #=> true\n  ({ a = 1; b = 2; } ? c)\n  #=> false\n\n  # The // operator merges two sets.\n  ({ a = 1; } // { b = 2; })\n  #=> { a = 1; b = 2; }\n\n  # Values on the right override values on the left.\n  ({ a = 1; b = 2; } // { a = 3; c = 4; })\n  #=> { a = 3; b = 2; c = 4; }\n\n  # The rec keyword denotes a \"recursive set\",\n  # in which attributes can refer to each other.\n  (let a = 1; in     { a = 2; b = a; }.b)\n  #=> 1\n  (let a = 1; in rec { a = 2; b = a; }.b)\n  #=> 2\n\n  # Nested sets can be defined in a piecewise fashion.\n  {\n    a.b   = 1;\n    a.c.d = 2;\n    a.c.e = 3;\n  }.a.c\n  #=> { d = 2; e = 3; }\n\n  # Sets are immutable, so you can't redefine an attribute:\n  {\n    a = { b = 1; };\n    a.b = 2;\n  }\n  #=> attribute 'a.b' at (string):3:5 already defined at (string):2:11\n\n  # However, an attribute's set members can also be defined piecewise\n  # way even if the attribute itself has been directly assigned.\n  {\n    a = { b = 1; };\n    a.c = 2;\n  }\n  #=> { a = { b = 1; c = 2; }; }\n\n\n  #  With\n  #=========================================\n\n  # The body of a `with` block is evaluated with\n  # a set's mappings bound to variables.\n  (with { a = 1; b = 2; };\n    a + b)\n  # => 3\n\n  # Inner bindings shadow outer bindings.\n  (with { a = 1; b = 2; };\n    (with { a = 5; };\n      a + b))\n  #=> 7\n\n  # This first line of tutorial starts with \"with builtins;\"\n  # because builtins is a set that contains all of the built-in\n  # functions (length, head, tail, filter, etc.). This saves\n  # us from having to write, for example, \"builtins.length\"\n  # instead of just \"length\".\n\n\n  #  Set patterns\n  #=========================================\n\n  # Sets are useful when we need to pass multiple values\n  # to a function.\n  (args: args.x + \"-\" + args.y) { x = \"a\"; y = \"b\"; }\n  #=> \"a-b\"\n\n  # This can be written more clearly using set patterns.\n  ({x, y}: x + \"-\" + y) { x = \"a\"; y = \"b\"; }\n  #=> \"a-b\"\n\n  # By default, the pattern fails on sets containing extra keys.\n  ({x, y}: x + \"-\" + y) { x = \"a\"; y = \"b\"; z = \"c\"; }\n  #=> error: anonymous function called with unexpected argument ‘z’\n\n  # Adding \", ...\" allows ignoring extra keys.\n  ({x, y, ...}: x + \"-\" + y) { x = \"a\"; y = \"b\"; z = \"c\"; }\n  #=> \"a-b\"\n\n\n  #  Errors\n  #=========================================\n\n  # `throw` causes evaluation to abort with an error message.\n  (2 + (throw \"foo\"))\n  #=> error: foo\n\n  # `tryEval` catches thrown errors.\n  (tryEval 42)\n  #=> { success = true; value = 42; }\n  (tryEval (2 + (throw \"foo\")))\n  #=> { success = false; value = false; }\n\n  # `abort` is like throw, but it's fatal; it cannot be caught.\n  (tryEval (abort \"foo\"))\n  #=> error: evaluation aborted with the following error message: ‘foo’\n\n  # `assert` evaluates to the given value if true;\n  # otherwise it throws a catchable exception.\n  (assert 1 < 2; 42)\n  #=> 42\n  (assert 1 > 2; 42)\n  #=> error: assertion failed at (string):1:1\n  (tryEval (assert 1 > 2; 42))\n  #=> { success = false; value = false; }\n\n\n  #  Impurity\n  #=========================================\n\n  # Because repeatability of builds is critical to the Nix package\n  # manager, functional purity is emphasized in the Nix language\n  # used to describe Nix packages. But there are a few impurities.\n\n  # You can refer to environment variables.\n  (getEnv \"HOME\")\n  #=> \"/home/alice\"\n\n  # The trace function is used for debugging. It prints the first\n  # argument to stderr and evaluates to the second argument.\n  (trace 1 2)\n  #=> trace: 1\n  #=> 2\n\n  # You can write files into the Nix store. Although impure, this is\n  # fairly safe because the file name is derived from the hash of\n  # its contents. You can read files from anywhere. In this example,\n  # we write a file into the store, and then read it back out.\n  (let filename = toFile \"foo.txt\" \"hello!\"; in\n    [filename (builtins.readFile filename)])\n  #=> [ \"/nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt\" \"hello!\" ]\n\n  # We can also download files into the Nix store.\n  (fetchurl \"https://example.com/package-1.2.3.tgz\")\n  #=> \"/nix/store/2drvlh8r57f19s9il42zg89rdr33m2rm-package-1.2.3.tgz\"\n\n]\n```\n\n### Further Reading\n\n* [Nix Manual - Nix expression language]\n  (https://nixos.org/nix/manual/#ch-expression-language)\n\n* [James Fisher - Nix by example - Part 1: The Nix expression language]\n  (https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55)\n\n* [Rommel Martinez - A Gentle Introduction to the Nix Family]\n  (https://ebzzry.io/en/nix/#nix)"
