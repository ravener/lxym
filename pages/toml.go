
package pages

const Toml = "TOML stands for Tom's Obvious, Minimal Language. It is a data serialisation language designed to be a minimal configuration file format that's easy to read due to obvious semantics.\n\nIt is an alternative to YAML and JSON. It aims to be more human friendly than JSON and simpler that YAML. TOML is designed to map unambiguously to a hash table. TOML should be easy to parse into data structures in a wide variety of languages.\n\nBe warned, TOML's spec is still changing a lot. Until it's marked as 1.0, you\nshould assume that it is unstable and act accordingly. This document follows TOML v0.4.0. \n\n```toml\n# Comments in TOML look like this.\n\n################\n# SCALAR TYPES #\n################\n\n# Our root object (which continues for the entire document) will be a map,\n# which is equivalent to a dictionary, hash or object in other languages.\n\n# The key, equals sign, and value must be on the same line\n# (though some values can be broken over multiple lines).\nkey = \"value\"\nstring = \"hello\"\nnumber = 42\nfloat = 3.14\nboolean = true\ndateTime = 1979-05-27T07:32:00-08:00\nscientificNotation = 1e+12\n\"key can be quoted\" = true # Both \" and ' are fine\n\"key may contain\" = \"letters, numbers, underscores, and dashes\"\n\n# A bare key must be non-empty, but an empty quoted key is allowed\n\"\" = \"blank\"     # VALID but discouraged\n'' = 'blank'     # VALID but discouraged\n\n##########\n# String #\n##########\n\n# All strings must contain only valid UTF-8 characters.\n# We can escape characters and some of them have a compact escape sequence.\n# For example, \\t add a tabulation. Refers to the spec to get all of them.\nbasicString = \"are surrounded by quotation marks. \\\"I'm quotable\\\". Name\\tJos\"\n\nmultiLineString = \"\"\"\nare surrounded by three quotation marks\non each side and allow newlines.\"\"\"\n\nliteralString = 'are surrounded by single quotes. Escaping are not allowed.'\n\nmultiLineLiteralString = '''\nare surrounded by three single quotes on each side\nand allow newlines. Still no escaping.\nThe first newline is trimmed in raw strings.\n   All other whitespace\n   is preserved. #! are preserved?\n'''\n\n# For binary data it is recommended that you use Base64, another ASCII or UTF8\n# encoding. The handling of that encoding will be application specific.\n\n###########\n# Integer #\n###########\n\n## Integers can start with a +, a - or nothing.\n## Leading zeros are not allowed. Hex, octal, and binary forms are not allowed.\n## Values that cannot be expressed as a series of digits are not allowed.\nint1 = +42\nint2 = 0\nint3 = -21\nintegerRange = 64\n\n## You can use underscores to enhance readability. Each\n## underscore must be surrounded by at least one digit.\nint4 = 5_349_221\nint5 = 1_2_3_4_5     # VALID but discouraged\n\n#########\n# Float #\n#########\n\n# Floats are an integer followed by a fractional and/or an exponent part.\nflt1 = 3.1415\nflt2 = -5e6\nflt3 = 6.626E-34\n\n###########\n# Boolean #\n###########\n\nbool1 = true\nbool2 = false\nboolMustBeLowercase = true\n\n############\n# Datetime #\n############\n\ndate1 = 1979-05-27T07:32:00Z # UTC time, following RFC 3339/ISO 8601 spec\ndate2 = 1979-05-26T15:32:00+08:00 # with RFC 3339/ISO 8601 offset\ndate3 = 1979-05-27T07:32:00 # without offset\ndate4 = 1979-05-27 # without offset or time\n\n####################\n# COLLECTION TYPES #\n####################\n\n#########\n# Array #\n#########\n\narray1 = [ 1, 2, 3 ]\narray2 = [ \"Commas\", \"are\", \"delimiters\" ]\narray3 = [ \"Don't mix\", \"different\", \"types\" ]\narray4 = [ [ 1.2, 2.4 ], [\"all\", 'strings', \"\"\"are the same\"\"\", '''type'''] ]\narray5 = [\n  \"Whitespace\", \"is\", \"ignored\"\n]\n\n#########\n# Table #\n#########\n\n# Tables (or hash tables or dictionaries) are collections of key/value\n# pairs. They appear in square brackets on a line by themselves.\n# Empty tables are allowed and simply have no key/value pairs within them.\n[table]\n\n# Under that, and until the next table or EOF are the key/values of that table.\n# Key/value pairs within tables are not guaranteed to be in any specific order.\n[table-1]\nkey1 = \"some string\"\nkey2 = 123\n\n[table-2]\nkey1 = \"another string\"\nkey2 = 456\n\n# Dots are prohibited in bare keys because dots are used to signify nested tables.\n# Naming rules for each dot separated part are the same as for keys.\n[dog.\"tater.man\"]\ntype = \"pug\"\n\n# In JSON land, that would give you the following structure:\n# { \"dog\": { \"tater.man\": { \"type\": \"pug\" } } }\n\n# Whitespace around dot-separated parts is ignored, however, best practice is to\n# not use any extraneous whitespace.\n[a.b.c]            # this is best practice\n[ d.e.f ]          # same as [d.e.f]\n[ j . \"ʞ\" . 'l' ]  # same as [j.\"ʞ\".'l']\n\n# You don't need to specify all the super-tables if you don't want to. TOML knows\n# how to do it for you.\n# [x] you\n# [x.y] don't\n# [x.y.z] need these\n[x.y.z.w] # for this to work\n\n# As long as a super-table hasn't been directly defined and hasn't defined a\n# specific key, you may still write to it.\n[a.b]\nc = 1\n\n[a]\nd = 2\n\n# Will generate the following in JSON:\n# { \"a\": {\"b\": {\"c\": 1}, \"d\": 2 } }\n\n# You cannot define any key or table more than once. Doing so is invalid.\n\n# DO NOT DO THIS\n[a]\nb = 1\n\n[a]\nc = 2\n\n# DO NOT DO THIS EITHER\n[a]\nb = 1\n\n[a.b]\nc = 2\n\n# All table names must be non-empty.\n[]     # INVALID\n[a.]   # INVALID\n[a..b] # INVALID\n[.b]   # INVALID\n[.]    # INVALID\n\n################\n# Inline table #\n################\n\ninlineTables = { areEnclosedWith = \"{ and }\", mustBeInline = true }\npoint = { x = 1, y = 2 }\n\n###################\n# Array of Tables #\n###################\n\n# An array of tables can be expressed by using a table name in double brackets.\n# Each table with the same double bracketed name will be an item in the array.\n# The tables are inserted in the order encountered.\n\n[[products]]\nname = \"array of table\"\nsku = 738594937\nemptyTableAreAllowed = true\n\n[[products]]\n\n[[products]]\nname = \"Nail\"\nsku = 284758393\ncolor = \"gray\"\n```\nThe equivalent in JSON would be:\n```json\n{ \n  \"products\": [\n    {\n      \"name\": \"array of table\",\n      \"sku\": 7385594937,\n      \"emptyTableAreAllowed\": true\n    },\n    {},\n    {\n      \"name\": \"Nail\",\n      \"sku\": 284758393,\n      \"color\": \"gray\"\n    }\n  ]\n}\n```\n\n```toml\n# You can create nested arrays of tables as well. Each double-bracketed\n# sub-table will belong to the nearest table element above it.\n\n[[fruit]]\n  name = \"apple\" # I am a property in fruit table/map\n\n  [fruit.geometry]\n    shape = \"round\"\n    note = \"I am a property in geometry table/map\"\n\n  [[fruit.color]]\n    name = \"red\"\n    note = \"I am an array item in apple fruit's table/map\"\n\n  [[fruit.color]]\n    name = \"green\"\n    note = \"I am in the same array as red\"\n\n[[fruit]]\n  name = \"banana\"\n\n  [[fruit.color]]\n    name = \"yellow\"\n    note = \"I am an array item in banana fruit's table/map\"\n\n```\nThe equivalent in JSON would be:\n```json\n\n{\n  \"fruit\": [\n    {\n      \"name\": \"apple\",\n      \"geometry\": { \"shape\": \"round\", \"note\": \"...\"},\n      \"color\": [\n        { \"name\": \"red\", \"note\": \"...\" },\n        { \"name\": \"green\", \"note\": \"...\" }\n      ]\n    },\n    {\n      \"name\": \"banana\",\n      \"color\": [\n        { \"name\": \"yellow\", \"note\": \"...\" }\n      ]\n    }\n  ]\n}\n```\n\n### More Resources\n\n+ [TOML official repository](https://github.com/toml-lang/toml)"
