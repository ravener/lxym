
package pages

const Mips = "The MIPS (Microprocessor without Interlocked Pipeline Stages) Assembly language\nis designed to work with the MIPS microprocessor paradigm designed by J. L. \nHennessy in 1981. These RISC processors are used in embedded systems such as \ngateways and routers.\n\n[Read More](https://en.wikipedia.org/wiki/MIPS_architecture)\n\n```asm\n# Comments are denoted with a '#'\n\n# Everything that occurs after a '#' will be ignored by the assembler's lexer.\n\n# Programs typically contain a .data and .text sections\n\n.data # Section where data is stored in memory (allocated in RAM), similar to\n      # variables in higher-level languages\n\n  # Declarations follow a ( label: .type value(s) ) form of declaration\n  hello_world: .asciiz \"Hello World\\n\"      # Declare a null terminated string\n  num1: .word 42                            # Integers are referred to as words\n                                            # (32-bit value)\n\n  arr1: .word 1, 2, 3, 4, 5                 # Array of words\n  arr2: .byte 'a', 'b'                      # Array of chars (1 byte each)\n  buffer: .space 60                         # Allocates space in the RAM \n                                            # (not cleared to 0)\n\n  # Datatype sizes\n  _byte: .byte 'a'                          # 1 byte\n  _halfword: .half 53                       # 2 bytes\n  _word: .word 3                            # 4 bytes\n  _float: .float 3.14                       # 4 bytes\n  _double: .double 7.0                      # 8 bytes\n\n  .align 2                                  # Memory alignment of data, where\n                                            # number indicates byte alignment\n                                            # in powers of 2. (.align 2\n                                            # represents word alignment since\n                                            # 2^2 = 4 bytes)\n\n.text                                       # Section that contains \n                                            # instructions and program logic\n.globl _main                                # Declares an instruction label as\n                                            # global, making it accessible to\n                                            # other files\n\n  _main:                                    # MIPS programs execute \n                                            # instructions sequentially, where \n                                            # the code under this label will be\n                                            # executed first\n\n    # Let's print \"hello world\"\n    la $a0, hello_world                     # Load address of string stored\n                                            # in memory\n    li $v0, 4                               # Load the syscall value (number\n                                            # indicating which syscall to make)\n    syscall                                 # Perform the specified syscall\n                                            # with the given argument ($a0)\n\n    # Registers (used to hold data during program execution)\n    # $t0 - $t9                             # Temporary registers used for \n                                            # intermediate calculations inside \n                                            # subroutines (not saved across \n                                            # function calls)\n\n    # $s0 - $s7                             # Saved registers where values are \n                                            # saved across subroutine calls. \n                                            # Typically saved in stack\n\n    # $a0 - $a3                             # Argument registers for passing in \n                                            # arguments for subroutines\n    # $v0 - $v1                             # Return registers for returning \n                                            # values to caller function\n\n    # Types of load/store instructions\n    la $t0, label                           # Copy the address of a value in\n                                            # memory specified by the label\n                                            # into register $t0\n    lw $t0, label                           # Copy a word value from memory\n    lw $t1, 4($s0)                          # Copy a word value from an address\n                                            # stored in a register with an\n                                            # offset of 4 bytes (addr + 4)\n    lb $t2, label                           # Copy a byte value to the \n                                            # lower order portion of \n                                            # the register $t2\n    lb $t2, 0($s0)                          # Copy a byte value from the source\n                                            # address in $s0 with offset 0\n    # Same idea with 'lh' for halfwords\n\n    sw $t0, label                           # Store word value into\n                                            # memory address mapped by label\n    sw $t0, 8($s0)                          # Store word value into address \n                                            # specified in $s0 and offset of\n                                            # 8 bytes\n    # Same idea using 'sb' and 'sh' for bytes and halfwords. 'sa' does not exist\n\n### Math ###\n  _math:\n    # Remember to load your values into a register\n    lw $t0, num                             # From the data section\n    li $t0, 5                               # Or from an immediate (constant)\n    li $t1, 6\n    add $t2, $t0, $t1                       # $t2 = $t0 + $t1\n    sub $t2, $t0, $t1                       # $t2 = $t0 - $t1\n    mul $t2, $t0, $t1                       # $t2 = $t0 * $t1\n    div $t2, $t0, $t1                       # $t2 = $t0 / $t1 (Might not be \n                                            # supported in some versons of MARS)\n    div $t0, $t1                            # Performs $t0 / $t1. Get the \n                                            # quotient using 'mflo' and \n                                            # remainder using 'mfhi'\n\n    # Bitwise Shifting\n    sll $t0, $t0, 2                         # Bitwise shift to the left with \n                                            # immediate (constant value) of 2\n    sllv $t0, $t1, $t2                      # Shift left by a variable amount\n                                            # in register\n    srl $t0, $t0, 5                         # Bitwise shift to the right (does \n                                            # not sign preserve, sign-extends \n                                            # with 0)\n    srlv $t0, $t1, $t2                      # Shift right by a variable amount \n                                            # in a register\n    sra $t0, $t0, 7                         # Bitwise arithmetic shift to  \n                                            # the right (preserves sign)\n    srav $t0, $t1, $t2                      # Shift right by a variable amount \n                                            # in a register\n\n    # Bitwise operators\n    and $t0, $t1, $t2                       # Bitwise AND\n    andi $t0, $t1, 0xFFF                    # Bitwise AND with immediate\n    or $t0, $t1, $t2                        # Bitwise OR\n    ori $t0, $t1, 0xFFF                     # Bitwise OR with immediate\n    xor $t0, $t1, $t2                       # Bitwise XOR\n    xori $t0, $t1, 0xFFF                    # Bitwise XOR with immediate\n    nor $t0, $t1, $t2                       # Bitwise NOR\n\n## BRANCHING ##\n  _branching:\n    # The basic format of these branching instructions typically follow <instr>\n    # <reg1> <reg2> <label> where label is the label we want to jump to if the\n    # given conditional evaluates to true\n    # Sometimes it is easier to write the conditional logic backward, as seen\n    # in the simple if statement example below\n\n    beq $t0, $t1, reg_eq                    # Will branch to reg_eq if\n                                            # $t0 == $t1, otherwise\n                                            # execute the next line\n    bne $t0, $t1, reg_neq                   # Branches when $t0 != $t1\n    b branch_target                         # Unconditional branch, will \n                                            # always execute\n    beqz $t0, req_eq_zero                   # Branches when $t0 == 0\n    bnez $t0, req_neq_zero                  # Branches when $t0 != 0\n    bgt $t0, $t1, t0_gt_t1                  # Branches when $t0 > $t1\n    bge $t0, $t1, t0_gte_t1                 # Branches when $t0 >= $t1\n    bgtz $t0, t0_gt0                        # Branches when $t0 > 0\n    blt $t0, $t1, t0_gt_t1                  # Branches when $t0 < $t1\n    ble $t0, $t1, t0_gte_t1                 # Branches when $t0 <= $t1\n    bltz $t0, t0_lt0                        # Branches when $t0 < 0\n    slt $s0, $t0, $t1                       # Instruction that sends a signal \n                                            # when $t0 < $t1 with result in $s0 \n                                            # (1 for true)\n\n    # Simple if statement\n    # if (i == j)\n    #     f = g + h;\n    #  f = f - i;\n\n    # Let $s0 = f, $s1 = g, $s2 = h, $s3 = i, $s4 = j\n    bne $s3, $s4, L1 # if (i !=j)\n    add $s0, $s1, $s2 # f = g + h\n\n    L1:\n      sub $s0, $s0, $s3 # f = f - i\n    \n    # Below is an example of finding the max of 3 numbers\n    # A direct translation in Java from MIPS logic:\n    # if (a > b)\n    #   if (a > c)\n    #     max = a;\n    #   else\n    #     max = c;\n    # else\n    #     max = b;\n    #   else\n    #     max = c;\n\n    # Let $s0 = a, $s1 = b, $s2 = c, $v0 = return register\n    ble $s0, $s1, a_LTE_b                   # if(a <= b) branch(a_LTE_b)\n    ble $s0, $s2, max_C                     # if(a > b && a <=c) branch(max_C)\n    move $v0, $s1                           # else [a > b && a > c] max = a\n    j done                                  # Jump to the end of the program\n\n    a_LTE_b:                                # Label for when a <= b\n      ble $s1, $s2, max_C                   # if(a <= b && b <= c) branch(max_C)\n      move $v0, $s1                         # if(a <= b && b > c) max = b\n      j done                                # Jump to done\n\n    max_C:\n      move $v0, $s2                         # max = c\n\n    done:                                   # End of program\n\n## LOOPS ##\n  _loops:\n    # The basic structure of loops is having an exit condition and a jump \n    # instruction to continue its execution\n    li $t0, 0\n    while:\n      bgt $t0, 10, end_while                # While $t0 is less than 10, \n                                            # keep iterating\n      addi $t0, $t0, 1                      # Increment the value\n      j while                               # Jump back to the beginning of \n                                            # the loop\n    end_while:\n\n    # 2D Matrix Traversal\n    # Assume that $a0 stores the address of an integer matrix which is 3 x 3\n    li $t0, 0                               # Counter for i\n    li $t1, 0                               # Counter for j\n    matrix_row:\n      bgt $t0, 3, matrix_row_end\n\n      matrix_col:\n        bgt $t1, 3, matrix_col_end\n\n        # Do stuff\n\n        addi $t1, $t1, 1                  # Increment the col counter\n      matrix_col_end:\n\n      # Do stuff\n\n      addi $t0, $t0, 1\n    matrix_row_end:\n\n## FUNCTIONS ##\n  _functions:\n    # Functions are callable procedures that can accept arguments and return \n    values all denoted with labels, like above\n\n    main:                                 # Programs begin with main func\n      jal return_1                        # jal will store the current PC in $ra\n                                          # and then jump to return_1\n\n      # What if we want to pass in args?\n      # First we must pass in our parameters to the argument registers\n      li $a0, 1\n      li $a1, 2\n      jal sum                             # Now we can call the function\n\n      # How about recursion?\n      # This is a bit more work since we need to make sure we save and restore\n      # the previous PC in $ra since jal will automatically overwrite \n      # on each call\n      li $a0, 3\n      jal fact\n\n      li $v0, 10\n      syscall\n    \n    # This function returns 1\n    return_1:\n      li $v0, 1                           # Load val in return register $v0\n      jr $ra                              # Jump back to old PC to continue exec\n\n\n    # Function with 2 args\n    sum:\n      add $v0, $a0, $a1\n      jr $ra                              # Return\n\n    # Recursive function to find factorial\n    fact:\n      addi $sp, $sp, -8                   # Allocate space in stack\n      sw $s0, ($sp)                       # Store reg that holds current num\n      sw $ra, 4($sp)                      # Store previous PC\n\n      li $v0, 1                           # Init return value\n      beq $a0, 0, fact_done               # Finish if param is 0\n\n      # Otherwise, continue recursion\n      move $s0, $a0                       # Copy $a0 to $s0\n      sub $a0, $a0, 1\n      jal fact\n\n      mul $v0, $s0, $v0                   # Multiplication is done\n\n      fact_done:\n        lw $s0, ($sp)\n        lw $ra, ($sp)                     # Restore the PC\n        addi $sp, $sp, 8\n\n        jr $ra\n\n## MACROS ##\n  _macros:\n    # Macros are extremely useful for substituting repeated code blocks with a\n    # single label for better readability\n    # These are in no means substitutes for functions\n    # These must be declared before it is used\n\n    # Macro for printing newlines (since these can be very repetitive)\n    .macro println()\n      la $a0, newline                     # New line string stored here\n      li $v0, 4\n      syscall\n    .end_macro\n\n    println()                             # Assembler will copy that block of\n                                          # code here before running\n\n    # Parameters can be passed in through macros.\n    # These are denoted by a '%' sign with any name you choose\n    .macro print_int(%num)\n      li $v0, 1\n      lw $a0, %num\n      syscall\n    .end_macro\n    \n    li $t0, 1\n    print_int($t0)\n    \n    # We can also pass in immediates for macros\n    .macro immediates(%a, %b)\n      add $t0, %a, %b\n    .end_macro\n\n    immediates(3, 5)\n\n    # Along with passing in labels\n    .macro print(%string)\n      la $a0, %string\n      li $v0, 4\n      syscall\n    .end_macro\n\n    print(hello_world)\n\n## ARRAYS ##\n.data\n  list: .word 3, 0, 1, 2, 6                 # This is an array of words\n  char_arr: .asciiz \"hello\"                 # This is a char array\n  buffer: .space 128                        # Allocates a block in memory, does\n                                            # not automatically clear\n                                            # These blocks of memory are aligned\n                                            # next to each other\n\n.text\n  la $s0, list                              # Load address of list\n  li $t0, 0                                 # Counter\n  li $t1, 5                                 # Length of the list\n\n  loop:\n    bgt $t0, $t1, end_loop\n\n    lw $a0, ($s0)\n    li $v0, 1\n    syscall                                 # Print the number\n\n    addi $s0, $s0, 4                        # Size of a word is 4 bytes\n    addi $t0, $t0, 1                        # Increment\n    j loop\n  end_loop:\n\n## INCLUDE ##\n# You do this to import external files into your program (behind the scenes, \n# it really just takes whatever code that is in that file and places it where\n# the include statement is)\n.include \"somefile.asm\"\n\n```"
