
package pages

const Bash = "Bash is a name of the unix shell, which was also distributed as the shell\nfor the GNU operating system and as the default shell on most Linux distros.\nNearly all examples below can be a part of a shell script\nor executed directly in the shell.\n\n[Read more here.](https://www.gnu.org/software/bash/manual/bashref.html)\n\n```bash\n#!/usr/bin/env bash\n# First line of the script is the shebang which tells the system how to execute\n# the script: https://en.wikipedia.org/wiki/Shebang_(Unix)\n# As you already figured, comments start with #. Shebang is also a comment.\n\n# Simple hello world example:\necho Hello world! # => Hello world!\n\n# Each command starts on a new line, or after a semicolon:\necho 'This is the first line'; echo 'This is the second line'\n# => This is the first line\n# => This is the second line\n\n# Declaring a variable looks like this:\nVariable=\"Some string\"\n\n# But not like this:\nVariable = \"Some string\" # => returns error \"Variable: command not found\"\n# Bash will decide that Variable is a command it must execute and give an error\n# because it can't be found.\n\n# Nor like this:\nVariable= 'Some string' # => returns error: \"Some string: command not found\"\n# Bash will decide that 'Some string' is a command it must execute and give an\n# error because it can't be found. (In this case the 'Variable=' part is seen\n# as a variable assignment valid only for the scope of the 'Some string'\n# command.)\n\n# Using the variable:\necho $Variable # => Some string\necho \"$Variable\" # => Some string\necho '$Variable' # => $Variable\n# When you use the variable itself — assign it, export it, or else — you write\n# its name without $. If you want to use the variable's value, you should use $.\n# Note that ' (single quote) won't expand the variables!\n\n# Parameter expansion ${ }:\necho ${Variable} # => Some string\n# This is a simple usage of parameter expansion\n# Parameter Expansion gets a value from a variable.\n# It \"expands\" or prints the value\n# During the expansion time the value or parameter can be modified\n# Below are other modifications that add onto this expansion\n\n# String substitution in variables\necho ${Variable/Some/A} # => A string\n# This will substitute the first occurrence of \"Some\" with \"A\"\n\n# Substring from a variable\nLength=7\necho ${Variable:0:Length} # => Some st\n# This will return only the first 7 characters of the value\necho ${Variable: -5} # => tring\n# This will return the last 5 characters (note the space before -5)\n\n# String length\necho ${#Variable} # => 11\n\n# Indirect expansion\nOtherVariable=\"Variable\"\necho ${!OtherVariable} # => Some String\n# This will expand the value of OtherVariable\n\n# Default value for variable\necho ${Foo:-\"DefaultValueIfFooIsMissingOrEmpty\"}\n# => DefaultValueIfFooIsMissingOrEmpty\n# This works for null (Foo=) and empty string (Foo=\"\"); zero (Foo=0) returns 0.\n# Note that it only returns default value and doesn't change variable value.\n\n# Declare an array with 6 elements\narray0=(one two three four five six)\n# Print first element\necho $array0 # => \"one\"\n# Print first element\necho ${array0[0]} # => \"one\"\n# Print all elements\necho ${array0[@]} # => \"one two three four five six\"\n# Print number of elements\necho ${#array0[@]} # => \"6\"\n# Print number of characters in third element\necho ${#array0[2]} # => \"5\"\n# Print 2 elements starting from forth\necho ${array0[@]:3:2} # => \"four five\"\n# Print all elements. Each of them on new line.\nfor i in \"${array0[@]}\"; do\n    echo \"$i\"\ndone\n\n# Brace Expansion { }\n# Used to generate arbitrary strings\necho {1..10} # => 1 2 3 4 5 6 7 8 9 10\necho {a..z} # => a b c d e f g h i j k l m n o p q r s t u v w x y z\n# This will output the range from the start value to the end value\n\n# Built-in variables:\n# There are some useful built-in variables, like\necho \"Last program's return value: $?\"\necho \"Script's PID: $$\"\necho \"Number of arguments passed to script: $#\"\necho \"All arguments passed to script: $@\"\necho \"Script's arguments separated into different variables: $1 $2...\"\n\n# Now that we know how to echo and use variables,\n# let's learn some of the other basics of bash!\n\n# Our current directory is available through the command `pwd`.\n# `pwd` stands for \"print working directory\".\n# We can also use the built-in variable `$PWD`.\n# Observe that the following are equivalent:\necho \"I'm in $(pwd)\" # execs `pwd` and interpolates output\necho \"I'm in $PWD\" # interpolates the variable\n\n# If you get too much output in your terminal, or from a script, the command\n# `clear` clears your screen\nclear\n# Ctrl-L also works for clearing output\n\n# Reading a value from input:\necho \"What's your name?\"\nread Name # Note that we didn't need to declare a new variable\necho Hello, $Name!\n\n# We have the usual if structure:\n# use `man test` for more info about conditionals\nif [ $Name != $USER ]\nthen\n    echo \"Your name isn't your username\"\nelse\n    echo \"Your name is your username\"\nfi\n# True if the value of $Name is not equal to the current user's login username\n\n# NOTE: if $Name is empty, bash sees the above condition as:\nif [ != $USER ]\n# which is invalid syntax\n# so the \"safe\" way to use potentially empty variables in bash is:\nif [ \"$Name\" != $USER ] ...\n# which, when $Name is empty, is seen by bash as:\nif [ \"\" != $USER ] ...\n# which works as expected\n\n# There is also conditional execution\necho \"Always executed\" || echo \"Only executed if first command fails\"\n# => Always executed\necho \"Always executed\" && echo \"Only executed if first command does NOT fail\"\n# => Always executed\n# => Only executed if first command does NOT fail\n\n\n# To use && and || with if statements, you need multiple pairs of square brackets:\nif [ \"$Name\" == \"Steve\" ] && [ \"$Age\" -eq 15 ]\nthen\n    echo \"This will run if $Name is Steve AND $Age is 15.\"\nfi\n\nif [ \"$Name\" == \"Daniya\" ] || [ \"$Name\" == \"Zach\" ]\nthen\n    echo \"This will run if $Name is Daniya OR Zach.\"\nfi\n\n# There is also the `=~` operator, which tests a string against a Regex pattern:\nEmail=me@example.com\nif [[ \"$Email\" =~ [a-z]+@[a-z]{2,}\\.(com|net|org) ]]\nthen\n    echo \"Valid email!\"\nfi\n# Note that =~ only works within double [[ ]] square brackets,\n# which are subtly different from single [ ].\n# See https://www.gnu.org/software/bash/manual/bashref.html#Conditional-Constructs for more on this.\n\n# Redefine command `ping` as alias to send only 5 packets\nalias ping='ping -c 5'\n# Escape the alias and use command with this name instead\n\\ping 192.168.1.1\n# Print all aliases\nalias -p\n\n# Expressions are denoted with the following format:\necho $(( 10 + 5 )) # => 15\n\n# Unlike other programming languages, bash is a shell so it works in the context\n# of a current directory. You can list files and directories in the current\n# directory with the ls command:\nls # Lists the files and subdirectories contained in the current directory\n\n# This command has options that control its execution:\nls -l # Lists every file and directory on a separate line\nls -t # Sorts the directory contents by last-modified date (descending)\nls -R # Recursively `ls` this directory and all of its subdirectories\n\n# Results of the previous command can be passed to the next command as input.\n# The `grep` command filters the input with provided patterns.\n# That's how we can list .txt files in the current directory:\nls -l | grep \"\\.txt\"\n\n# Use `cat` to print files to stdout:\ncat file.txt\n\n# We can also read the file using `cat`:\nContents=$(cat file.txt)\n# \"\\n\" prints a new line character\n# \"-e\" to interpret the newline escape characters as escape characters\necho -e \"START OF FILE\\n$Contents\\nEND OF FILE\"\n# => START OF FILE\n# => [contents of file.txt]\n# => END OF FILE\n\n# Use `cp` to copy files or directories from one place to another.\n# `cp` creates NEW versions of the sources,\n# so editing the copy won't affect the original (and vice versa).\n# Note that it will overwrite the destination if it already exists.\ncp srcFile.txt clone.txt\ncp -r srcDirectory/ dst/ # recursively copy\n\n# Look into `scp` or `sftp` if you plan on exchanging files between computers.\n# `scp` behaves very similarly to `cp`.\n# `sftp` is more interactive.\n\n# Use `mv` to move files or directories from one place to another.\n# `mv` is similar to `cp`, but it deletes the source.\n# `mv` is also useful for renaming files!\nmv s0urc3.txt dst.txt # sorry, l33t hackers...\n\n# Since bash works in the context of a current directory, you might want to\n# run your command in some other directory. We have cd for changing location:\ncd ~    # change to home directory\ncd      # also goes to home directory\ncd ..   # go up one directory\n        # (^^say, from /home/username/Downloads to /home/username)\ncd /home/username/Documents   # change to specified directory\ncd ~/Documents/..    # still in home directory..isn't it??\ncd -    # change to last directory\n# => /home/username/Documents\n\n# Use subshells to work across directories\n(echo \"First, I'm here: $PWD\") && (cd someDir; echo \"Then, I'm here: $PWD\")\npwd # still in first directory\n\n# Use `mkdir` to create new directories.\nmkdir myNewDir\n# The `-p` flag causes new intermediate directories to be created as necessary.\nmkdir -p myNewDir/with/intermediate/directories\n# if the intermediate directories didn't already exist, running the above\n# command without the `-p` flag would return an error\n\n# You can redirect command input and output (stdin, stdout, and stderr).\n# Read from stdin until ^EOF$ and overwrite hello.py with the lines\n# between \"EOF\":\ncat > hello.py << EOF\n#!/usr/bin/env python\nfrom __future__ import print_function\nimport sys\nprint(\"#stdout\", file=sys.stdout)\nprint(\"#stderr\", file=sys.stderr)\nfor line in sys.stdin:\n    print(line, file=sys.stdout)\nEOF\n# Variables will be expanded if the first \"EOF\" is not quoted\n\n# Run the hello.py Python script with various stdin, stdout, and\n# stderr redirections:\npython hello.py < \"input.in\" # pass input.in as input to the script\n\npython hello.py > \"output.out\" # redirect output from the script to output.out\n\npython hello.py 2> \"error.err\" # redirect error output to error.err\n\npython hello.py > \"output-and-error.log\" 2>&1\n# redirect both output and errors to output-and-error.log\n\npython hello.py > /dev/null 2>&1\n# redirect all output and errors to the black hole, /dev/null, i.e., no output\n\n# The output error will overwrite the file if it exists,\n# if you want to append instead, use \">>\":\npython hello.py >> \"output.out\" 2>> \"error.err\"\n\n# Overwrite output.out, append to error.err, and count lines:\ninfo bash 'Basic Shell Features' 'Redirections' > output.out 2>> error.err\nwc -l output.out error.err\n\n# Run a command and print its file descriptor (e.g. /dev/fd/123)\n# see: man fd\necho <(echo \"#helloworld\")\n\n# Overwrite output.out with \"#helloworld\":\ncat > output.out <(echo \"#helloworld\")\necho \"#helloworld\" > output.out\necho \"#helloworld\" | cat > output.out\necho \"#helloworld\" | tee output.out >/dev/null\n\n# Cleanup temporary files verbosely (add '-i' for interactive)\n# WARNING: `rm` commands cannot be undone\nrm -v output.out error.err output-and-error.log\nrm -r tempDir/ # recursively delete\n# You can install the `trash-cli` Python package to have `trash`\n# which puts files in the system trash and doesn't delete them directly\n# see https://pypi.org/project/trash-cli/ if you want to be careful\n\n# Commands can be substituted within other commands using $( ):\n# The following command displays the number of files and directories in the\n# current directory.\necho \"There are $(ls | wc -l) items here.\"\n\n# The same can be done using backticks `` but they can't be nested -\n# the preferred way is to use $( ).\necho \"There are `ls | wc -l` items here.\"\n\n# Bash uses a `case` statement that works similarly to switch in Java and C++:\ncase \"$Variable\" in\n    # List patterns for the conditions you want to meet\n    0) echo \"There is a zero.\";;\n    1) echo \"There is a one.\";;\n    *) echo \"It is not null.\";;  # match everything\nesac\n\n# `for` loops iterate for as many arguments given:\n# The contents of $Variable is printed three times.\nfor Variable in {1..3}\ndo\n    echo \"$Variable\"\ndone\n# => 1\n# => 2\n# => 3\n\n\n# Or write it the \"traditional for loop\" way:\nfor ((a=1; a <= 3; a++))\ndo\n    echo $a\ndone\n# => 1\n# => 2\n# => 3\n\n# They can also be used to act on files..\n# This will run the command `cat` on file1 and file2\nfor Variable in file1 file2\ndo\n    cat \"$Variable\"\ndone\n\n# ..or the output from a command\n# This will `cat` the output from `ls`.\nfor Output in $(ls)\ndo\n    cat \"$Output\"\ndone\n\n# Bash can also accept patterns, like this to `cat`\n# all the Markdown files in current directory\nfor Output in ./*.markdown\ndo\n    cat \"$Output\"\ndone\n\n# while loop:\nwhile [ true ]\ndo\n    echo \"loop body here...\"\n    break\ndone\n# => loop body here...\n\n# You can also define functions\n# Definition:\nfunction foo ()\n{\n    echo \"Arguments work just like script arguments: $@\"\n    echo \"And: $1 $2...\"\n    echo \"This is a function\"\n    return 0\n}\n# Call the function `foo` with two arguments, arg1 and arg2:\nfoo arg1 arg2\n# => Arguments work just like script arguments: arg1 arg2\n# => And: arg1 arg2...\n# => This is a function\n\n# or simply\nbar ()\n{\n    echo \"Another way to declare functions!\"\n    return 0\n}\n# Call the function `bar` with no arguments:\nbar # => Another way to declare functions!\n\n# Calling your function\nfoo \"My name is\" $Name\n\n# There are a lot of useful commands you should learn:\n# prints last 10 lines of file.txt\ntail -n 10 file.txt\n\n# prints first 10 lines of file.txt\nhead -n 10 file.txt\n\n# sort file.txt's lines\nsort file.txt\n\n# report or omit repeated lines, with -d it reports them\nuniq -d file.txt\n\n# prints only the first column before the ',' character\ncut -d ',' -f 1 file.txt\n\n# replaces every occurrence of 'okay' with 'great' in file.txt\n# (regex compatible)\nsed -i 's/okay/great/g' file.txt\n# be aware that this -i flag means that file.txt will be changed\n# -i or --in-place erase the input file (use --in-place=.backup to keep a back-up)\n\n# print to stdout all lines of file.txt which match some regex\n# The example prints lines which begin with \"foo\" and end in \"bar\"\ngrep \"^foo.*bar$\" file.txt\n\n# pass the option \"-c\" to instead print the number of lines matching the regex\ngrep -c \"^foo.*bar$\" file.txt\n\n# Other useful options are:\ngrep -r \"^foo.*bar$\" someDir/ # recursively `grep`\ngrep -n \"^foo.*bar$\" file.txt # give line numbers\ngrep -rI \"^foo.*bar$\" someDir/ # recursively `grep`, but ignore binary files\n\n# perform the same initial search, but filter out the lines containing \"baz\"\ngrep \"^foo.*bar$\" file.txt | grep -v \"baz\"\n\n# if you literally want to search for the string,\n# and not the regex, use `fgrep` (or `grep -F`)\nfgrep \"foobar\" file.txt\n\n# The `trap` command allows you to execute a command whenever your script\n# receives a signal. Here, `trap` will execute `rm` if it receives any of the\n# three listed signals.\ntrap \"rm $TEMP_FILE; exit\" SIGHUP SIGINT SIGTERM\n\n# `sudo` is used to perform commands as the superuser\n# usually it will ask interactively the password of superuser\nNAME1=$(whoami)\nNAME2=$(sudo whoami)\necho \"Was $NAME1, then became more powerful $NAME2\"\n\n# Read Bash shell built-ins documentation with the bash `help` built-in:\nhelp\nhelp help\nhelp for\nhelp return\nhelp source\nhelp .\n\n# Read Bash manpage documentation with `man`\napropos bash\nman 1 bash\nman bash\n\n# Read info documentation with `info` (`?` for help)\napropos info | grep '^info.*('\nman info\ninfo info\ninfo 5 info\n\n# Read bash info documentation:\ninfo bash\ninfo bash 'Bash Features'\ninfo bash 6\ninfo --apropos bash\n```"
