
package pages

const Coq = "The Coq system is a proof assistant. It is designed to build and verify mathematical proofs. The Coq system contains the functional programming language Gallina and is capable of proving properties about programs written in this language.\n\nCoq is a dependently typed language. This means that the types of the language may depend on the values of variables. In this respect, it is similar to other related languages such as Agda, Idris, F*, Lean, and others. Via the Curry-Howard correspondence, programs, properties and proofs are formalized in the same language.\n\nCoq is developed in OCaml and shares some syntactic and conceptual similarity with it. Coq is a language containing many fascinating but difficult topics. This tutorial will focus on the programming aspects of Coq, rather than the proving. It may be helpful, but not necessary to learn some OCaml first, especially if you are unfamiliar with functional programming. This tutorial is based upon its OCaml equivalent\n\nThe standard usage model of Coq is to write it with interactive tool assistance, which operates like a high powered REPL. Two common such editors are the CoqIDE and Proof General Emacs mode.\n\nInside Proof General `Ctrl+C Ctrl+<Enter>` will evaluate up to your cursor.\n\n\n```coq\n(*** Comments ***)\n\n(* Comments are enclosed in (* and *). It's fine to nest comments. *)\n\n(* There are no single-line comments. *)\n\n(*** Variables and functions ***)\n\n(* The Coq proof assistant can be controlled and queried by a command\n   language called the vernacular. Vernacular keywords are capitalized and\n   the commands end with a period.  Variable and function declarations are\n   formed with the Definition vernacular. *)\n\nDefinition x := 10.\n\n(* Coq can sometimes infer the types of arguments, but it is common practice\n   to annotate with types. *)\n\nDefinition inc_nat (x : nat) : nat := x + 1.\n\n(* There exists a large number of vernacular commands for querying\n   information.  These can be very useful. *)\n\nCompute (1 + 1). (* 2 : nat *) (* Compute a result. *)\n\nCheck tt. (* tt : unit *) (* Check the type of an expressions *)\n\nAbout plus. (* Prints information about an object *)\n\n(* Print information including the definition *)\nPrint true. (* Inductive bool : Set := true : Bool | false : Bool *)\n\nSearch nat. (* Returns a large list of nat related values *)\nSearch \"_ + _\". (* You can also search on patterns *)\nSearch (?a -> ?a -> bool). (* Patterns can have named parameters  *)\nSearch (?a * ?a).\n\n(* Locate tells you where notation is coming from. Very helpful when you\n   encounter new notation. *)\n\nLocate \"+\".\n\n(* Calling a function with insufficient number of arguments does not cause\n   an error, it produces a new function. *)\nDefinition make_inc x y := x + y. (* make_inc is int -> int -> int *)\nDefinition inc_2 := make_inc 2.   (* inc_2 is int -> int *)\nCompute inc_2 3. (* Evaluates to 5 *)\n\n\n(* Definitions can be chained with \"let ... in\" construct.  This is roughly\n   the same to assigning values to multiple variables before using them in\n   expressions in imperative languages. *)\n\nDefinition add_xy : nat := let x := 10 in\n                           let y := 20 in\n                           x + y.\n\n(* Pattern matching is somewhat similar to switch statement in imperative\n   languages, but offers a lot more expressive power. *)\n\nDefinition is_zero (x : nat) :=\n    match x with\n    | 0 => true\n    | _ => false  (* The \"_\" pattern means \"anything else\". *)\n    end.\n\n(* You can define recursive function definition using the Fixpoint\n   vernacular.*)\n\nFixpoint factorial n := match n with\n                        | 0 => 1\n                        | (S n') => n * factorial n'\n                        end.\n\n(* Function application usually doesn't need parentheses around arguments *)\nCompute factorial 5. (* 120 : nat *)\n\n(* ...unless the argument is an expression. *)\nCompute factorial (5-1). (* 24 : nat *)\n\n(* You can define mutually recursive functions using \"with\" *)\nFixpoint is_even (n : nat) : bool := match n with\n  | 0 => true\n  | (S n) => is_odd n\nend with\n  is_odd n := match n with\n  | 0 => false\n  | (S n) => is_even n\n              end.\n\n(* As Coq is a total programming language, it will only accept programs when\n   it can understand they terminate. It can be most easily seen when the\n   recursive call is on a pattern matched out subpiece of the input, as then\n   the input is always decreasing in size. Getting Coq to understand that\n   functions terminate is not always easy. See the references at the end of\n   the article for more on this topic. *)\n\n(* Anonymous functions use the following syntax: *)\n\nDefinition my_square : nat -> nat := fun x => x * x.\n\nDefinition my_id (A : Type) (x : A) : A := x.\nDefinition my_id2 : forall A : Type, A -> A := fun A x => x.\nCompute my_id nat 3. (* 3 : nat *)\n\n(* You can ask Coq to infer terms with an underscore *)\nCompute my_id _ 3.\n\n(* An implicit argument of a function is an argument which can be inferred\n   from contextual knowledge. Parameters enclosed in {} are implicit by\n   default *)\n\nDefinition my_id3 {A : Type} (x : A) : A := x.\nCompute my_id3 3. (* 3 : nat *)\n\n(* Sometimes it may be necessary to turn this off. You can make all\n   arguments explicit again with @ *)\n\nCompute @my_id3 nat 3.\n\n(* Or give arguments by name *)\nCompute my_id3 (A:=nat) 3.\n\n(* Coq has the ability to extract code to OCaml, Haskell, and Scheme *)\nRequire Extraction.\nExtraction Language OCaml.\nExtraction \"factorial.ml\" factorial.\n(* The above produces a file factorial.ml and factorial.mli that holds:\n\ntype nat =\n| O\n| S of nat\n\n(** val add : nat -> nat -> nat **)\n\nlet rec add n m =\n  match n with\n  | O -> m\n  | S p -> S (add p m)\n\n(** val mul : nat -> nat -> nat **)\n\nlet rec mul n m =\n  match n with\n  | O -> O\n  | S p -> add m (mul p m)\n\n(** val factorial : nat -> nat **)\n\nlet rec factorial n = match n with\n| O -> S O\n| S n' -> mul n (factorial n')\n*)\n\n\n(*** Notation ***)\n\n(* Coq has a very powerful Notation system that can be used to write\n   expressions in more natural forms. *)\n\nCompute Nat.add 3 4. (* 7 : nat *)\nCompute 3 + 4. (* 7 : nat *)\n\n(* Notation is a syntactic transformation applied to the text of the program\n   before being evaluated. Notation is organized into notation scopes. Using\n   different notation scopes allows for a weak notion of overloading. *)\n\n(* Imports the Zarith module holding definitions related to the integers Z *)\n\nRequire Import ZArith.\n\n(* Notation scopes can be opened *)\nOpen Scope Z_scope.\n\n(* Now numerals and addition are defined on the integers. *)\nCompute 1 + 7. (* 8 : Z *)\n\n(* Integer equality checking *)\nCompute 1 =? 2. (* false : bool *)\n\n(* Locate is useful for finding the origin and definition of notations *)\nLocate \"_ =? _\". (* Z.eqb x y : Z_scope *)\nClose Scope Z_scope.\n\n(* We're back to nat being the default interpretation of \"+\" *)\nCompute 1 + 7. (* 8 : nat *)\n\n(* Scopes can also be opened inline with the shorthand % *)\nCompute (3 * -7)%Z. (* -21%Z : Z *)\n\n(* Coq declares by default the following interpretation scopes: core_scope,\n   type_scope, function_scope, nat_scope, bool_scope, list_scope, int_scope,\n   uint_scope. You may also want the numerical scopes Z_scope (integers) and\n   Q_scope (fractions) held in the ZArith and QArith module respectively. *)\n\n(* You can print the contents of scopes *)\nPrint Scope nat_scope.\n(*\nScope nat_scope\nDelimiting key is nat\nBound to classes nat Nat.t\n\"x 'mod' y\" := Nat.modulo x y\n\"x ^ y\" := Nat.pow x y\n\"x ?= y\" := Nat.compare x y\n\"x >= y\" := ge x y\n\"x > y\" := gt x y\n\"x =? y\" := Nat.eqb x y\n\"x <? y\" := Nat.ltb x y\n\"x <=? y\" := Nat.leb x y\n\"x <= y <= z\" := and (le x y) (le y z)\n\"x <= y < z\" := and (le x y) (lt y z)\n\"n <= m\" := le n m\n\"x < y <= z\" := and (lt x y) (le y z)\n\"x < y < z\" := and (lt x y) (lt y z)\n\"x < y\" := lt x y\n\"x / y\" := Nat.div x y\n\"x - y\" := Init.Nat.sub x y\n\"x + y\" := Init.Nat.add x y\n\"x * y\" := Init.Nat.mul x y\n*)\n\n(* Coq has exact fractions available as the type Q in the QArith module.\n   Floating point numbers and real numbers are also available but are a more\n   advanced topic, as proving properties about them is rather tricky. *)\n\nRequire Import QArith.\n\nOpen Scope Q_scope.\nCompute 1. (* 1 : Q *)\n\n(* Only 1 and 0 are interpreted as fractions by Q_scope *)\nCompute 2. (* 2 : nat *)\nCompute (2 # 3). (* The fraction 2/3 *)\nCompute (1 # 3) ?= (2 # 6). (* Eq : comparison *)\nClose Scope Q_scope.\n\nCompute ( (2 # 3) / (1 # 5) )%Q. (* 10 # 3 : Q *)\n\n\n(*** Common data structures ***)\n\n(* Many common data types are included in the standard library *)\n\n(* The unit type has exactly one value, tt *)\nCheck tt. (* tt : unit *)\n\n(* The option type is useful for expressing computations that might fail *)\nCompute None. (* None : option ?A *)\nCheck Some 3. (* Some 3 : option nat *)\n\n(* The type sum A B allows for values of either type A or type B *)\nPrint sum.\nCheck inl 3. (* inl 3 : nat + ?B *)\nCheck inr true. (* inr true : ?A + bool *)\nCheck sum bool nat. (* (bool + nat)%type : Set *)\nCheck (bool + nat)%type. (* Notation for sum *)\n\n(* Tuples are (optionally) enclosed in parentheses, items are separated\n   by commas. *)\nCheck (1, true). (* (1, true) : nat * bool *)\nCompute prod nat bool. (* (nat * bool)%type : Set *)\n\nDefinition my_fst {A B : Type} (x : A * B) : A := match x with\n                                                  | (a,b) => a\n                                                  end.\n\n(* A destructuring let is available if a pattern match is irrefutable *)\nDefinition my_fst2 {A B : Type} (x : A * B) : A := let (a,b) := x in\n                                                   a.\n\n(*** Lists ***)\n\n(* Lists are built by using cons and nil or by using notation available in\n   list_scope. *)\nCompute cons 1 (cons 2 (cons 3 nil)). (*  (1 :: 2 :: 3 :: nil)%list : list nat *)\nCompute (1 :: 2 :: 3 :: nil)%list.\n\n(* There is also list notation available in the ListNotations modules *)\nRequire Import List.\nImport ListNotations.\nCompute [1 ; 2 ; 3]. (* [1; 2; 3] : list nat *)\n\n\n(* There is a large number of list manipulation functions available,\n   including:\n\n• length\n• head : first element (with default)\n• tail : all but first element\n• app : appending\n• rev : reverse\n• nth : accessing n-th element (with default)\n• map : applying a function\n• flat_map : applying a function returning lists\n• fold_left : iterator (from head to tail)\n• fold_right : iterator (from tail to head)\n\n *)\n\nDefinition my_list : list nat := [47; 18; 34].\n\nCompute List.length my_list. (* 3 : nat *)\n\n(* All functions in coq must be total, so indexing requires a default value *)\nCompute List.nth 1 my_list 0. (* 18 : nat *)\nCompute List.map (fun x => x * 2) my_list. (* [94; 36; 68] : list nat *)\nCompute List.filter (fun x => Nat.eqb (Nat.modulo x 2) 0) my_list.\n                                               (* [18; 34] : list nat *)\nCompute (my_list ++ my_list)%list. (* [47; 18; 34; 47; 18; 34] : list nat *)\n\n(*** Strings ***)\n\nRequire Import Strings.String.\n\n(* Use double quotes for string literals. *)\nCompute \"hi\"%string.\n\nOpen Scope string_scope.\n\n(* Strings can be concatenated with the \"++\" operator. *)\nCompute String.append \"Hello \" \"World\". (* \"Hello World\" : string *)\nCompute \"Hello \" ++ \"World\". (* \"Hello World\" : string *)\n\n(* Strings can be compared for equality *)\nCompute String.eqb \"Coq is fun!\" \"Coq is fun!\". (* true : bool *)\nCompute \"no\" =? \"way\". (* false : bool *)\n\nClose Scope string_scope.\n\n(*** Other Modules ***)\n\n(* Other Modules in the standard library that may be of interest:\n\n• Logic : Classical logic and dependent equality\n• Arith : Basic Peano arithmetic\n• PArith : Basic positive integer arithmetic\n• NArith : Basic binary natural number arithmetic\n• ZArith : Basic relative integer arithmetic\n\n• Numbers : Various approaches to natural, integer and cyclic numbers\n            (currently axiomatically and on top of 2^31 binary words)\n• Bool : Booleans (basic functions and results)\n\n• Lists : Monomorphic and polymorphic lists (basic functions and results),\n          Streams (infinite sequences defined with co-inductive types)\n• Sets : Sets (classical, constructive, finite, infinite, power set, etc.)\n• FSets : Specification and implementations of finite sets and finite maps\n          (by lists and by AVL trees)\n• Reals : Axiomatization of real numbers (classical, basic functions,\n          integer part, fractional part, limit, derivative, Cauchy series,\n          power series and results,...)\n• Relations : Relations (definitions and basic results)\n• Sorting : Sorted list (basic definitions and heapsort correctness)\n• Strings : 8-bits characters and strings\n• Wellfounded : Well-founded relations (basic results)\n *)\n\n(*** User-defined data types ***)\n\n(* Because Coq is dependently typed, defining type aliases is no different\n   than defining an alias for a value. *)\n\nDefinition my_three : nat := 3.\nDefinition my_nat : Type := nat.\n\n(* More interesting types can be defined using the Inductive vernacular.\n   Simple enumeration can be defined like so *)\n\nInductive ml := OCaml | StandardML | Coq.\nDefinition lang := Coq.  (* Has type \"ml\". *)\n\n(* For more complicated types, you will need to specify the types of the\n   constructors. *)\n\n(* Type constructors don't need to be empty. *)\nInductive my_number := plus_infinity\n                     | nat_value : nat -> my_number.\nCompute nat_value 3. (* nat_value 3 : my_number *)\n\n\n(* Record syntax is sugar for tuple-like types. It defines named accessor\n   functions for the components. Record types are defined with the notation\n   {...} *)\n\nRecord Point2d (A : Set) := mkPoint2d { x2 : A ; y2 : A }.\n(* Record values are constructed with the notation {|...|} *)\nDefinition mypoint : Point2d nat :=  {| x2 := 2 ; y2 := 3 |}.\nCompute x2 nat mypoint. (* 2 : nat *)\nCompute mypoint.(x2 nat). (* 2 : nat *)\n\n(* Types can be parameterized, like in this type for \"list of lists of\n   anything\". 'a can be substituted with any type. *)\n\nDefinition list_of_lists a := list (list a).\nDefinition list_list_nat := list_of_lists nat.\n\n(* Types can also be recursive. Like in this type analogous to\n   built-in list of naturals. *)\n\nInductive my_nat_list :=\n  EmptyList | NatList : nat -> my_nat_list -> my_nat_list.\n\nCompute NatList 1 EmptyList. (*  NatList 1 EmptyList : my_nat_list *)\n\n(** Matching type constructors **)\n\nInductive animal := Dog : string -> animal | Cat : string -> animal.\n\nDefinition say x :=\n    match x with\n    | Dog x => (x ++ \" says woof\")%string\n    | Cat x => (x ++ \" says meow\")%string\n    end.\n\nCompute say (Cat \"Fluffy\"). (* \"Fluffy says meow\". *)\n\n(** Traversing data structures with pattern matching **)\n\n(* Recursive types can be traversed with pattern matching easily.\n   Let's see how we can traverse a data structure of the built-in list type.\n   Even though the built-in cons (\"::\") looks like an infix operator,\n   it's actually a type constructor and can be matched like any other. *)\nFixpoint sum_list l :=\n    match l with\n    | [] => 0\n    | head :: tail => head + (sum_list tail)\n    end.\n\nCompute sum_list [1; 2; 3]. (* Evaluates to 6 *)\n\n\n(*** A Taste of Proving ***)\n\n(* Explaining the proof language is out of scope for this tutorial, but here\n   is a taste to whet your appetite. Check the resources below for more. *)\n\n(* A fascinating feature of dependently type based theorem provers is that\n   the same primitive constructs underly the proof language as the\n   programming features.  For example, we can write and prove the\n   proposition A and B implies A in raw Gallina *)\n\nDefinition my_theorem : forall A B, A /\\ B -> A :=\n  fun A B ab => match ab with\n                  | (conj a b) => a\n                end.\n\n(* Or we can prove it using tactics. Tactics are a macro language to help\n   build proof terms in a more natural style and automate away some\n   drudgery. *)\n\nTheorem my_theorem2 : forall A B, A /\\ B -> A.\nProof.\n  intros A B ab.  destruct ab as [ a b ]. apply a.\nQed.\n\n(* We can prove easily prove simple polynomial equalities using the\n   automated tactic ring. *)\n\nRequire Import Ring.\nRequire Import Arith.\nTheorem simple_poly : forall (x : nat), (x + 1) * (x + 2) = x * x + 3 * x + 2.\n  Proof. intros. ring. Qed.\n\n(* Here we prove the closed form for the sum of all numbers 1 to n using\n   induction *)\n\nFixpoint sumn (n : nat) : nat :=\n  match n with\n  | 0 => 0\n  | (S n') => n + (sumn n')\n  end.\n\nTheorem sum_formula : forall n, 2 * (sumn n) = (n + 1) * n.\nProof. intros n. induction n.\n       - reflexivity. (* 0 = 0 base case *)\n       - simpl. ring [IHn]. (* induction step *)\nQed.\n```\n\nWith this we have only scratched the surface of Coq. It is a massive\necosystem with many interesting and peculiar topics leading all the way up\nto modern research.\n\n## Further reading\n\n* [The Coq reference manual](https://coq.inria.fr/refman/)\n* [Software Foundations](https://softwarefoundations.cis.upenn.edu/)\n* [Certified Programming with Dependent Types](http://adam.chlipala.net/cpdt/)\n* [Mathematical Components](https://math-comp.github.io/mcb/)\n* [Coq'Art: The Calculus of Inductive Constructions](http://www.cse.chalmers.se/research/group/logic/TypesSS05/resources/coq/CoqArt/)\n* [FRAP](http://adam.chlipala.net/frap/)"
